* $Id: tfc_calc_delta.F,v 1.2 1998/01/27 01:14:50 fisyak Exp $
* $Log: tfc_calc_delta.F,v $
* Revision 1.2  1998/01/27 01:14:50  fisyak
* Split sources
*
CC:>--------------------------------------------------------------------
CC: FILE:       tfc_calc_delta.F
CC: HISTORY:
CC:             00jan96-v000a-hpl- Created by stic Version
CC:		30-Sept-96	Original routine by Nathan Stone
CC:  Id: 
CC:<--------------------------------------------------------------------

      INTEGER*4 FUNCTION TFC_CALC_DELTA(
     1             tphit_h,             tphit ,
     2             delta_h,             delta ) 

      IMPLICIT NONE
#include "tfc_calc_delta.inc"

CC:>--------------------------------------------------------------------
CC: ROUTINE:    TFC_CALC_DELTA
CC: DESCRIPTION: This routine takes the locations of hits, output from
CC:		the hit-finder, and calculates the separation between
CC:		hits residing in the same row.
CC:
CC:             This is a FORTRAN 77 Physics Analysis Module template
CC:             automatically generated by stic Version
CC:        Id: 
CC:             from tfc_calc_delta.idl.
CC:             Please edit comments and code.
CC:
CC: AUTHOR:     Nathan T.B. Stone
CC:
CC: ARGUMENTS:
CC:          IN:
CC:            tphit     - TCL hit table
CC:          tphit_h     - Header Structure for tphit
CC:       INOUT:
CC:         OUT:
CC:            delta     - table of coordinate separations
CC:          delta_h     - Header Structure for delta
CC: RETURNS:    STAF Condition Value
CC:>--------------------------------------------------------------------

	integer		i, j, k
	integer		Nrows_max		! Max # of rows in a sector
	parameter	(Nrows_max = 45)

	integer		Nhits			! # of hits in this row
	integer		Nhits_max		! Max # "    "   "   "
	parameter	(Nhits_max = 20)
	integer		HitList(Nhits_max)	! list of hit indeces
	integer		inok			! counter for delta_h.nok
	integer		HLj, HLk		! HitList counters

	integer		ievent/0/
	save		ievent

c -----	Make sure incoming tables look ok.
	if ((tphit_h.maxlen.le.0) .or. (tphit_h.nok.gt.tphit_h.maxlen)) then
	  write (6,*) 'CALC_DELTA: !!! Poorly defined table: TPHIT !!!'
	  goto 999
	endif

	if ((delta_h.maxlen.le.0) .or. (delta_h.nok.gt.delta_h.maxlen)) then
	  write (6,*) 'CALC_DELTA: !!! Poorly defined table: DELTA !!!'
	  goto 999
	endif

c -----	Loop over all rows.
c	1) Count hits in each row
c		- only perform calculations for rows with < N hits
c	2) Loop over all permutations of hits
c	3) Catalog relative separations

c -----	Look for all possible permutations
	ievent = ievent + 1				! event counter
	do i = 100, 100+Nrows_max			! loop over rows
	  Nhits = 0
	  do j = 1, tphit_h.nok				! loop over all hits
	    if (tphit(j).row .eq. i) then		! count it...
	      Nhits = Nhits + 1
	      if (Nhits.le.Nhits_max) then		! store it...
	        HitList(Nhits) = j
	      endif
	    endif
	  enddo	! loop over all hits

c	  write (6,*) 'CALC_DELTA: Row ', i, ', Nhits = ', Nhits

	  if (Nhits.gt.Nhits_max) then
	    write (6,*) 'CALC_DELTA: !!! Nhits > Nhits_max: row=', i,
	2	', Nhits=', Nhits, ', event=', ievent
	  else
	    if (delta_h.nok+int(0.5*Nhits*(Nhits+1)).gt.delta_h.maxlen) then
	      write (6,*) 'CALC_DELTA: !!! Not enough room in DELTA '//
	2	'for this row !!! Nhits = ', Nhits
	    else
	      do j = 1, Nhits-1
	        do k = j+1, Nhits
	          delta_h.nok = delta_h.nok + 1
	          inok = delta_h.nok
	          HLj = HitList(j)
	          HLk = HitList(k)

c	Current row and number of hits
	          delta(inok).event = ievent
	          delta(inok).row = i
	          delta(inok).hits = Nhits

c	Hit locations
	          delta(inok).x1 = tphit(HLj).x
	          delta(inok).y1 = tphit(HLj).y
	          delta(inok).z1 = tphit(HLj).z
	          delta(inok).x2 = tphit(HLk).x
	          delta(inok).y2 = tphit(HLk).y
	          delta(inok).z2 = tphit(HLk).z

c	Simple cartesian separations
	          delta(inok).dx = abs( tphit(HLj).x - tphit(HLk).x )
	          delta(inok).dy = abs( tphit(HLj).y - tphit(HLk).y )
	          delta(inok).dz = abs( tphit(HLj).z - tphit(HLk).z )

c	Radial (cylindrical and 3D) separations
	          delta(inok).dr = 
	2		sqrt( delta(inok).dx**2 + delta(inok).dy**2 )
	          delta(inok).d3 = 
	2		sqrt( delta(inok).dr**2 + delta(inok).dz**2 )

	        enddo
	      enddo
	    endif	! nok+().gt.maxlen
	  endif		! Nhits.gt.Nhits_max
	enddo		! loop over rows



c -----	Successful completion of analysis module...
998	TFC_CALC_DELTA = STAFCV_OK
	RETURN

c -----	Unsuccessful completion of analysis module...
999	TFC_CALC_DELTA = STAFCV_BAD
	RETURN

	END
