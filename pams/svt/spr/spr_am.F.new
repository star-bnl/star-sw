C -*- mode:fortran; compile-command:"cd ../; make; cd src"; -*- 
C MUST FIX:
! id_mctrack array is not used.
! flag() array shouldn't be used
! The globtrk(i).id_hypo_pid kludge
!
C2345678901234567890123456789012345678901234567890123456789012345678901
!********************************************************************

      INTEGER*4 FUNCTION SPR_AM(
     1     sprpar_h,            sprpar ,
     2     mhits_svt_h,         mhits_svt ,
     3     g2t_track_h,         g2t_track ,
     4     mkine_h,             mkine ,
     5     svt_geom_h,          svt_geom ,
     6     svt_ctrack_h,        svt_ctrack ,
     7     svt_dtrack_h,        svt_dtrack ,
     8     svt_mctrack_h,       svt_mctrack ,
     9     svt_spt_h,           svt_spt ,
     9     svt_track_h,         svt_track ,
     9     globtrk_h,           globtrk ,
     9     hypo_pid_h,          hypo_pid ) 


!********************************************************************
!...Title      : The dE/dx and pid information for the SVT in STAR  *
!                                                                   *
!...Author     : Stathes Paganis (U.T. Austin) Nov/14/93            *
!                                                                   *
!...Description: This module takes the energy dE deposited in the   *
!                Si wafers and divides it by the traversed length.  *
!                The dE/dx is in GeV/cm.                            *
!                The dE is read from Geant and the dx is calculated *
!                from the wafer orientation information that module *
!                svg provides.                                      *
!                The pid is recorded in svt_track.pid and contains  *
!                the probability that the particular track          *
!                belongs to a pion proton, kaon or electron.        *
!                For a full description for the pid see under www.  *
!                                                                   *
!...Status     : Tested (11/18/93)                                  *
!                Updated to give pid (1/10/94)                      *
!                                                                   *
!                Modified by L. Ray to use global track momentum    *
!                from globtrk (if available) for method = 3;        *
!                removed some probability = 0 statements from       *
!                Subroutine gaussf                                  *
!                Date: 10/17/94                                     *
!********************************************************************

      IMPLICIT NONE

!********************************************************************
!                         Includes                                  *
!********************************************************************

#include "spr_am.inc"

!********************************************************************

      INTEGER   icount(22),noka,igr,iwa,ind,jk,
     @          kj,j,q1,l,jj,k,nok,i,ii,itra1,npt

      COMMON/RESET_I/icount,noka,igr,iwa,ind,jk,
     @               kj,j,q1,l,jj,k,nok,i,ii,itra1,npt

      INTEGER*4    im,ik,ievent,ll
      INTEGER*4    itra,dimx,dimy,ikk,sc_rows
      INTEGER*4    flag(1)
      REAL         pi_id,ka_id,pr_id

      PARAMETER (dimx=15000,dimy=5,sc_rows=3000)
      REAL       alena,atota,adea,axtot,trun,pid_check,sig(3)
      REAL       de(dimx,dimy),ptot(dimx,dimy),costhe(dimx,dimy)
      REAL       xco(dimx,dimy),yco(dimx,dimy),zco(dimx,dimy)
      REAL       xx(dimx,dimy),yy(dimx,dimy),zz(dimx,dimy)
      REAL       el_id,sigma_dev(4),id(dimx,dimy)
      REAL       momentum(sc_rows),hypo(dimx),dei(3),range
      REAL       delapse,timearray(2),dtime,p_improved,pt,p_cutoff

      INTEGER    track_id(sc_rows),id_mctrack(sc_rows)
      INTEGER    track_rows,h_row,max_id,MAXIZE,imp_track,pouts
      INTEGER    id_globtrk(sc_rows),track_spt(6,sc_rows)
      INTEGER    irtrk(dimx,dimy)
      INTEGER    globtrk_row(10000)

      !**************************************************************

      !delapse=dtime(timearray)

      print *,'*****************************************************'
      print *,'*            dE/dx and pid for the SVT              *'
      print *,'*  Hit data               : svt_spt_direct module   *'
      print *,'*  Wafer orientation      : svg module, svt_geom    *'
      print *,'*  Momentum reconstruction: sgr or stk              *'
      print *,'*  dE/dx - pid            : spr module              *'
      print *,'*****************************************************'


      ! Here I kludge id_hypo_pid until it is filled by some other module
      print *,'hypo_pid_h.nok',hypo_pid_h.nok
      if(hypo_pid_h.nok .eq. 0) then
         do i=1,svt_track_h.nok
            globtrk(i).id_hypo_pid = 0
         enddo
      endif

      !**************************************************************
      !                   Sanity Tests                              *
      !**************************************************************

      if(svt_track_h.nok .eq. 0) then
         print *,'SPR --> No nok rows in svt_track table'
         print *,'Program Aborting ...'
         stop
      endif

      CALL RESET_SVT

      !**************************************************************
      !                 Input Data                                  *
      !**************************************************************

      flag(1)  = sprpar(1).method
      p_cutoff = sprpar(1).p

c      do i=1,2000
c      svt_track(i).cov(1)  = 0.
c      svt_track(i).dedx(1) = 0.
c      svt_track(i).r0      = 0.
c      enddo  
CC
CC    Fill the pointer array for table globtrk:
CC
      do i = 1,10000
         globtrk_row(i) = 0
      end do
      do i = 1,globtrk_h.nok
         if(globtrk(i).id .gt. 0 .and. globtrk(i).id .le. 10000) then
            globtrk_row(globtrk(i).id) = i
         end if
      end do


      !**************************************************************
      !                 Multiple Input Selection                    *
      !**************************************************************

      if(flag(1).eq.1)then
         track_rows = svt_ctrack_h.nok
         do i=1,svt_ctrack_h.nok
            track_id(i)      = svt_ctrack(i).id
*yf         id_mctrack(i) = svt_ctrack(i).id_mctrack
*           do j=1,6
*              track_spt(j,i)    = svt_ctrack(i).spt(j)
*yf         enddo
         enddo
      elseif(flag(1).eq.2)then
         track_rows = svt_dtrack_h.nok
         do i=1,svt_dtrack_h.nok
            track_id(i)      = svt_dtrack(i).id
*yf         id_mctrack(i) = svt_dtrack(i).id_mctrack
*           do j=1,6
*              track_spt(j,i)    = svt_dtrack(i).spt(j)
*yf         enddo
         enddo
      elseif(flag(1).eq.3.or.flag(1).eq.5)then
         track_rows = svt_track_h.nok
         do i=1,svt_track_h.nok
            track_id(i)      = svt_track(i).id
*yf         id_mctrack(i) = svt_ctrack(i).id_mctrack

            !print *,i,id_mctrack(i)

            if(svt_track(i).id_globtrk .gt. 0) then
               id_globtrk(i) = globtrk_row(svt_track(i).id_globtrk)
               momentum(i) = (1.0/globtrk(id_globtrk(i)).invpt)
     @              *sqrt(1.0+(globtrk(id_globtrk(i)).tanl)**2)
            else
               !*****************************************************
               !* Here I set the globtrk pointer equal to the svt_tr*
               !* ack.id in the case it is zero ...                 *
               !*****************************************************

               id_globtrk(i) = svt_track(i).id

               !*****************************************************

               momentum(i)      = abs(1./(abs(svt_track(i).invpt)))
     @              *sqrt(1.0+svt_track(i).tanl**2)
            end if

*yf         do j=1,6
*              track_spt(j,i)    = svt_ctrack(i).spt(j)
*              !print *,'spt ',i,j,track_spt(j,i)
*yf         enddo
         enddo

         !***********************************************************
         ! Set max_id to the largest value of hypo_id.id            *
         !***********************************************************

         max_id = 0
         do i = 1,hypo_pid_h.nok
            if(hypo_pid(i).id .gt. max_id) max_id = hypo_pid(i).id
         end do
c      elseif(flag(1).eq.4)then
c      elseif(flag(1).eq.5)then
      endif

c        do ll=1,hypo_pid_h.nok
c           if(hypo_pid(ll).id.eq.0)then
c              h_row = ll
c              goto 4323
c           endif
c        enddo

      !**************************************************************
      ! Set current next row number in hypo_pid                     *
      !**************************************************************

      h_row = hypo_pid_h.nok + 1

      !**************************************************************

      !print *,'track_rows',track_rows
 4323 do i=1,track_rows
            
         !print *,'i,track_id',i,track_id(i)
         if(track_id(i).eq.0)then  
            goto 400
         endif   

         !print *,'i,id_globtrk',i,id_globtrk(i)

         ! The following is temporarily out
         if(id_globtrk(i) .eq. 0) go to 400

               k=0

               noka=track_id(i)
c                noka=noka+1
                   do jk=1,3
c                         ikk= track_spt(1,i)
                         ik = track_spt(jk,i)
                         if(ik.eq.0)then 
c                                noka=noka-1
                                goto 400
                         endif
                         k=jk
                         de(noka,k)  = svt_spt(ik).de(1)
                         xco(noka,k) = svt_spt(ik).x(1)
                         yco(noka,k) = svt_spt(ik).x(2)
                         zco(noka,k) = svt_spt(ik).x(3)
                         id(noka,k)  = svt_spt(ik).id_wafer
                         irtrk(noka,k) = svt_spt(ik).id_mctrack
                         pt          = SQRT(mkine(irtrk(noka,k)).p(1)*
     @                                      mkine(irtrk(noka,k)).p(1)
     @                                     +mkine(irtrk(noka,k)).p(2)
     @                                     *mkine(irtrk(noka,k)).p(2)
     @                                    +mkine(irtrk(noka,k)).p(3)
     @                                    *mkine(irtrk(noka,k)).p(3))

                       if(flag(1).eq.3.or.flag(1).eq.5)then
                       ptot(noka,1) = momentum(i)
                       else                       
                       ptot(noka,k) = SQRT(mkine(irtrk(noka,k)).p(1)*
     @                                     mkine(irtrk(noka,k)).p(1)
     @                                    +mkine(irtrk(noka,k)).p(2)
     @                                    *mkine(irtrk(noka,k)).p(2)
     @                                    +mkine(irtrk(noka,k)).p(3)
     @                                    *mkine(irtrk(noka,k)).p(3))
                       endif


                         if(k.eq.2)then
                         xx(noka,1) = xco(noka,2) - xco(noka,1)
                         yy(noka,1) = yco(noka,2) - yco(noka,1)
                         zz(noka,1) = zco(noka,2) - zco(noka,1)

                   do ind=1,svt_geom_h.nok
                      if(svt_geom(ind).id.eq.svt_spt(ik).id_wafer)then
                         iwa=ind
                         goto 1002
                      endif
                   enddo   
                   print *,'spr --> NO WAFER WAS FOUND IN svt_geom !!!'
 1002              costhe(noka,1) =ABS(svt_geom(iwa).n(1)*xx(noka,1)+
     @                                 svt_geom(iwa).n(2)*yy(noka,1)+
     @                                 svt_geom(iwa).n(3)*zz(noka,1))/
     @                            sqrt(xx(noka,1)*xx(noka,1)+
     @                                 yy(noka,1)*yy(noka,1)+
     @                                 zz(noka,1)*zz(noka,1))

                         endif
                   enddo
                   goto 201
c            endif    
c 202     enddo

      !**************************************************************
      ! Set current next row number in hypo_pid                     *
      !**************************************************************
C-------------   Straight line approximation  -------------------

 201     if(k.ge.3)then
            do kj=2,3
                   xx(noka,kj) = xco(noka,kj) - xco(noka,kj-1)
                   yy(noka,kj) = yco(noka,kj) - yco(noka,kj-1)
                   zz(noka,kj) = zco(noka,kj) - zco(noka,kj-1)

                   !print *,'svt_geom_h.nok',svt_geom_h.nok
                   do ind=1,svt_geom_h.nok
                      if(svt_geom(ind).id.eq.id(noka,kj))then
                         iwa=ind
                         goto 1005
                      endif
                   enddo   
                   goto 1006
 1005              costhe(noka,kj)=ABS(svt_geom(iwa).n(1)*xx(noka,kj)+
     @                                 svt_geom(iwa).n(2)*yy(noka,kj)+
     @                                 svt_geom(iwa).n(3)*zz(noka,kj))/
     @                            sqrt(xx(noka,kj)*xx(noka,kj)+
     @                                 yy(noka,kj)*yy(noka,kj)+
     @                                 zz(noka,kj)*zz(noka,kj))

 1006       enddo
         endif

            if(k.gt.1)then
            if(k.eq.2)then !GOOD ONLY FOR GEANT INPUT
c               noka=noka-1
               goto 400

            else  

      !**************************************************************
      ! Set current next row number in hypo_pid                     *
      !**************************************************************
C------------    Find the dE/dx       ---------------------------

               de(noka,1)=de(noka,1)*costhe(noka,1)/0.03
               de(noka,2)=de(noka,2)*costhe(noka,2)/0.03
               de(noka,3)=de(noka,3)*costhe(noka,3)/0.03

               !print *,'de1,de2,de3',de(noka,1),de(noka,2),de(noka,3)

               do q1=1,2
               do l=q1,2
                  if (de(noka,q1).gt.de(noka,l+1)) then
                     trun=de(noka,q1)
                     de(noka,q1)=de(noka,l+1)
                     de(noka,l+1)=trun
                  endif
               enddo
               enddo
               if(de(noka,1).eq.0.)then
                  icount(17) = icount(17) + 1

               endif

            svt_track(noka).dedx(1) = (de(noka,1)+de(noka,2))/2.
c            svt_track(noka).r0      = pt

            endif
            goto 200
         endif

         goto 400

         !***********************************************************
         !           Correct the momentum using dE/dx               *
         !***********************************************************

 200     if(flag(1).eq.5)then
            dei(1)=de(noka,1)
            dei(2)=de(noka,3)
            dei(3)=de(noka,2)

            range=0.4
            if(ptot(noka,1).lt.range.and.ptot(noka,1).gt.0.01)then
               call p_resol_improve(dei,0.2,ptot(noka,1),p_improved)
               if(abs(p_improved).lt.0.00000001)then
c     print *,'zero p_imp'
c     svt_track(noka).r0   = pt
                  goto 202
               endif
               svt_track(noka).invpt   = sqrt(1. + svt_track(noka).
     @              tanl**2)/p_improved
c     svt_track(noka).r0   = pt
c     svt_track(noka).z0   = p_improved
            else
c     svt_track(noka).r0   = pt
c     svt_track(noka).z0   = sqrt(1. + svt_track(noka).tanl**2)/
c     @abs(svt_track(noka).invpt)
            endif
         endif
         
         !***********************************************************
         !                 Particle Identification                  *
         !***********************************************************

 202     if(ptot(noka,1).lt.p_cutoff.and.ptot(noka,1).gt.0.01)then
            icount(18) = icount(18) + 1

            call particle_id(ptot(noka,1) , svt_track(noka).dedx(1),
     @           sigma_dev    , svt_track(noka).pid    )
            
            if(flag(1).eq.3)then

               if(globtrk(id_globtrk(i)).id_hypo_pid.ne.0)then
                  hypo_pid(h_row  ).id = globtrk(id_globtrk(i)).id_hypo_pid
                  hypo_pid(h_row+1).id = globtrk(id_globtrk(i)).id_hypo_pid
                  hypo_pid(h_row+2).id = globtrk(id_globtrk(i)).id_hypo_pid
                  hypo_pid(h_row+3).id = globtrk(id_globtrk(i)).id_hypo_pid
               else
                  globtrk(id_globtrk(i)).id_hypo_pid = max_id + 1
         !print *,'globtrk.id_hypo_pid',globtrk(id_globtrk(i)).id_hypo_pid

                  hypo_pid(h_row  ).id = max_id + 1
                  hypo_pid(h_row+1).id = hypo_pid(h_row).id
                  hypo_pid(h_row+2).id = hypo_pid(h_row).id
                  hypo_pid(h_row+3).id = hypo_pid(h_row).id
                  max_id = max_id + 1
               endif        


               hypo_pid(h_row  ).det   = 1
               hypo_pid(h_row+1).det   = 1
               hypo_pid(h_row+2).det   = 1
               hypo_pid(h_row+3).det   = 1
               hypo_pid(h_row  ).gid   = 2
               hypo_pid(h_row+1).gid   = 8
               hypo_pid(h_row+2).gid   = 11
               hypo_pid(h_row+3).gid   = 14
               hypo_pid(h_row  ).nsigma= sigma_dev(4)        
               hypo_pid(h_row+1).nsigma= sigma_dev(1)        
               hypo_pid(h_row+2).nsigma= sigma_dev(2)        
               hypo_pid(h_row+3).nsigma= sigma_dev(3)        
               hypo_pid(h_row  ).method= 2
               hypo_pid(h_row+1).method= 2
               hypo_pid(h_row+2).method= 2
               hypo_pid(h_row+3).method= 2

c        goto 4321
               el_id = int( svt_track(noka).pid/1000000.)
               pr_id = int((svt_track(noka).pid - el_id*1000000.)/10000.)
               ka_id = int((svt_track(noka).pid - el_id*1000000. 
     @              - pr_id*10000.)/100.)
               pi_id = int( svt_track(noka).pid - el_id*1000000. 
     @              - pr_id*10000. - ka_id*100.)
c     4321   continue

               hypo_pid(h_row  ).prob= el_id
               hypo_pid(h_row+1).prob= pi_id
               hypo_pid(h_row+2).prob= ka_id
               hypo_pid(h_row+3).prob= pr_id
               hypo_pid_h.nok        = h_row + 3

               h_row = h_row + 4
c     max_id= max_id+ 1
            endif

C----------- Evaluation for the pid (using sigma) ----------------------

c        goto 4322
            el_id = -abs(sigma_dev(4))
            pr_id = -abs(sigma_dev(3))
            ka_id = -abs(sigma_dev(2))
            pi_id = -abs(sigma_dev(1))
c 4322   continue
        
C------------------------------------------------------------------------

            if(pi_id.gt.ka_id.and.pi_id.gt.pr_id.and.pi_id.gt.el_id)then
               icount(1) = icount(1) + 1
               pi_id = 9
               ka_id = 0
               pr_id = 0
               el_id = 0
            elseif(ka_id.gt.pi_id.and.ka_id.gt.pr_id.and.ka_id.gt.el_id)then
               icount(2) = icount(2) + 1
               ka_id = 12
               pi_id = 0
               pr_id = 0
               el_id = 0
c     svt_track(noka).z0   = sqrt(1. + svt_track(noka).tanl**2)
c     @/abs(svt_track(noka).invpt)
               if(flag(1).eq.5)then
                  svt_track(noka).invpt   = svt_track(noka).invpt
               endif
            elseif(pr_id.gt.pi_id.and.pr_id.gt.ka_id.and.pr_id.gt.el_id)then
               icount(3) = icount(3) + 1
               pr_id = 15
               pi_id = 0
               ka_id = 0
               el_id = 0
c     svt_track(noka).z0   = sqrt(1. + svt_track(noka).tanl**2)
c     @/abs(svt_track(noka).invpt)
               if(flag(1).eq.5)then
                  svt_track(noka).invpt   = svt_track(noka).invpt
               endif
            elseif(el_id.gt.pi_id.and.el_id.gt.ka_id.and.el_id.gt.pr_id)then
               icount(4) = icount(4) + 1
               el_id = 2
               pr_id = 0
               pi_id = 0
               ka_id = 0
c     svt_track(noka).z0   = sqrt(1. + svt_track(noka).tanl**2)
c     @/abs(svt_track(noka).invpt)
               if(flag(1).eq.5)then
                  svt_track(noka).invpt   = svt_track(noka).invpt
               endif
            else
               pi_id = 0
               ka_id = 0
               pr_id = 0
               el_id = 0
c     svt_track(noka).z0   = sqrt(1. + svt_track(noka).tanl**2)
c     @/abs(svt_track(noka).invpt)
               if(flag(1).eq.5)then
                  svt_track(noka).invpt   = svt_track(noka).invpt
               endif
            endif   

            do itra=1,g2t_track_h.nok
*yf            if(g2t_track(itra).id.eq.svt_ctrack(noka).id_mctrack)then
* Caution:
*
* To find the pid one has to go the track struct.
                  pid_check=g2t_track(itra).ge_pid
* 
                  goto 380
*yf            else   
*                 pid_check=101
*yf            endif  
            enddo   


 380        if(pid_check.eq.101)then
               print *,'no-pid!!!!'
            endif  


            if(pid_check.eq.8.or.pid_check.eq.9)then
               icount(12) = icount(12) + 1
c     svt_track(noka).cov(1)=1.
            elseif(pid_check.eq.11.or.pid_check.eq.12)then   
               icount(6)= icount(6) + 1
c     svt_track(noka).cov(1)=2.
            elseif(pid_check.eq.14.or.pid_check.eq.15)then   
               icount(7)= icount(7) + 1
c     svt_track(noka).cov(1)=3.
            elseif(pid_check.eq.7)then
               icount(9)= icount(9) + 1
c     svt_track(noka).cov(1)=0.
            elseif(pid_check.eq.10)then
               icount(10)= icount(10) + 1
c     svt_track(noka).cov(1)=0.
            elseif(pid_check.eq.2.or.pid_check.eq.3)then
               icount(11)= icount(11) + 1
c     svt_track(noka).cov(1)=4.
            else
c     print *,'mc-particle id',pid_check
               icount(8)= icount(8)+ 1
c     svt_track(noka).cov(1)=0.
            endif   
            
            if(svt_track(noka).pid.le.0.01)then
               pi_id = 0
               ka_id = 0
               pr_id = 0
               el_id = 0
               icount(19)= icount(19)+ 1           
               goto 390
            endif   


            if(pid_check.eq.(pi_id-1).or.pid_check.eq.pi_id)then
               icount(16) = icount(16) + 1
            elseif(pid_check.eq.ka_id-1.or.pid_check.eq.ka_id)then
               icount(13) = icount(13) + 1
            elseif(pid_check.eq.pr_id-1.or.pid_check.eq.pr_id)then
               icount(14) = icount(14) + 1
            elseif(pid_check.eq.el_id+1.or.pid_check.eq.el_id)then
               icount(15) = icount(15) + 1
            else
               icount(19) = icount(19) + 1 
            endif   
            
cc 390    continue
 390     endif
 400  enddo

!-------------------  Print statements  -------------------------

      print *,'total 3-point tracks:           ',noka
      print *,'multipl. below p_cut',p_cutoff   ,icount(18)
      print *,'total mc-pions (+/-):           ',icount(12)
      print *,'total measured pions (+/-):     ',icount(1)
      print *,'succesfull pions:               ',icount(16)
      print *,'total mc-kaons:                 ',icount(6)      
      print *,'total measured kaons:           ',icount(2)
      print *,'succesfull kaons:               ',icount(13)
      print *,'total mc-protons:               ',icount(7)
      print *,'total measured protons:         ',icount(3)
      print *,'succesfull protons:             ',icount(14)
      print *,'total mc e+e-:                  ',icount(11)
      print *,'total measured e+e-:            ',icount(4)
      print *,'succesfull e+e-:                ',icount(15)
      print *,'total mc pi0:                   ',icount(9)
      print *,'total mc K0:                    ',icount(10)
      print *,'total others:                   ',icount(8)
      print *,'failed :                        ',icount(19)
      print *,'zero minimum de points:         ',icount(17)

C-----------------------------------------------------------------

c      svt_track_h.nok=noka
c      hypo_pid_h.nok = h_row + 4

c      delapse=dtime(timearray)
c      print *,'SPR --> User   time:',timearray(1)      
c      print *,'SPR --> System time:',timearray(2)      
      
      !call set_staf_result_(1)
      print *,'epi_hypo_pid_h.nok=',hypo_pid_h.nok

      spr_am = STAFCV_OK
      RETURN
      END

C-----------------------------------------------------------------
C*****************************************************************

      subroutine particle_id(ptot,dedx,dedx_diff,apid)

!*****************************************************************
!                                                                *
! Title : Particle Identification using the SVT dE/dx.           *
! Author: S. Paganis (U.T.) (1/11/94)                            *
!*****************************************************************

      implicit none
      integer q,l,possib(4),ic
      real    ypion,ptot,ykaon,yprot,yelec,dedx,asigma(5)
      real    dedx_diff(4),err,poss,apid,sig(5)

c      goto 4323
      if(ptot.lt.0.1)then
c         asigma(1)=0.0026
         asigma(1)=ypion(ptot)*0.14
         asigma(2)=ykaon(ptot)*0.14
c         asigma(2)=0.0025
         asigma(3)=yprot(ptot)*0.13
      elseif(ptot.lt.0.15)then
         asigma(1)=0.00166
         asigma(2)=ykaon(ptot)*0.14
c         asigma(2)=0.0025
         asigma(3)=yprot(ptot)*0.13   
      elseif(ptot.lt.0.2)then
         asigma(1)=0.00166
         asigma(2)=0.0025
         asigma(3)=yprot(ptot)*0.13
      elseif(ptot.lt.0.25)then
         asigma(1)=0.001667
         asigma(2)=0.001667
         asigma(3)=0.0032
      elseif(ptot.lt.0.3)then
         asigma(1)=0.00093
         asigma(2)=0.0012
         asigma(3)=0.0028
      elseif(ptot.lt.0.35)then
         asigma(1)=0.00066
         asigma(2)=0.00093
         asigma(3)=0.0024
      elseif(ptot.lt.0.4)then
         asigma(1)=0.0005
         asigma(2)=0.00066
         asigma(3)=0.00175
      elseif(ptot.lt.0.45)then
         asigma(1)=0.00046
         asigma(2)=0.00066
         asigma(3)=0.001375
      elseif(ptot.lt.0.5)then
         asigma(1)=0.00046
         asigma(2)=0.0005333
         asigma(3)=0.0012
      elseif(ptot.lt.0.55)then
         asigma(1)=0.00046
         asigma(2)=0.000467
         asigma(3)=0.001333
      elseif(ptot.lt.0.6)then
         asigma(1)=0.00046
         asigma(2)=0.000467
         asigma(3)=0.0009333
      elseif(ptot.lt.0.65)then
         asigma(1)=0.0004
         asigma(2)=0.0004
         asigma(3)=0.0008666      
      elseif(ptot.lt.0.7)then
         asigma(1)=0.000333
         asigma(2)=0.000333
         asigma(3)=0.0007333
      elseif(ptot.lt.0.75)then
         asigma(1)=0.0002
         asigma(2)=0.0002
         asigma(3)=0.00055
      elseif(ptot.lt.0.8)then
         asigma(1)=0.0002
         asigma(2)=0.0002
         asigma(3)=0.0005
      endif
c 4323 continue

c      asigma(1)=ypion(ptot)*0.14
      call gaussf(ypion(ptot),asigma(1),dedx,10,poss)
      if(poss.lt.0.01)then
         possib(1)=0
      elseif(poss.gt.0.99)then
         possib(1)=99
c     elseif(poss.gt.1.)then
c        possib(1)=0
      else   
      possib(1)=int(100.*poss)
      endif

c      asigma(2)=ykaon(ptot)*0.14
      call gaussf(ykaon(ptot),asigma(2),dedx,10,poss)
      if(poss.lt.0.01)then
         possib(2)=0
      elseif(poss.gt.0.99)then
         possib(2)=99
c     elseif(poss.gt.1.)then
c        possib(2)=0
      else   
      possib(2)=int(100.*poss)
      endif

c      asigma(3)=yprot(ptot)*0.13
      call gaussf(yprot(ptot),asigma(3),dedx,10,poss)
      if(poss.lt.0.01)then
         possib(3)=0
      elseif(poss.gt.0.99)then
         possib(3)=99
c     elseif(poss.gt.1.)then
c        possib(3)=0
      else   
      possib(3)=int(100.*poss)
      endif

      asigma(4)=0.00028/3.
      call gaussf(yelec(ptot),asigma(4),dedx,10,poss)
      if(poss.lt.0.01)then
         possib(4)=0
      elseif(poss.gt.0.99)then
         possib(4)=99
c     elseif(poss.gt.1.)then
c        possib(4)=0
      else   
      possib(4)=int(100.*poss)
      endif

!------------- Relative probability-pid number ------------------

      apid =float(1*(possib(1)) + 100*(possib(2)) + 
     @    10000*(possib(3)) + 1000000*(possib(4)))

!------------- How many sigmas away from the mean? ---------------

      dedx_diff(1) = (dedx-ypion(ptot))/asigma(1)
      dedx_diff(2) = (dedx-ykaon(ptot))/asigma(2)
      dedx_diff(3) = (dedx-yprot(ptot))/asigma(3)
      dedx_diff(4) = (dedx-yelec(ptot))/asigma(4)


      return
      end

C----------------------------------------------------------------
C----------------------------------------------------------------

      subroutine gaussf(mean,sigma,start,n,possib)
C.....NUMERICAL LINEAR INTEGRATION OF THE GAUSSIAN DENSITY
C.....              PROBABILITY FUNCTION
C.....E.Paganis (U.T)
      implicit none
      integer i,n
      real sigma,mean,x(50),y(50),dx,dy,step,start
      real gaussian,possib

c     if(abs(mean-start).gt.(3.1*sigma))then
c           possib=0.
c           return
c     endif
     
      x(1)=start
      y(1)=gaussian(start,mean,sigma)

      step=(mean-start)/n
      possib=0.

      do i=1,n
         x(i+1)=x(i)+step
         y(i+1)=gaussian(x(i+1),mean,sigma)
         dy = abs(y(i+1) - y(i))
         possib = abs(step)*(dy/2. + y(i)) + possib
      enddo   
      if(possib.gt.0.5)then
         possib=0.
         return
      endif   
      possib = 2.*(0.5 - possib)

      return   
      end

C-----------------------------------------------------------------
C-----------------------------------------------------------------

      real function gaussian(x,mean,sigma)
      implicit none
      real x,pi,sigma,mean
      pi = acos(-1.)
      gaussian = exp(-(x-mean)*(x-mean)/(2.*sigma*sigma))/
     @           (sigma*sqrt(2.*pi))
      end

C-----------------------------------------------------------------
C-----------------------------------------------------------------

      FUNCTION ypion(ptot)


      REAL ypion,ptot

      ypion = 0.0326778 - 0.563*ptot + 4.818536*ptot*ptot 
     @ - 23.6057*ptot*ptot*ptot + 71.49886*ptot*ptot*ptot*ptot
     @ - 137.44698*ptot*ptot*ptot*ptot*ptot
     @ + 166.42779*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 121.22428*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ + 47.37461*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 7.2874*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot

      END

C-----------------------------------------------------------------
C-----------------------------------------------------------------

      FUNCTION ykaon(ptot)


      REAL ykaon,ptot

      ykaon = 0.5513644107 - 12.415704621*ptot + 129.8180929*ptot*ptot 
     @ - 782.49481527*ptot*ptot*ptot + 2942.9046905*ptot*ptot*ptot*ptot
     @ - 7120.2280777*ptot*ptot*ptot*ptot*ptot 
     @ + 11074.771039*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 10694.485339*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ + 5831.8563062*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 1371.8853736*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot

      END

C-----------------------------------------------------------------
C-----------------------------------------------------------------

      FUNCTION yprot(ptot)


      REAL yprot,ptot

      yprot = 1.4594 -29.281*ptot + 273.81*ptot*ptot 
     @ - 1498.3*ptot*ptot*ptot + 5209.6*ptot*ptot*ptot*ptot
     @ - 11860*ptot*ptot*ptot*ptot*ptot 
     @ + 17628*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 16475*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ + 8784*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot
     @ - 2036.3*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot*ptot

c      yprot = 0.13848 - 0.793*ptot + 2.0796*ptot*ptot 
c     @ - 2.911*ptot*ptot*ptot + 2.1179*ptot*ptot*ptot*ptot
c     @ - 0.6296*ptot*ptot*ptot*ptot*ptot

      END

C-----------------------------------------------------------------
C-----------------------------------------------------------------

      FUNCTION yelec(ptot)

      REAL yelec,ptot

      yelec = 0.0032133 + 0.00024182*ptot

      END

C----------------------------------------------------------------------

      INTEGER FUNCTION reset_svt

      implicit none

      integer icount,noka,igr,iwa,ind,jk,kj,j,q1,l,jj,k,nok,i,ii,
     @        itra1,npt
      COMMON/RESET_I/icount(22),noka,igr,iwa,ind,jk,kj,j,q1,l,jj,
     @               k,nok,i,ii,itra1,npt

      integer jcount

      noka=0
      igr=0
      iwa=0
      ind=0
      jk=0
      kj=0
      j=0
      q1=0
      l=0
      jj = 0
      k=0
      nok=0
      npt=0
      i=0
      itra1=0
      ii=0
      do jcount=1,22
      icount(jcount)=0
      enddo

      return
      end

C-------------------------------------------------------------------
C-------------------------------------------------------------------

      SUBROUTINE P_RESOL_IMPROVE(dedx,range,p_recon,p_improved)

      implicit none
      integer i,l,q,irange
      real dedx(3),yrms(500),ypt,ptot,step,p_improved,p(500),minimum,pin
      real tru,trun,ykaon,ypion,yrmsk(500),p_recon,ykt,yproton,range

      i=1
      step = 0.001
      p(1) = 0.06
 10   ptot = p(i)

!------------------ SET THE CONTAMINATION ACCEPTANCE ---------------

c      if(p_recon.lt.range)then
c         ypt = ypion(ptot)
c      elseif(dedx(1).le.(ypion(p_recon)/2.+ykaon(p_recon)/2.))then
         ypt = ypion(ptot)
c      else   
c         ypt = ykaon(ptot)
c      endif

!-------------------   PROCEED  ------------------------------------

c      print *,'dedx(1),dedx(2),ptot',dedx(1),dedx(2),ptot
c      print *,'dedx(ptot)',ypt

      yrms(i) = abs((dedx(1)+dedx(3))/2. - ypt)
c       yrms(i) = SQRT((dedx(1)-ypt)*(dedx(1)-ypt)+(dedx(3)-ypt)
c*(dedx(3)-ypt))
c     @               (dedx(3)-ypt)*(dedx(3)-ypt))

         irange = int((range-0.06)*1000.)
      if(i.gt.irange)then

               do q=1,i
               do l=q,i
                  if (yrms(q).gt.yrms(l+1)) then
                     trun=yrms(q)
                     yrms(q)=yrms(l+1)
                     yrms(l+1)=trun
                     tru = p(q)
                     p(q)= p(l+1)
                     p(l+1) = tru
                  endif
               enddo
               enddo

!-------------- BOUNDARY CONDITIONS  ---------------------------

               if(abs(p(1)-0.06).le.0.00001.or.abs(p(1)-RANGE)
     @                          .le.0.00001)then
                  p_improved = p_recon
                  return
               else
                  p_improved = p(1)
                  return
               endif   
      endif

      p(i+1) = p(i) + step
      i = i + 1
      goto 10

      end

C---------------------------------------------------------------
