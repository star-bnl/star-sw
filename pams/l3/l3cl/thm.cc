/*:>--------------------------------------------------------------------
**: FILE:       thm.c.template
**: HISTORY:
**:             15June98v000a-Md - Created by Martin Demello
**:              3July98v000a-PPY- Modified by Pablo Yepes   
**:<------------------------------------------------------------------*/


// Version 2.0 - Last modified Jun 15 '98
// Version 2.1 - Last modified Jul  3 '98

#include "thm.h"
#include "thmCell.hpp"
#include <iostream.h>


typedef thmCell* PthmCell;
int thmGetCell(mHitElt M, THM_CTRL_ST* ctrl) ;
int thmGetCell(tHitElt T, THM_CTRL_ST* ctrl) ;
long thmSetParameters ( THM_CTRL_ST* ctrl );


extern "C" long thm_(
  TABLE_HEAD_ST           *ctrlH,       THM_CTRL_ST             *ctrl ,
  TABLE_HEAD_ST           *mHitH,    G2T_TPC_HIT_ST             *mHit ,
  TABLE_HEAD_ST           *tHitH,      TCL_TPHIT_ST             *tHit ,
  TABLE_HEAD_ST          *matchH,  TCL_TPC_INDEX_ST            *match,  
  TABLE_HEAD_ST          *evalH,   THM_EVALUATION_ST           *eval  )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    thm_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from thm.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:               mhit    - PLEASE FILL IN DESCRIPTION HERE
**:              mhit_h   - header Structure for mhit
**:               thit    - PLEASE FILL IN DESCRIPTION HERE
**:              thit_h   - header Structure for thit
**:    INOUT:
**:               ctrl    - PLEASE FILL IN DESCRIPTION HERE
**:              ctrl_h   - header Structure for ctrl
**:      OUT:
**:               match    - PLEASE FILL IN DESCRIPTION HERE
**:              match_h   - header Structure for match
**:              
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/
//
//    Make sure we are getting something meaningful
//
   if ( ctrlH->nok != 1 ) {
      cout<<" thm: ctrl table does not have the proper number of rows "<<endl;
      return STAFCV_BAD ;
   }
//
   if ( mHitH->nok < 1 ) {
      cout<<" thm: Empty Geant hit table "<<endl;
      return STAFCV_BAD ;
   }
//
   if ( tHitH->nok < 1 ) {
      cout<<" thm: Empty reco hit table "<<endl;
      return STAFCV_BAD ;
   }
//
//  Set geometry class
//
  thmGeometry geometry ;
  geometry.Set ( ctrl ) ;
//
//    Construct cells
//
#ifdef DEBUG
  if ( ctrl->debug > 1 ) cout << " Initializing "<< geometry.maxCells <<" cells... " <<flush;
#endif
  thmCell*  cells  = new thmCell[geometry.maxCells];
  if ( cells == 0 ) {
     cout<<" thm : Error allocating cells "<<endl ;
     return STAFCV_BAD ;
  }

  for ( int ix=0; ix<geometry.maxCells; ix++) cells[ix].init(ix, geometry);
//
//   Allocate classes for points
//
  thmPoint* recoPoints = new thmPoint[tHitH->nok];
  thmPoint* mcPoints   = new thmPoint[mHitH->nok];

#ifdef DEBUG
  if ( ctrl->debug > 1 ) cout << "done \n" <<flush;
#endif

//
// Break the space into cells 
//
  PthmCell cellPointer ;
  int iCell ;
//
//   Set Mc point class and get cells
//
  int i ;
  for (i=0; i<mHitH->nok;i++) {
    iCell = mcPoints[i].Set ( mHit[i].volume_id%100-1,
                              mHit[i].x[0], mHit[i].x[1], mHit[i].x[2], geometry ) ;
    mcPoints[i].pTable = (void *)(&(mHit[i]));
    if ( iCell < 0 ) continue ;
    cellPointer = &(cells[iCell]);
    cellPointer->mcHits.append(&(mcPoints[i]));
    mcPoints[i].pCell = cellPointer ;
  }
#ifdef DEBUG
  if ( ctrl->debug > 1 ) {
     cout << flush;
     cout << "Geant Hits assigned to cells \n" << flush;
  }
#endif
//
//   Set reco point class and get cells
//
  for (i=0; i<tHitH->nok;i++) {
    iCell = recoPoints[i].Set ( tHit[i].row%100-1, tHit[i].x, tHit[i].y, tHit[i].z, geometry ) ;
    recoPoints[i].pTable = (void * )(&(tHit[i]));
    if ( iCell >= 0 )  {
       cellPointer=&(cells[iCell]);
       recoPoints[i].pCell = cellPointer ;
    }
    else {
       recoPoints[i].pCell = 0 ;
    }
  } 
#ifdef DEBUG
  if ( ctrl->debug > 1 ) {
    cout << tHitH->nok << " Reconstructed Hits assigned to cells \n" << flush;
  }
#endif
  // -----  Find Nearest Points  -----
  
  //   Iterate over tHits, mapping every tHit to a corr. mHit
  //   (assumed, for first approx., that |tHits|<|mHits|)
  
  int jmin ;
  int j,k=0,n;
  double dz, dz2, dphi, drphi, d;
  double dMin, dMax, drPhiMin ;
  double filter = (ctrl->goodDistance) * (ctrl->goodDistance) ;
  thmLink *x;
  mHitElt mIt, minMcHit;
  thmPoint*   minMcPoint ;
  dMax = 10.*10. ;

  for (i=0;i<tHitH->nok;i++) { 
//   if (i%10000 == 0) cout << "i= "<< i << "\n" <<flush;
//
//   Find cell where this point is located
//
    cellPointer = recoPoints[i].pCell ;
    if ( cellPointer == 0 ) continue ;
//
//   Loop over cells around
//
    dMin = dMax ;
    for (n=0;n<9 && dMin>filter;n++) {   //Iterate over nearest neighbours
      j=cellPointer->nn(n, geometry);
      if (j != -1) {
	      for( x= cells[j].mcHits.first(); x!=0 && dMin>filter ; x=x->succ) {  
	         thmPoint* mcTempPoint  = (thmPoint *)(x->e);
            mIt = (G2T_TPC_HIT_ST *)(mcTempPoint->pTable);
//           dz2  = dz*dz; 
            dz2 = 0 ;
            dphi = mcTempPoint->phi-recoPoints[i].phi ;
            if ( dphi >  pi ) dphi  = (float)twoPi - dphi ;
            if ( dphi < -pi ) dphi += (float)twoPi  ;
            drphi = recoPoints[i].r * dphi ;
            d    = drphi*drphi + dz*dz ;
	       if ( d < dMin){
               dMin       = d; 
               drPhiMin   = drphi ;
               jmin       = j;
               minMcHit   = mIt ;
               minMcPoint = mcTempPoint ;
            }
         }
      }
    }
//
//    Fill match table if something found
//
    if ( dMin < dMax ) {
      match[k].key1=minMcHit->id;
      match[k].key2=tHit[i].id;
      match[k].type=1;
//
//     cells[jmin].mHits.remove(mMin);
//
//    Fill evaluation table in requested
//
      if ( ctrl->fillEvaluationTable && k < evalH->maxlen ) {
         mHitElt tempMcHit = minMcHit ;
         eval[k].rowSector = tHit[i].row ;
         eval[k].mcId      = tempMcHit->id ;
         eval[k].recoId    = tHit[i].id ;
         eval[k].r         = minMcPoint->r ;
         eval[k].phi       = toDeg * minMcPoint->phi ;
         eval[k].z         = tempMcHit->x[2] ;
         eval[k].drphi     = drPhiMin ;
         eval[k].dz        = eval[k].z - tHit[i].z ;
      }
//
      k++;
      if ( k >= matchH->maxlen ) {
         cout<<" thm: Matching table too small !! "<<endl ;
         matchH->nok = k-- ;
         evalH->nok  = k ;
         return STAFCV_BAD ;
      }
      if ( k >= evalH->maxlen && ctrl->fillEvaluationTable ) {
         cout<<" thm: Matching table too small !! "<<endl ;
         matchH->nok = k-- ;
         evalH->nok  = k ;
         return STAFCV_BAD ;
      }
    } 
  }
  
  matchH->nok = k;
  evalH->nok  = k;
//
//    Delete class arrays
//
  delete []mcPoints ;
  delete []recoPoints ;
  delete []cells ;
//
#ifdef DEBUG
  if ( ctrl->debug > 1 ) {
      cout << k <<"  --- Hits matched --- " << endl;
  }
#endif
  return STAFCV_OK;
}


