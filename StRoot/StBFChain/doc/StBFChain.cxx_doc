//_____________________________________________________________________
// @(#)StRoot/StBFChain:$Name:  $:$Id: StBFChain.cxx_doc,v 1.25 2007/03/14 15:24:37 fisyak Exp $
//_____________________________________________________________________
#include "TROOT.h"
#include "TString.h"
#include "TObjString.h"
#include "TRegexp.h"
#include "TSystem.h"
#include "TInterpreter.h"
#include "TClassTable.h"
#include "TMemStat.h"
#include "StBFChain.h"
#include "St_db_Maker/St_db_Maker.h"
#include "StTreeMaker/StTreeMaker.h"
#include "StIOMaker/StIOMaker.h"
#include "StChallenger/StChallenger.h"
#include "StDbUtilities/StMagUtilities.h"
#include "StMessMgr.h"
#include "StEnumerations.h"
#define STAR_LOGGER 1

//_____________________________________________________________________
// PLease, preserve the comment after = { . It is used for documentation formatting
//
#if 0
// Keep to be compartible with old documentaion
#define STR_OBSOLETE "WARNING *** Option is OBSOLETE ***"
Bfc_st BFC[] = {



  {"Key" ,"Name" ,"Chain" ,"Opts" ,"Maker","Libs","Comment",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"TIME STAMPS ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"SD97" ,"","","db,detDb" ,"","","Turn on 1997 test parameters",kFALSE},
  {"SD98" ,"","","db,detDb" ,"","","Turn on 1998 test parameters",kFALSE},
  {"Y1a" ,"","","db,detDb" ,"","","YEAR_1A  approximation to year1: TPC+CTB+FTPC",kFALSE},
  {"Y1b" ,"","","db,detDb" ,"","","YEAR_1B: TPC+CTB+FTPC+calo patch+RICH, no svt",kFALSE},
  {"Y1s" ,"","","db,detDb" ,"","","YEAR_1S  started in summer: TPC, CONE, AL pipe",kFALSE},
  {"Y1d" ,"","","db,detDb" ,"","","YEAR_1D  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"Y1e" ,"","","db,detDb" ,"","","YEAR_1E  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"Y1e" ,"","","db,detDb" ,"","","YEAR_1E  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"ES99" ,"","","db,detDb" ,"","","Turn on 1999 engineering run simulation parameters",kFALSE},
  {"ER99" ,"","","db,detDb" ,"","","Turn on 1999 engineering run real data parameters",kFALSE},
  {"DC99" ,"","","db,detDb" ,"","","Turn on December 1999 engineering run real parameters",kFALSE},
  {"Y1h" ,"","","db,detDb", "","","YEAR_1H fantastic y1:TPC+CTB+FTPC+RICH+caloPatch+svtLadder",kFALSE},
  {"year2000" ,"","","Y2000" ,"","","",kFALSE},
  {"year2001" ,"","","Y2001" ,"","","",kFALSE},
  {"year2002" ,"","","db,detDb" ,"","","",kFALSE},
  {"year2003" ,"","","Y2003" ,"","","",kFALSE},
  {"Y2000" ,"","","db,detDb" ,"","","actual 2000:  TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"RY1h" ,"","","db,detDb,VtxOffSet" ,"","","Real data with Year1h geometry",kFALSE},
  {"RY2000","","","db,detDb,VtxOffSet" ,"","","actual 2000: Real data with Year2000 geometry ",kFALSE},
  {"RY2000a","","","db,detDb" ,"","","alternate 2000: Real data with Year2000 geometry ",kFALSE},
  {"RY2001","","","db,detDb" ,"","","actual 2001: Real data with Year2001 geometry ",kFALSE},
  {"RY2003","","","db,detDb" ,"","","actual 2003: Real data with Year3 geometry ",kFALSE},
  {"RY2003a","","","db,detDb" ,"","","Real data with Year3 study geometry ",kFALSE},
  {"RY2003b","","","db,detDb" ,"","","Real data with Year3 study geometry ",kFALSE},
  {"RY2003c","","","db,detDb" ,"","","Real data with Year3 study geometry, new SVT ",kFALSE},
  {"RY2003X","","","db,detDb" ,"","","tempative 2003: Real data with Year4 trigger study",kFALSE},
  {"RY2004" ,"","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004a","","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004b","","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004X","","","db,detDb" ,"","","Year4 full barrel study geometry",kFALSE},
  {"RY2004Y","","","db,detDb" ,"","","Year4 full Barrel+TPC backplane+rad length+SVT copper cable",kFALSE},
  {"RY2004c","","","db,detDb" ,"","","Year4 geometry fixed",kFALSE},
  {"RY2004d","","","db,detDb" ,"","","Year4 geometry with ne wSVT",kFALSE},
  {"RY2005" ,"","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005x","","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005b","","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005c","","","db,detDb" ,"","","the best Year5 geometry",kFALSE},
  {"RY2005d","","","db,detDb" ,"","","y2005c + new SVT",kFALSE},
  {"RY2006","","","db,detDb" ,"","","y2006 for p+p run",kFALSE},
  {"RY2007","","","db,detDb" ,"","","y2007 for AuAu run",kFALSE},

  {"Y2a" ,"","","db,detDb" ,"","","Old (CDR time) complete STAR",kFALSE},
  {"Y2b" ,"","","db,detDb" ,"","","2001 geometry 1st guess:TPC+CTB+FTPC+RICH+CaloPatch+SVT",kFALSE},
  {"Y2001" ,"","","db,detDb" ,"","","year2001: geometry - TPC+CTB+FTPC+RICH+CaloPatch+SVT+FPD",kFALSE},
  {"Y2001n","","","db,detDb","","", "year2001: new geometry - TPC+CTB+FTPC+RICH+CaloPatch+SVT+FPD",kFALSE},
  {"Y2003" ,"","","db,detDb","","",
                               "year2003: new geometry - TPC+CTB+FTPC+CaloPatch2+SVT3+BBC+FPD+ECAL",kFALSE},
  {"Y2003X" ,"","","db,detDb","","",
                  "y2003X: new geometry - TPC+CTB+FTPC+CaloPatch2+SVT3+BBC+FPD+ECAL - Full B/E EMC",kFALSE},
  {"Y2003a" ,"","","db,detDb","","",
                                  "Year2003 geometry with corrected barrel EMC and SVT layer radii",kFALSE},
  {"Y2003b" ,"","","db,detDb","","",
    "Year2003 geometry with corrected barrel EMC and SVT layer radii and extra material in the SVT",kFALSE},
  {"Y2003c" ,"","","db,detDb","","",
"Year2003 geometry with corrected barrel EMC and SVT layer radii and extra material in the new SVT",kFALSE},

  {"Y2004" ,"","","db,detDb","","",
       "Initial Yea4 geometry - TPC, SVT, SSD, CTB(TOF), FTPC, EMC, ECAL, PMD, BBC, ZDC, FPD, pVPD",kFALSE},
  {"Y2004a" ,"","","db,detDb","","", "Y2004 with PMD adjusted",kFALSE},
  {"Y2004b" ,"","","db,detDb","","", "Y2004a + SSD materiau",kFALSE},
  {"Y2004x" ,"","","db,detDb","","", "Y2004 with full barrel EMC and two caps ECAL",kFALSE},
  {"Y2004y" ,"","","db,detDb","","", "Y2004 full barrel EMC and two caps ECAL+TPC back+SVT cables",kFALSE},
  {"Y2004c" ,"","","db,detDb","","", "Y2004a + SSD materiau V2",kFALSE},
  {"Y2004d" ,"","","db,detDb","","", "Y2004c + new SVT",kFALSE},

  {"Y2005" ,"","","db,detDb","","", "Initial Year5 geometry", kFALSE},
  {"Y2005x" ,"","","db,detDb","","", "Full barrel EMC Year5 geometry", kFALSE},
  {"Y2005b" ,"","","db,detDb","","", "Year5 geometry + corrections SVT, FTPC gas + SSD y4c", kFALSE},
  {"Y2005c" ,"","","db,detDb","","", "Year5 geometry + more corrections SVT, FTPC gas + SSD y4c", kFALSE},
  {"Y2005d" ,"","","db,detDb","","", "y2005c + new SVT", kFALSE},
  {"ForceGeometry","","","","","", "Force geometry to overwrite the geometry caming from fz-file", kFALSE},

  {"Complete","","","db,detDb" ,"","","complete: new (currently foreseen) complete STAR",kFALSE},
  {"Ist1" ,"","","db,detDb" ,"","","Development geometry STAR",kFALSE},



  {"NoDb" ,"" ,"","-db,-tpcDb,-magF" ,"","","Take out Db from Chain",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Valid Db    ","Versions   ","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"DbV" ,"" ,"","db,ry1h" ,"","","19940614/0 Db Version for none",kFALSE},
  {"DbV0614" ,"" ,"","db,ry1h" ,"","","20000614/0 Db Version for p00hd",kFALSE},
  {"DbV0624" ,"" ,"","db,ry1h" ,"","","20000624/0 Db Version for p00hd_1",kFALSE},
  {"DbV0713" ,"" ,"","db,ry1h" ,"","","20000713/0 Db Version for p00he",kFALSE},
  {"DbV0727" ,"" ,"","db,ry1h" ,"","","20000727/0 Db Version for p00he",kFALSE},
  {"DbV0819" ,"" ,"","db,ry1h" ,"","","20000819/0 Db Version for p00hg",kFALSE},
  {"DbV1123" ,"" ,"","db,ry1h" ,"","","20001123/0 Db wo TpcDriftVel. from StTpcT0Maker",kFALSE},
  {"DbV0523" ,"" ,"","db,ry1h" ,"","", "20010523/0 Db Version for p01he",kFALSE},
  {"DbV1007" ,"" ,"","db,ry1h" ,"","", "20011007/0 Db Version for p01hi",kFALSE},
  {"DbV1107" ,"" ,"","db,ry1h" ,"","", "20011107/0 Db Version for pass1 p01gk",kFALSE},
  {"DbV1211" ,"" ,"","db,ry1h" ,"","", "20011211/0 Db Version for prod p01gl",kFALSE},

  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Trigger Type","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"Physics" ,"","","trg" ,"","","Select Physics events",kFALSE},
  {"LaserTest" ,"","","trg" ,"","","Select Laser events",kFALSE},
  {"PulserSvt" ,"","","trg" ,"","","Select SVT Pulser events",kFALSE},
  {"alltrigger" ,"","","trg" ,"","","Select all events (no trig sel)",kFALSE},






  {"phys_off" ,"","","" ,"","","Turn off physics in simulation",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"C H A I N S ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"doEvents" ,"" ,"","in,StEvent,analysis,NoDb" ,"","","",kFALSE},
  {"drawDst" ,"" ,"","in,ry1h,globT,SCL,geant,display,NoDb,TbUtil" ,"","","",kFALSE},
  {"Cdst" ,"" ,"","global,dst,event,analysis,EventQA" ,"","","",kFALSE},
  {"C1default" ,"" ,"","tpc,rich,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits" ,"","","Year 1 chain",kFALSE},
  {"C2default" ,"" ,"","tpc,rich,l0,Cdst,Kalman,tags,Tree,EvOut,ftpc,svt,emcY2"
                                                                              ,"","","Year 2 chain",kFALSE},
  {"C3default" ,"" ,"","tpc,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits,ftpc,svt,bbcsim,emcY2"
                                                                    ,"","","Year 3 simu base chain",kFALSE},
  {"CAdefault" ,"" ,"","tpc,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits,ftpc,svt,emcY2"
                                                                         ,"","","Assymptotic chain",kFALSE},
  {"Cy1a" ,"" ,"","y1a,C1default" ,"","","Turn on chain y1a",kFALSE},
  {"Cy1b" ,"" ,"","y1b,C1default" ,"","","Turn on chain y1b",kFALSE},
  {"Cy1s" ,"" ,"","y1s,C1default" ,"","","Turn on chain y1s",kFALSE},
  {"Cy1d" ,"" ,"","y1d,C1default" ,"","","Turn on chain y1d",kFALSE},
  {"cy1e" ,"" ,"","y1e,C1default" ,"","","Turn on chain y1h",kFALSE},
  {"cy1h" ,"" ,"","y1h,C1default" ,"","","Turn on chain y1e",kFALSE},
  {"Cy2a" ,"" ,"","y2a,CAdefault" ,"","","Turn on chain y2a",kFALSE},
  {"Cy2b" ,"" ,"","y2b,C2default" ,"","","Turn on chain y2b",kFALSE},
  {"C2000" ,"" ,"","y2000,C1default" ,"","","Turn on chain Y2000",kFALSE},
  {"C2001" ,"" ,"","y2001,C2default" ,"","","Turn on chain Y2001",kFALSE},
  {"C2003" ,"" ,"","y2003,C3default" ,"","","Turn on chain Y2003",kFALSE},
  {"C2003X" ,"" ,"","y2003X,C3default" ,"","","Turn on chain Y2003X (full B/E EMC)",kFALSE},

  {"mdc3" ,"" ,"","cy1h,GeantOut" ,"","","MDC3 default chain",kFALSE},
  {"MDC4" ,"" ,"","C2001,trs,srs,fss,rrs,big,GeantOut" ,"","","Turn on chain for MDC4",kFALSE},
  {"MDC4New" ,"" ,"","y2001n,C2default,trs,srs,fss,rrs,big,GeantOut","","",
                                                     "Turn on chain for MDC4 (for after September)",kFALSE},
  {"PostMDC4" ,"" ,"","C2001,trs,sss,fss,rrs,big,GeantOut" ,"","","Turn on Post MDC4 chain",kFALSE},

  {"ppMDC4" ,"" ,"","ppOpt,C2001,-PreVtx,mwc,trs,srs,rrs,big,GeantOut",
                                                                    "","","Turn on chain for ppMDC",kFALSE},

  {"dAuMDC" ,"" ,"","ppOpt,C2003,-PreVtx,trs,srs,fss,big,GeantOut","","" ,"Chain for d+Au",kFALSE},

  {"dAuMDCa" ,"" ,"","ppOpt,C2003,-PreVtx,trs,srs,fss,big,GeantOut,est","","","Chain for d+Au",kFALSE},

  {"CComplete" ,"" ,"","Complete,C2default" ,"","","Turn on chain for Complete STAR",kFALSE},

  {"SvtD" ,"","","SvtDb,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit", "","","SVT chain for Data",kFALSE},

  {"P00h" ,"" ,"","ry1h,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout,ExB,NoHits","",""
                                                           ,"Production chain for summer 2000 data",kFALSE},
  {"P2000" ,"" ,"","ry2000,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout,ExB,NoHits","",""
                                                           ,"Production chain for summer 2000 data",kFALSE},
  {"B2000" ,"" ,"","ry2000a,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                  ,"Base chain for 2001 (tpc+rhic)",kFALSE},
  {"P2000a" ,"" ,"","B2000,Corr1","","" ,"Production chain for summer 2000 data",kFALSE},


  {"B2001" ,"" ,"","ry2001,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                  ,"Base chain for 2001 (tpc+rhic)",kFALSE},
  {"P2001" ,"" ,"","B2001,l3onl,tofDat,Corr2,OSpaceZ","",""
                                               ,"Production chain for summer 2001 data (+ l3, tof)",kFALSE},
  {"P2001a" ,"" ,"","B2001,svt_daq,SvtD,ftpc,l3onl,tofDat,emcDY2,Corr2,OSpaceZ","",""
                               ,"Production chain for summer 2001 data (+ ftpc, svt, l3, tof, emc)",kFALSE},

  {"pp2001" ,"" ,"","ppOpt,B2001,-PreVtx,l3onl,tofDat,emcDY2,Corr2","",""
                                                                        ,"pp 2001 (+ l3, tof, emc)",kFALSE},
  {"pp2001a" ,"" ,"","pp2001,svt_daq,SvtD,ftpc","",""
                                                             ,"pp 2001 (+ ftpc, svt, l3, tof, emc)",kFALSE},


  {"B2003" ,"" ,"","ry2003,in,tpc_daq,tpc,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                       ,"Base chain for 2003 (tpc)",kFALSE},
  {"dau2003" ,"" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc","",""
                 ,"Production chain for winter 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc)",kFALSE},
  {"dau2003a" ,"" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd","",""
           ,"Production chain for winter 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc, trgd)",kFALSE},
  {"pp2003" , "" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd","",""
           ,"Production chain for Spring 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc, trgd)",kFALSE},
  {"B2004" ,"" ,"","ry2004,in,tpc_daq,tpc,svt_daq,SvtD,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                   ,"Base chain for 2004 (tpc+svt)",kFALSE},
  {"P2004" ,"" ,"","B2004,l3onl,fcf,ToF,emcDY2,fpd,Corr4,ftpc,trgd,ZDCvtx,OSpaceZ2","",""
                ,"Production chain for winter 2003/2004 data (+ l3, tof, bcc/fpd, ftpc, emc, trgd)",kFALSE},
  {"pp2004" ,"" ,"",
   "B2004,fcf,ppOpt,VFppLMV5,-PreVtx,l3onl,ToF,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr4,OSpaceZ2",
                    "","","Production chain for 2004 pp data (+ l3, tof, bcc/fpd, ftpc, emc, trgd)",kFALSE},
  {"B2005" ,"" ,"","ry2005b,in,tpc_daq,tpc,svt_daq,SvtD,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                   ,"Base chain for 2005 (tpc+svt)",kFALSE},

  {"B2005a" ,"" ,"","ry2005b,in,tpc_daq,tpc,Physics,Cdst,-SvtDedx,Kalman,tags,Tree,evout","",""
                                                                  ,"Base chain for 2005 (tpc only)",kFALSE},




  {"P2005" ,"" ,"","B2005,l3onl,fcf,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr3","",""
                     ,"Production chain for winter 2004/2005 data (+ l3, bcc/fpd, ftpc, emc, trgd)",kFALSE},
  {"pp2005" ,"" ,"",
     "B2005,fcf,ppOpt,VFppLMV5,-PreVtx,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr3",
                         "","","Production chain for 2005 pp data (+ l3, bcc/fpd, ftpc, emc, trgd)",kFALSE},
  {"pp2005a" ,"" ,"",
   "B2005a,fcf,ppOpt,VFPPV,beamline,CtbMatchVtx,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr4",
                "","","Production chain for 2005 pp data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},
  {"LaserCal0","" ,"","db,detDb,tpc_daq,tpcDb,tcl,globT,laser,LaserTest","","",
                                                                    "Laser Calibration Chain (tcl)",kFALSE},
  {"LaserCal","" ,"","db,detDb,tpc_daq,tpcDb,fcf,globT,laser,LaserTest","","",
                                                                          "Laser Calibration Chain",kFALSE},
  {"L3Counter","" ,"","db,detDb,in,l3count","","", "L3 Counter extraction pass",kFALSE},
  {"VtxSeedCal","","","ppOpt,ry2001,in,tpc_daq,tpc,global,-Tree,Physics,-PreVtx,FindVtxSeed,NoEvent,Corr2",
                                                                     "","","Pass0 Vertex evaluator",kFALSE},
  {"SpcChgCal","","","B2004,fcf,Corr3,OSpaceZ2,OShortR,SCEbyE,-Tree,-tags,-EvOut,-EventQA",
                                                                "","","Pass0 SpaceCharge evaluator",kFALSE},


  {"SpcChgCalG","","","MuDST,fcf,Corr4,OSpaceZ2,OGridLeak3D,SCEbyE,-Tree,-tags,-EvOut,-EventQA",
                                                  "","","Pass0 SpaceCharge evaluator with GridLeak",kFALSE},

  {"VtxSeedCalG","","","MuDST,fcf,Corr4,FindEvtVtxSeed,-Tree,-tags,-EvOut,-EventQA",
                                                                     "","","Pass0 Vertex evaluator",kFALSE},


  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"OPTIONS     ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},



  {"SvtHitFilt" ,"", "","", "","","SVT Hit filter Maker",kFALSE},
  {"NoHits" ,"" ,"","" ,"","","Don't write hits into Event.Branch",kFALSE},
  {"Kalman" ,"" ,"","geant" ,"","","",kFALSE},
  {"Eval" ,"" ,"","","","" ,"Turn on evaluation switch for different makers",kFALSE},
  {"Ev03" ,"" ,"","","","" ,"Turn on alternative V0 method",kFALSE},
  {"off" ,"" ,"","","","" ,"Turn off default chain",kFALSE},
  {"clearDAQCTB" ,"" ,"","","" ,"" ,"clear DAQ CTB Hits for embedding",kFALSE},
  {"NoInput" ,"" ,"","","" ,"" ,"No input file",kFALSE},
  {"util" ,"" ,"","","","StAnalysisUtilities", "Load StAnalysisUtilities",kFALSE},
  {"FieldOn" ,"" ,"","MagF" ,"","" ,"Constant nominal field",kFALSE},
  {"FieldOff" ,"" ,"","MagF" ,"","" ,"No Field option",kFALSE},
  {"HalfField" ,"" ,"","MagF" ,"","","Half Field option",kFALSE},
  {"ReverseField","" ,"","MagF" ,"","","Reverse Field option",kFALSE},
  {"NoCintDb" ,"" ,"","" ,"","","Switch off standard Cint Db",kFALSE},
  {"NoCintCalDb" ,"" ,"","" ,"","","Switch off local Cint Db",kFALSE},
  {"NoMySQLDb" ,"" ,"","" ,"","","Switch off MySQL Db",kFALSE},
  {"NoEvent" ,"" ,"","-event,-analysis" ,"","","Switch Off StEvent and StAnalysis Makers",kFALSE},
  {"MakeDoc" ,"" ,"","" ,"","","Make HTML documentation for the given Chain",kFALSE},
  {"Debug" ,"" ,"","" ,"","","Set debug flag = 1",kFALSE},
  {"Debug1" ,"" ,"","" ,"","","Set debug flag = 1",kFALSE},
  {"Debug2" ,"" ,"","" ,"","","Set debug flag = 2",kFALSE},
  {"IdTruth" ,"" ,"","" ,"","","Enable IdTruth association in StAssociationMaker",kFALSE},
  {"useInTracker","" ,"","","","" ,"switch from EGR to Sti global tracks in StAssociationMaker",kFALSE},
  {"noRepeat" ,"" ,"","" ,"","","No repeat in Messenger",kFALSE},
  {"useInTracker","" ,"","","","" ,"switch from EGR to Sti global tracks in StAssociationMaker",kFALSE},
  {"noHistos" ,"" ,"","" ,"","","Disables Attributes histos",kFALSE},
  {"Higz" ,"" ,"","" ,"","","Pop Higz window",kFALSE},
  {"big" ,"" ,"","" ,"","","Set NwGEANT =20Mwords",kFALSE},
  {"bigbig" ,"" ,"","" ,"","","Set NwGEANT =40Mwords",kFALSE},



  {"InTree" ,"" ,"","in","" ,"","bfcTree Input Tree name",kFALSE},
  {"OutTree" ,"" ,"","Tree","" ,"","bfcTree Output Tree name",kFALSE},
  {"DstOut" ,"" ,"","Tree" ,"","","Write dst to StTree",kFALSE},
  {"McEvOut" ,"" ,"","StMcEvent,Tree" ,"","","Write StMcEvent to StTree",kFALSE},
  {"EvOut" ,"" ,"","Tree" ,"","","Write StEvent to StTree",kFALSE},
  {"GeantOut" ,"" ,"","Tree" ,"","","Write g2t tables to StTree",kFALSE},
  {"Simu" ,"" ,"","" ,"","","Simulated Data",kFALSE},
  {"HitsBranch" ,"" ,"","" ,"","","take out points from dst branch and put them into HitsBranch",kFALSE},
  {"paw" ,"" ,"","" ,"","","Allocate memory for pawc",kFALSE},
  {"AllEvent" ,"" ,"","Tree" ,"","","Write whole event to StTree",kFALSE},
  {"AllTables" ,"" ,"","","" ,"St_Tables","Load Star Tables",kFALSE},

  {"Corr1" ,"" ,"","AlignSectors,ExB,OBmap,OClock,OPr13","","",
                                                      "... AlignSectors,ExB,OBmap,OClock,OPr13 ...",kFALSE},
  {"Corr2" ,"" ,"","AlignSectors,ExB,OBmap,OClock,OPr13,OTwist,OIFC","","",
                                          "... AlignSectors,ExB,OBmap,OClock,OPr13,OTwist,OIFC ...",kFALSE},
  {"Corr3" ,"" ,"","AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC","","",
                                        "... AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC ...",kFALSE},
  {"Corr4" ,"" ,"","AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC,OShortR","","",
                               "... AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC , OShortR...",kFALSE},

  {"ExB" ,"" ,"","","" ,"","Activate ExB correction",kFALSE},
  {"EB1" ,"" ,"","","" ,"","Force ExB configuration 1",kFALSE},
  {"EB2" ,"" ,"","","" ,"","Force ExB configuration 2",kFALSE},
  {"OBmap" ,"" ,"","","" ,"","ExB shape correction",kFALSE},
  {"OBmap2D" ,"" ,"","","" ,"","ExB 2 D shape correction",kFALSE},
  {"OTwist" ,"" ,"","","" ,"","ExB twist correction",kFALSE},
  {"OClock" ,"" ,"","","" ,"","Clock/tpc rot. correction",kFALSE},
  {"OPr13" ,"" ,"","","" ,"","PadRow 13 distortion",kFALSE},
  {"OCentm" ,"" ,"","","" ,"","Central membrane correction",kFALSE},
  {"OECap" ,"" ,"","","" ,"","EndCap (curved) correction",kFALSE},
  {"OIFC" ,"" ,"","","" ,"","Field Cage correction",kFALSE},
  {"OSpaceZ" ,"" ,"","","" ,"","Space Charge corrections",kFALSE},
  {"OSpaceZ2" ,"" ,"","","" ,"","Space Charge corrections R2",kFALSE},
  {"OShortR" ,"" ,"","","" ,"","Shorted Ring correction",kFALSE},
  {"OGridLeak" ,"" ,"","","" ,"","Grid Leak correction",kFALSE},
  {"OGridLeak3D" ,"" ,"","","" ,"","3D Grid Leak correction",kFALSE},
  {"AlignSectors","" ,"","","" ,"","Activate Sector Alignment correction",kFALSE},

  {"EastOff" ,"" ,"","","" ,"","Disactivate East part of tpc",kFALSE},
  {"WestOff" ,"" ,"","","" ,"","Disactivate West part of tpc",kFALSE},
  {"AllOn" ,"" ,"","","" ,"","Activate both East and West parts of tpc",kFALSE},
  {"ReadAll" ,"" ,"","","" ,"","Activate all branches to read",kFALSE},

  {"pp" ,"" ,"","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"ppOpt" ,"" ,"","TrsPileUp","","", "pp option without enabling special cases",kFALSE},
  {"TrsPileUp" ,"" ,"","","","", "Trs pile up mode",kFALSE},
  {"TrsToF" ,"" ,"","","","", "Trs account for particle time of flight",kFALSE},


  {"SvtMatchVtx" ,"" ,"","","" ,"","Use SVT matched tracks to find  Primary Vertex",kFALSE},


  {"VtxOffSet" ,"" ,"","","" ,"","Account Primary Vertex offset from y2000 data",kFALSE},
  {"Calibration" ,"" ,"","","" ,"","Calibration mode",kFALSE},
  {"beamLine" ,"" ,"","","" ,"","LMV Beam line constrain",kFALSE},





  {"VFPPV" ,"" ,"","VFppLMV5","" ,"","... WARNING VFPPV is NOT valid with TPT",kFALSE},

  {"VFppLMV" ,"" ,"","","" ,"","...VertexMaker will use ppLMV method",kFALSE},
  {"VFppLMV5" ,"" ,"","","" ,"","...VertexMaker will use ppLMV method (tuned)",kFALSE},
  {"onlcl" ,"" ,"","","" ,"","Read/use TPC DAQ100 clusters",kFALSE},
  {"onlraw" ,"" ,"","","" ,"","Read/use TPC raw hits",kFALSE},

  {"ezTree" ,"" ,"","","" ,"","Create ezTree branch",kFALSE},
  {"BEmcDebug","" ,"","","" ,"","Turn OFF B-EMC hit reconstruction cuts",kFALSE},


  {"useLDV" ,"" ,"","","" ,"","... uses laserDV database flavor",kFALSE},
  {"useCDV" ,"" ,"","","" ,"","... uses ofl database flavor",kFALSE},

  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Tables      ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"tables" ,"" ,"",
     "StDbT,ctf_T,ebyeT,emc_T,ftpcT,gen_T,geomT,globT,l3_T,mwc_T,sim_T,svt_T,tpc_T,trg_T,vpd_T",
                                                                                           "","","",kFALSE},



  {"StDbT" ,"" ,"","","" ,"StDb_Tables","Load StDb_Tables",kFALSE},
  {"ctf_T" ,"" ,"","","" ,"ctf_Tables","Load ctf_Tables",kFALSE},
  {"ebyeT" ,"" ,"","","" ,"ebye_Tables","Load ebye_Tables",kFALSE},
  {"emc_T" ,"" ,"","","" ,"emc_Tables","Load emc_Tables",kFALSE},
  {"ftpcT" ,"" ,"","","" ,"ftpc_Tables","Load ftpc_Tables",kFALSE},
  {"gen_T" ,"" ,"","","" ,"gen_Tables","Load gen_Tables",kFALSE},
  {"geomT" ,"" ,"","","" ,"geometry_Tables","Load geometry_Tables",kFALSE},
  {"globT" ,"" ,"","","" ,"global_Tables","Load global_Tables",kFALSE},
  {"l3_T" ,"", "","","" ,"l3_Tables","Load l3_Tables",kFALSE},

  {"mwc_T" ,"" ,"","","" ,"mwc_Tables","Load mwc_Tables",kFALSE},



  {"sim_T" ,"" ,"","","" ,"sim_Tables","Load sim_Tables",kFALSE},
  {"svt_T" ,"" ,"","","" ,"svt_Tables","Load svt_Tables",kFALSE},
  {"tpc_T" ,"" ,"","","" ,"tpc_Tables","Load tpc_Tables",kFALSE},

  {"trg_T" ,"" ,"","","" ,"trg_Tables","Load trg_Tables",kFALSE},
  {"vpd_T" ,"" ,"","","" ,"vpd_Tables","Load vpd_Tables",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Utilities   ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Geometry+Mag","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"pgf77" ,"" ,"","","" ,"pgf77VMC","Fortran",kFALSE},
  {"minicern" ,"" ,"","","" ,"minicern","minicern",kFALSE},
  {"mysql" ,"" ,"","","" ,"mysqlclient","MySQL",kFALSE},
  {"geometry" ,"" ,"","","" ,"geometry","geometry+Mag.Field",kFALSE},
  {"StarMagField","", "","magF" ,"","StarMagField","Load StarMagField",kFALSE},
  {"geomNoField" ,"" ,"","-geometry,StarMagField" ,"","geometryNoField","geometry-Mag.Field",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"vpd" ,"" ,"","vpd_T","" ,"St_vpd","",kFALSE},



  {"tls" ,"" ,"","","" ,"tls","",kFALSE},
  {"daq" ,"" ,"","","" ,"StDaqLib,StDAQMaker","Load StDAQMaker",kFALSE},
  {"SCL" ,"" ,"","","" ,"StarClassLibrary","Load StarClassLibrary",kFALSE},
  {"SvtCL" ,"" ,"","","" ,"StSvtClassLibrary","",kFALSE},
  {"TbUtil" ,"" ,"","sim_T,tpc_t,globT,SCL","" ,"StTableUtilities","Load StTableUtilities",kFALSE},
  {"TRGDef" ,"" ,"","","" ,"StTriggerDataMaker","Load StTriggerData",kFALSE},
  {"TofUtil" ,"" ,"","","" ,"StTofUtil","Load StTofUtil",kFALSE},
  {"StBichsel" ,"" ,"","","" ,"StBichsel","Load Bichsel model for dE/dx",kFALSE},
  {"StEvent" ,"" ,"","globT,SCL,TRGDef,StBichsel","" ,"StEvent","Load StEvent",kFALSE},
  {"SsdUtil" ,"" ,"","","" ,"StSsdUtil","Load SSD Util",kFALSE},
  {"EmcUtil" ,"" ,"","emc_T,geomT,StDbT","" ,"StEmcUtil","Load StEmcUtil",kFALSE},
  {"EEmcUtil" ,"" ,"","","" ,"StEEmcUtil","Load StEEmcUtil",kFALSE},
  {"l3Util" ,"" ,"","","" ,"Stl3Util","Load Stl3Util",kFALSE},
  {"PmdUtil" ,"" ,"","","", "StPmdUtil","Load StPmdUtil",kFALSE},
  {"QUtils" ,"" ,"","PmdUtil,EmcUtil","", "","Load QA Libs dependencies",kFALSE},
  {"MuDSTDeps" ,"" ,"","StEvent","","Physics,StEventUtilities,StStrangeMuDstMaker",
                                                              "Load MuDST misc. dependencies (all)",kFALSE},
  {"MuDST" ,"" ,"","MuDSTDeps,EmcUtil,TofUtil,PmdUtil","","StMuDSTMaker","Load MuDST library",kFALSE},
  {"geantL","","","geomT,gen_T,sim_T,StarMagField,geomNoField","","Geom,St_g2t,St_geant_Maker"
                                                                                  ,"Load GeantLibs",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"I/O Makers  ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"gstar" ,"geant" ,"","-fzin,-ntin,-geant,Simu,geantL","St_geant_Maker",
                                      "","gstar for 80 muon tracks with pT = 1GeV in |eta|<4",kFALSE},
  {"tdaq" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"miniDAQ" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"fzin" ,"geant","","Simu,-gstar,-ntin,-geant,geantL","St_geant_Maker","",
                                                                               "read gstar fz-file",kFALSE},
  {"in" ,"" ,"","" , "StIOMaker","StIOMaker","Read [DAQ|ROOT] input file",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Db makers   ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"dbutil" ,"" ,"","StDbT" ,"","StDbUtilities","Load StDbUtilities",kFALSE},
  {"db" ,"db" ,"","StDbT" ,"St_db_Maker","StDbLib,StDbBroker,St_db_Maker","",kFALSE},
  {"magF" ,"MagField","","StDbT,db","StMagFMaker","StarMagField,StMagF"
                                                         ,"Mag.field map with scale factor from Db",kFALSE},
  {"svtDb" ,"svtDb","","SvtCL,dbutil,db","StSvtDbMaker","StSvtDbMaker","Load and run SvtDbMaker",kFALSE},
  {"ssdDb" ,"ssdDb","","SsdUtil,db","StSsdDbMaker","StSsdDbMaker","Load and run StSsdDbMaker",kFALSE},
  {"detDb" ,"","","","StDetectorDbMaker","StDetectorDbMaker","Load and run StDetectorDbMaker",kFALSE},
  {"eemcDb" ,"eeDb" ,"","db", "StEEmcDbMaker","StEEmcDbMaker","",kFALSE},
  {"tpcDB" ,"tpcDB","","tpc_T,dbutil,db" ,"StTpcDbMaker","StTpcDb","",kFALSE},
  {"trgd" ,"trgd","","TRGDef" ,"StTriggerDataMaker","StTriggerDataMaker","Get trigger data",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"MAKERS      ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},



  {"ntin" ,"geant" ,"","paw,-fzin,-geant,-gstar,Simu,geantL,paw","St_geant_Maker",
                                                       "gstar","read event generated Hbook nt-file",kFALSE},
  {"geant" ,"geant","","geantL" ,"St_geant_Maker","","passive GEANT",kFALSE},
  {"RootVMC","","" ,"-geant,-fzin,-ntin,StarMagField,-geantL,-geometry,-geomNoField","",
                                         "Geom,VMC,Physics,EG,Pythia6,EGPythia6,minicern,geant3","",kFALSE},
  {"VMCAppl" ,"","","geomT,gen_t,sim_T,RootVMC","" ,"StarVMCApplication","VMC G3",kFALSE},
  {"VMC" ,"geant","","Simu,VMCAppl,-geant","StVMCMaker", "StVMCMaker","VMC Maker",kFALSE},
  {"VMCPassive" ,"geant","","VMCAppl" ,"StVMCMaker", "StVMCMaker","VMC Maker in Passive Mode",kFALSE},
  {"StMcEvent" ,"","","gen_t,sim_T", ,"StMcEvent","",kFALSE},
  {"McEvent" ,"","","StEvent,EEmcUtil,EmcUtil,StMcEvent","StMcEventMaker" ,"StMcEventMaker","",kFALSE},
  {"MakeEvent","0Event","","StEvent,tpcDB,detDb","StEventMaker","StEventMaker",
                                                                         "<Early StEvent creation>",kFALSE},


  {"l0" ,"l0Chain","","trg_T,globT,ctf,trg" ,"StMaker","StChain","",kFALSE},



  {"ctf" ,"ctf","l0Chain","ctf_T,db" ,"St_ctf_Maker","St_ctf,St_ctf_Maker","",kFALSE},

  {"mwc" ,"mwc","l0Chain","mwc_T,db,tpcDB" ,"St_mwc_Maker","St_mwc,St_mwc_Maker","",kFALSE},
  {"trg" ,"trg","l0Chain","trg_T,globT,db" ,"St_trg_Maker","St_trg,St_trg_Maker","",kFALSE},
  {"ppMCTrig" ,"ppMC_trig1","l0Chain",""
                         ,"StppTrigMaker","StppSpin","Add emulation of pp Trigger based on CTB+MWC",kFALSE},






  {"tpc" ,"tpcChain","","tpc_T,globT,tls,db,tpcDB,tcl,tpt,PreVtx" ,"StMaker","StChain","",kFALSE},
  {"tpcI" ,"tpcChain","","tpc_T,globT,tls,db,tpcDB,TpcHitMover","StMaker","StChain","tpc with ITTF",kFALSE},
  {"Trs" ,"Trs","tpcChain","scl,tpcDB,tpc_daq,Simu" ,"StTrsMaker","StTrsMaker","",kFALSE},
  {"TrsMini" ,"","tpcChain","scl,tpcDB,-Trs,-tpc_daq,Simu","StTrsMiniMaker","StTrsMiniMaker","",kFALSE},

  {"Mixer" ,"tpc_raw","","","StMixerMaker" ,"StDaqLib,StDAQMaker,StTrsMaker,StMixerMaker","",kFALSE},
  {"St_tpc" ,"","","tpc_T,tpcDb" ,"","St_tpc","",kFALSE},
  {"St_svt" ,"","","svt_T,svtDb" ,"","St_svt","",kFALSE},

  {"tpc_daq" ,"tpc_raw","tpcChain","detDb,tpc_T" ,"St_tpcdaq_Maker","St_tpcdaq_Maker","",kFALSE},
  {"tfs" ,"","tpcChain","Simu,tcl" ,"","","use tfs (no StTrsMaker)",kFALSE},
  {"tcl" ,"tpc_hits","tpcChain","tls,St_tpc,StEvent","St_tcl_Maker","St_tcl_Maker",
                                                                        "Cluster Finder (from raw)",kFALSE},
  {"fcf" ,"","tpcChain","daq,-tcl", "StRTSClientFCFMaker","StRTSClientFCF,StRTSClientFCFMaker",
                                                                       "Offline FCF Cluster finder",kFALSE},
  {"Velo" ,"","tpcChain","tpc_T,tls" ,"StVeloMaker","StVeloMaker","",kFALSE},

  {"TpcHitFilter","tpc_hit_filter","tpcChain","" ,"StTpcHitFilterMaker","StTpcHitFilterMaker","",kFALSE},

  {"TpcHitMover" ,"tpc_hit_mover","tpcChain","StEvent",
                      "StTpcHitMover","StTpcHitMoverMaker","TPC hits coord transform + corrections",kFALSE},
  {"tpt" ,"tpc_tracks","tpcChain","tls,St_tpc,TpcHitMover", "St_tpt_Maker","St_tpt_Maker","",kFALSE},
  {"tpt_old" ,"tpc_tracks","tpcChain","St_tpc,tls", "St_tpt_Maker","St_tpt_Maker","",kFALSE},
  {"TpcT0" ,"TpcT0","","ctf_T,ftpcT,tls,St_tpc,St_svt,tpc_daq,kalman,StEvent","StTpcT0Maker",
                            "St_tcl_Maker,St_tpt_Maker,St_global,St_dst_Maker,StPass0CalibMaker","",kFALSE},

  {"ChargeStep","","","tpc_T,globT,tls,db,tpcDB,tpc_daq","StChargeStepMaker","StChargeStepMaker","",kFALSE},

  {"laser" ,"tpc_tracks","LaserTest,tpcChain","tdaq,tpc,-tpt,-PreVtx"
                                           ,"StLaserEventMaker","StLaserEvent,StLaserEventMaker","",kFALSE},
  {"PreVtx" ,"","tpcChain","tpt,SCL,sim_T,St_tpc,St_svt,ftpcT,ctf_T",
                                                     "StPreVertexMaker","St_global,St_dst_Maker","",kFALSE},

  {"svt" ,"svtChain","","svt_T,SvtCL,Est" ,"StMaker","StChain","",kFALSE},



  {"sss" ,"","","SvtSlowSim" ,"","","Short cut for SvtSlowSim",kFALSE},
  {"SvtSlowSim" ,"","","SvtSSim,SvtOnlSeq" ,"","","Short cut for SvtSlowSim and SvtOnlSeq",kFALSE},
  {"SvtSSim","SvtSSimu","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit"
                                  ,"StSvtSimulationMaker","StSvtSimulationMaker,StSvtCalibMaker","",kFALSE},

  {"SvtEmbed" ,"","","SvtSSim,SvtEm,SvtOnlSeq" ,"","","Short cutfor SvtSlowSim and SvtOnlSeq",kFALSE},
  {"SvtEm","SvtEm","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit","StSvtEmbeddingMaker",
                                                          "StSvtSimulationMaker,StSvtCalibMaker","",kFALSE},
  {"SvtOnlSeq" ,"SvtOnlSeq","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit"
                                             ,"StSvtOnlineSeqAdjSimMaker","StSvtSimulationMaker","",kFALSE},

  {"srs" ,"svt_hits","svtChain","svtDb,tls,Simu,St_tpc,St_svt,SvtCL,-sss,-SvtSlowSim,StEvent"
                                                ,"St_srs_Maker","StSvtClusterMaker,St_srs_Maker","",kFALSE},
  {"svt_daq" ,"svt_raw","svtChain","SvtCL" ,"StSvtDaqMaker","StSvtDaqMaker","",kFALSE},
  {"SvtSeqAdj" ,"SvtSeqAdj","svtChain","SvtCL" ,"StSvtSeqAdjMaker","StSvtSeqAdjMaker","",kFALSE},
  {"SvtClu" ,"SvtClu","svtChain","svt_T,StEvent,SvtCL","StSvtClusterMaker","StSvtClusterMaker","",kFALSE},
  {"SvtCluAnal" ,"SvtCluAnal","svtChain","SvtCL","StSvtClusterAnalysisMaker","StSvtClusterMaker","",kFALSE},
  {"SvtHit" ,"svt_hits","svtChain","SvtCL" ,"StSvtHitMaker","StSvtClusterMaker","",kFALSE},

  {"SvtVtx" ,"SvtVtx","SvtChain","" ,"StSvtVertexFinderMaker","StSvtClusterMaker","",kFALSE},

  {"stk" ,"svt_tracks","svtChain","tls,St_tpc,St_svt,SvtCL","St_stk_Maker","St_stk_Maker","",kFALSE},
  {"Est" ,"","svtChain","St_svt" ,"StEstMaker","St_global,StEstMaker","",kFALSE},

  {"global" ,"globalChain","","globT,St_tpc,St_svt,Match,vertex,primary,dst,SCL,dEdxY2"
                                                                            ,"StMaker","StChain","",kFALSE},
  {"Match" ,"match","globalChain","SCL,tpc_T,St_svt,tls"
                                                        ,"StMatchMaker","St_global,St_dst_Maker","",kFALSE},

  {"Vertex" ,"Vertex","globalChain","SCL,St_svt,tls"
                                   ,"StVertexMaker","St_global,St_dst_Maker","Primary Vertex finder",kFALSE},
  {"Primary" ,"primary","globalChain","SCL,St_svt,tls","StPrimaryMaker","St_global,St_dst_Maker","",kFALSE},
  {"V0" ,"v0","globalChain","SCL,St_svt,tls" ,"StV0Maker","St_global,St_dst_Maker","",kFALSE},
  {"Xi" ,"xi","globalChain","SCL,St_svt,tls" ,"StXiMaker","St_global,St_dst_Maker","",kFALSE},
  {"Kink","kink","globalChain" ,"SCL,tls,St_svt" ,"StOldKinkMaker" ,"St_global,St_dst_Maker","",kFALSE},

  {"Fglobal" ,"","","","","" ,"WARNING *** Option is OBSOLETE ***",kFALSE},
  {"Fprimary" ,"","","","","" ,"WARNING *** Option is OBSOLETE ***",kFALSE},

  {"dst" ,"dst","globalChain","St_svt,dstOut,SCL,tls,gen_t,sim_T,ctf_T,trg_T,l3_T,ftpcT"
                                                        ,"St_dst_Maker","St_global,St_dst_Maker","",kFALSE},



  {"dEdx" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"svtdEdx" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"Event", "","","StEvent,tpcDB,detDb","StEventMaker","StEventMaker","<StEvent creation/filling>",kFALSE},



  {"pixFastSim","","","StMcEvent,StEvent",
                                   "StPixelFastSimMaker","StPixelFastSimMaker","FastPixelSimulator",kFALSE},
  {"ssdUtil", ,"","","", ,"","StSsdUtil","Ssd utilities",kFALSE},
  {"ssddat" ,"","","ssd_daq" ,"","","SSD full chain for Real Data",kFALSE},
  {"ssd_daq","SpaStrip","","ssddb,St_svt,-sls,-spa,ssdUtil","StSsdDaqMaker","StSsdDaqMaker","... SSD Daq",kFALSE},
  {"ssd" ,"","","sls,spa,spt" ,"","","SSD full chain for simulation",kFALSE},
  {"sls" ,"","","tls,Simu,St_tpc,St_svt,SvtCL","St_sls_Maker","StSsdSimulationMaker",
                                                                           "... SSD slow simulator",kFALSE},
  {"spa" ,"SpaStrip","","tls,Simu,St_tpc,St_svt,SvtCL,ssdUtil","St_spa_Maker","StSsdSimulationMaker",
                                                                     "... SSD Pedestal Annihilator",kFALSE},
  {"spt" ,"","","St_svt,ssdUtil","StSsdPointMaker","StSsdPointMaker","... SSD Point Creator",kFALSE},
  {"emcDY2" ,"emcRaw","emcY2",
     "daq,eemcDb,EEmcUtil,emc_T,EmcUtil,StEvent,PreEcl,Epc","StEmcRawMaker","StEmcRawMaker",
                                                                        "B/E EMC data common maker",kFALSE},
  {"emcAtoE" ,"","" ,"db,emcDY2","StEmcADCtoEMaker","StEmcADCtoEMaker", "B-EMC ADC to E converter",kFALSE},
  {"eemcD" ,"","","","","", "WARNING *** Option is OBSOLETE ***",kFALSE},
  {"ZDCVtx" ,"","","db" ,"StZdcVertexMaker","StZdcVertexMaker","",kFALSE},

  {"emcY2" ,"emcY2","","emc_T,tpc_T,db,emcSim,PreEcl,epc" ,"StMaker","StChain",
                            "EMC Chain for Y2A (must be before makers which include in this chain)",kFALSE},
  {"emcSim" ,"","emcY2","emc_T,EmcUtil,StMcEvent","StEmcSimulatorMaker","StEmcSimulatorMaker",
                                                                           "New simulator for BEMC",kFALSE},
  {"EEfs" ,"eefs","","db,EEmcUtil,MuDst",
                                     "StEEmcFastMaker","StEEmcSimulatorMaker","EEMC fast simulator",kFALSE},

  {"genvtx" ,"","","EEmcUtil","StGenericVertexMaker","Minuit,Sti,StGenericVertexMaker"
                                                                           ,"Generic Vertex Finder",kFALSE},
  {"StiUtil" ,"","","", "","StiUtilities","Load StiUtilities library",kFALSE},
  {"Sti" ,"Sti","","SCL,StEvent,tables,TpcDb,SvtDb,ssdDb,StiUtil","StiMaker",
                               "StEventUtilities,Sti,StiMaker,StiTpc,StiSvt,StiSsd" ,"ITTF tracker",kFALSE},
  {"StiRnD" ,"","","Sti", "","StiRnD", "Load StiRnD shared library",kFALSE},
  {"StiPulls" ,"","","Sti", "","", "Request to make Sti Pulls",kFALSE},
  {"BeamBack" ,"","","StEvent","StBeamBackMaker","StBeamBackMaker"
                                                              ,"Beam background tracker in the TPC",kFALSE},
  {"dEdxY2" ,"dEdxY2","","tpcDb,StEvent","StdEdxY2Maker","StdEdxY2Maker",
                                                                     "Bichsel method used for dEdx",kFALSE},


  {"FindVtxSeed" ,"FindVtxSeed" ,"","","StVertexSeedMaker", "St_global,St_dst_Maker,StPass0CalibMaker",
                                                                     "Performs vertex seed finding",kFALSE},
  {"FindEvtVtxSeed","FindEvtVtxSeed","","","StEvtVtxSeedMaker",
                                   "StPass0CalibMaker","Performs vertex seed finding using StEvent",kFALSE},


  {"Ftpc" ,"ftpcChain" ,"","ftpcT,fcl,fpt" ,"StMaker","StChain","",kFALSE},
  {"fss" ,"ftpc_raw","ftpcChain","SCL,Simu",
                                    "StFtpcSlowSimMaker","StFtpcSlowSimMaker","FTPC Slow simulator",kFALSE},
  {"Fcl" ,"ftpc_hits","ftpcChain","SCL","StFtpcClusterMaker",
                    "StDaqLib,StDAQMaker,StFtpcTrackMaker,StFtpcClusterMaker","FTPC cluster finder",kFALSE},
  {"fpt" ,"ftpc_tracks","ftpcChain","SCL"
                                          ,"StFtpcTrackMaker","StFtpcTrackMaker","FTPC Track Maker",kFALSE},
  {"fdbg" ,"","","fcl,fpt","","","StFtpcClusterMaker and StFtpcTrackMaker will write debugfile",kFALSE},
  {"flaser" ,"","","fpt" ,"","","StFtpcTrackMaker in LASERTRACKING",kFALSE},


  {"pmdRaw" ,"pmdRaw","","PmdUtil,pmdRead,pmdClust" ,"StMaker","StChain","PMD Raw chain",kFALSE},
  {"pmd" ,"pmd","","pmdSim,pmdClust,pmdDis","StMaker" ,"StChain", "PMD Simulation chain",kFALSE},
  {"pmdRead" ,"","","PmdUtil","StPmdReadMaker" ,"StPmdReadMaker", "DAQ reader for PMD",kFALSE},
  {"pmdSim" ,"","","PmdUtil","StPmdSimulatorMaker","StPmdSimulatorMaker","Hit Simulator for PMD",kFALSE},
  {"pmdClust" ,"pmdClust","","","StPmdClusterMaker", "StPmdClusterMaker","ClusterMaker for PMD",kFALSE},
  {"pmdDis" ,"pmdDis","PmdClust","","StPmdDiscriminatorMaker",
                                                  "StPmdDiscriminatorMaker","Discriminator for PMD",kFALSE},




  {"Kink2" ,"kink2","","db,MuDST,-kink","StKinkMaker","StSecondaryVertexMaker",
                                                                          "Find Kinks from StEvent",kFALSE},
  {"V02" ,"v02","","db,MuDST,-V0","StV0FinderMaker","StSecondaryVertexMaker",
                                                                            "Find V0s from StEvent",kFALSE},
  {"Xi2" ,"xi2","","db,MuDST,-V02,-Xi","StXiFinderMaker","StSecondaryVertexMaker",
                                                                         "Xis AND V0s from StEvent",kFALSE},

  {"V0svt" ,"v0svt","","db,MuDST","StV0FinderMaker","StSecondaryVertexMaker",
                                                              "Special: use estGlobal from StEvent",kFALSE},
  {"Xisvt" ,"xisvt","","db,MuDST","StXiFinderMaker","StSecondaryVertexMaker",
                                                              "Special: use estGlobal from StEvent",kFALSE},

  {"SCEbyE" ,"scebye","","","StSpaceChargeEbyEMaker","StEvent,StPass0CalibMaker",
                                                         "Determine EbyE SpaceCharge using StEvent",kFALSE},
  {"SCScalerCal" ,"scscalercal","","","StSpaceChargeEbyEMaker","StEvent,StPass0CalibMaker",
                                                                    "Calibrate SpaceCharge scalers",kFALSE},
  {"PostEmc" ,"PostChain","","emc_T,tpc_T,db,PreEcl,EmcUtil" ,"StMaker","StChain","",kFALSE},
  {"PreEcl" ,"preecl","PostChain","" ,"StPreEclMaker", "StPreEclMaker","B-EMC Cluster finder",kFALSE},
  {"Epc" ,"epc","PostChain","PreEcl,EmcUtil" ,"StEpcMaker","StEpcMaker","B-EMC point maker",kFALSE},
  {"fpd" ,"fpd","","", "StFpdMaker","StFpdMaker","FPD/BBC Data base chain",kFALSE},
  {"rich" ,"RichChain","","rch,RichPiD,RichSpectra", "StMaker","StChain","RICH chain",kFALSE},
  {"Rrs" ,"","RichChain","sim_T,Simu" ,"StRrsMaker","StRrsMaker","",kFALSE},
  {"rch" ,"","RichChain","sim_T,globT" ,"StRchMaker","StRrsMaker,StRchMaker","",kFALSE},
  {"RichPiD" ,"","RichChain","Event" ,"StRichPIDMaker","StRichPIDMaker","",kFALSE},

  {"ToF" ,"TofChain","","tofDat,tofrMatch,tofpMatch,tofCalib","StMaker","StChain","ToF Chain",kFALSE},
  {"tofDat" ,"tof_raw","TofChain","db,Tofutil","StTofMaker","StEvent,StTofMaker",
                                                                              "TOF Data base chain",kFALSE},
  {"tofsim" ,"","TofChain","TofUtil","StTofSimMaker","StEvent,StTofMaker,StTofSimMaker",
                                                                                    "TOF Simulator",kFALSE},
  {"tofrMatch" ,"","TofChain","db,TofUtil","StTofrMatchMaker","StTofrMatchMaker",
                                                                       "TPC to TOFr track matching",kFALSE},
  {"tofpMatch" ,"","TofChain","db,TofUtil","StTofpMatchMaker","StTofpMatchMaker",
                                                                       "TPC to TOFp track matching",kFALSE},
  {"tofCalib" ,"","TofChain","db,TofUtil","StTofCalibMaker","StTofCalibMaker", "TOF calibration",kFALSE},

  {"l3" ,"l3Chain","","l3cl,l3t" ,"StMaker","StChain","",kFALSE},
  {"l3cl" ,"","l3Chain","l3_T,l3util" ,"St_l3Clufi_Maker","St_l3,St_l3Clufi_Maker","",kFALSE},
  {"l3t" ,"","l3Chain","l3_T,l3util" ,"St_l3t_Maker","St_l3,St_l3t_Maker","",kFALSE},
  {"l3onl" ,"","","" ,"Stl3RawReaderMaker","Stl3RawReaderMaker","",kFALSE},
  {"l3count" ,"","","" ,"Stl3CounterMaker","Stl3RawReaderMaker","",kFALSE},

  {"bbcSim" ,"","","db","StBbcSimulationMaker" ,"StBbcSimulationMaker","BBC Simulator",kFALSE},

  {"analysis" ,"","","StEvent" ,"StAnalysisMaker","StAnalysisMaker","Example of Analysis",kFALSE},




  {"pec" ,"PeC","","Event" ,"StPeCMaker","StPeCMaker","PCollAnalysis",kFALSE},
  {"RichSpectra" ,"","","" ,"StRichSpectraMaker","StRichSpectraMaker","",kFALSE},

  {"TagsChain" ,"TagsChain","","" ,"StMaker","StChain","",kFALSE},

  {"TpcTag" ,"","TagsChain","" ,"StTpcTagMaker","StTpcTagMaker","",kFALSE},

  {"Flow" ,"","TagsChain","StEvent" ,"StFlowMaker","StEventUtilities,StFlowMaker","",kFALSE},

  {"FlowTag" ,"","TagsChain","StEvent,Flow" ,"StFlowTagMaker","StFlowTagMaker","",kFALSE},

  {"FlowAnalysis","","TagsChain","StEvent,Flow" ,"StFlowAnalysisMaker","StFlowAnalysisMaker","",kFALSE},
  {"StrangeTags" ,"","TagsChain","StEvent" ,"StStrangeTagsMaker","StStrangeTagsMaker","",kFALSE},
  {"SpectraTag" ,"","TagsChain","StEvent" ,"StSpectraTagMaker","StSpectraTagMaker","",kFALSE},
  {"HeavyTags" ,"","TagsChain","StEVent" ,"StHeavyTagMaker","StHeavyTagMaker","",kFALSE},
  {"HighPtTags" ,"","TagsChain","StEVent" ,"StHighPtTagsMaker","StHighPtTagsMaker","",kFALSE},



  {"PCollTag" ,"","TagsChain","StEvent" ,"StPCollTagMaker","StPCollTagMaker","",kFALSE},
  {"tags" ,"","TagsChain", "globT,Event,StrangeTags,SpectraTag,HeavyTags,PCollTag,HighPtTags"
                                           ,"StTagsMaker","StTagsMaker","Collect all tags to TTree",kFALSE},

  {"MuDSTChain","MuDSTChain","EMCmDST,CMuDST","" ,"StMaker","StChain","",kFALSE},
  {"StrngMuDST","","MuDSTDeps","", "StStrangeMuDstMaker","","Creates Stangeness MuDST",kFALSE},
  {"EMCmDST" ,"","MuDSTChain","MuDst", "StEmcMicroDstMaker","","Creates EMC MuDST",kFALSE},
  {"CMuDST" ,"","MuDSTChain","MuDst,StrngMuDST", "StMuDstMaker","","Writes Common MuDST",kFALSE},
  {"St_geom" ,"" ,"","" , "St_geom_Maker","St_geom_Maker","",kFALSE},
  {"Display" ,"","","TbUtil,St_geom",
               "StEventDisplayMaker","StEvent,StEventUtilities,StEventDisplayMaker","Event Display",kFALSE},
  {"Mc" ,"McChain","McEvent","sim_T,globT,McAss,McAna" ,"StMaker","StChain","",kFALSE},
  {"McAss" ,"","McChain","McEvent", "StAssociationMaker","StAssociationMaker","",kFALSE},
  {"McAnaTpc" ,"","","McAna" "","","Mc Analysis for Tpc",kFALSE},
  {"McAnaSvt" ,"","","McAna" "","","Mc Analysis for Svt",kFALSE},
  {"McAnaSsd" ,"","","McAna" "","","Mc Analysis for Ssd",kFALSE},
  {"McAna" ,"","McChain","McEvent,McAss", "StMcAnalysisMaker","StMcAnalysisMaker","",kFALSE},
  {"McQa" ,"","McChain","McEvent", "StMcQaMaker","StMcQaMaker","QA histogramms for McEvent",kFALSE},
  {"McTpcAna" ,"","McAnaChain","McEvent,McAss",
                                    "StTpcMcAnalysisMaker","StTrsMiniMaker,StTpcMcAnalysisMaker","",kFALSE},
  {"MiniMcEvent" ,"","","","", "StMiniMcEvent","Loads StMiniMcEvent library only",kFALSE},
  {"MiniMcMk" ,"","","McAss,MiniMcEvent","StMiniMcMaker","StMiniMcMaker",
                                                                 "Creates tree in minimc.root file",kFALSE},
  {"SvtMatTree","","","","SvtMatchedTree",
                                  "StSvtPoolEventT,StSvtPoolSvtMatchedTree","Create SvtMatchedTree",kFALSE},
  {"LAna" ,"","","in,RY1h,tpcDb","StLaserAnalysisMaker"
                                                      ,"StLaserAnalysisMaker","Laser data Analysis",kFALSE},

  {"SpinTag" ,"SpinTag","","","StSpinTagMaker","StppSpin","tag for analysis of polarized pp events",kFALSE},
  {"ppLPfind1" ,"ppLPfind1" ,"","" ,"StppLPfindMaker","StppSpin","Find leading particle for pp",kFALSE},
  {"SpinSortA" ,"SpinSortA" ,"","" ,"StSpinSortMaker","StppSpin","Spin sort event",kFALSE},
  {"ppLPprojectA","ppLPprojectA","",""
                      ,"StppLPprojectMaker","StppSpin","project LP to the spin dependent phi-histo",kFALSE},
  {"ppLPeval1" ,"ppLPeval1" ,"","" ,"StppLPevalMaker","StppSpin","Evaluation of LP algo for pp",kFALSE},
  {"ppDAQfilter1","ppDAQfilter1" ,"","" ,"StDAQfilterMaker","StppSpin","DAQ filter (used for pp)",kFALSE},
  {"QA" ,"QA","","QUtils,globT,SCL,global","St_QA_Maker","St_QA_Maker","Filling Y1/Y2 Qa histo",kFALSE},
  {"EventQA","EventQA","","QUtils,Event","StEventQAMaker" ,"St_QA_Maker","Filling Y2/Y3 Qa histo",kFALSE},
  {"QAC" ,"CosmicsQA","globT","" ,"StQACosmicMaker","StQACosmicMaker","",kFALSE},
  {"HitFilt" ,"", "","", "StHitFilterMaker","StHitFilterMaker","Hit filter Maker",kFALSE},
  {"KeepTpcHit" ,"", "","", "","","Keep all TPC hits in StHitFilterMaker",kFALSE},
  {"KeepSvtHit" ,"", "","", "","","Keep all SVT hits in StHitFilterMaker",kFALSE},
  {"Tree" ,"OutTree","","","StTreeMaker","StTreeMaker","Write requested branches into files",kFALSE},
  {"logger" ,"" ,"","" ,"","","Use log4cxx package to manage the program messages",kFALSE},

  {"ITTF" ,"" ,"","", "","","Just to keep option ITTF==false",kFALSE},

  {"NoDefault" ,"" ,"","" ,"","","No Default consistency check",kFALSE}
};
// ITTF Chain will be put here. Option list starting from minimalistic requirements
// and may not initially work.
// Please, preserve the comment after = { . It is used for documentation formatting
//
// ITTF Chains
Bfc_st BFC2[] = {

  {"Key" ,"Name" ,"Chain" ,"Opts" ,"Maker","Libs","Comment",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"TIME STAMPS ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"SD97" ,"","","db,detDb" ,"","","Turn on 1997 test parameters",kFALSE},
  {"SD98" ,"","","db,detDb" ,"","","Turn on 1998 test parameters",kFALSE},
  {"Y1a" ,"","","db,detDb" ,"","","YEAR_1A  approximation to year1: TPC+CTB+FTPC",kFALSE},
  {"Y1b" ,"","","db,detDb" ,"","","YEAR_1B: TPC+CTB+FTPC+calo patch+RICH, no svt",kFALSE},
  {"Y1s" ,"","","db,detDb" ,"","","YEAR_1S  started in summer: TPC, CONE, AL pipe",kFALSE},
  {"Y1d" ,"","","db,detDb" ,"","","YEAR_1D  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"Y1e" ,"","","db,detDb" ,"","","YEAR_1E  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"Y1e" ,"","","db,detDb" ,"","","YEAR_1E  even better y1:TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"ES99" ,"","","db,detDb" ,"","","Turn on 1999 engineering run simulation parameters",kFALSE},
  {"ER99" ,"","","db,detDb" ,"","","Turn on 1999 engineering run real data parameters",kFALSE},
  {"DC99" ,"","","db,detDb" ,"","","Turn on December 1999 engineering run real parameters",kFALSE},
  {"Y1h" ,"","","db,detDb", "","","YEAR_1H fantastic y1:TPC+CTB+FTPC+RICH+caloPatch+svtLadder",kFALSE},
  {"year2000" ,"","","Y2000" ,"","","",kFALSE},
  {"year2001" ,"","","Y2001" ,"","","",kFALSE},
  {"year2002" ,"","","db,detDb" ,"","","",kFALSE},
  {"year2003" ,"","","Y2003" ,"","","",kFALSE},
  {"Y2000" ,"","","db,detDb" ,"","","actual 2000:  TPC+CTB+RICH+caloPatch+svtLadder",kFALSE},
  {"RY1h" ,"","","db,detDb,VtxOffSet" ,"","","Real data with Year1h geometry",kFALSE},
  {"RY2000","","","db,detDb,VtxOffSet" ,"","","actual 2000: Real data with Year2000 geometry ",kFALSE},
  {"RY2000a","","","db,detDb" ,"","","alternate 2000: Real data with Year2000 geometry ",kFALSE},
  {"RY2001","","","db,detDb" ,"","","actual 2001: Real data with Year2001 geometry ",kFALSE},
  {"RY2003","","","db,detDb" ,"","","actual 2003: Real data with Year3 geometry ",kFALSE},
  {"RY2003a","","","db,detDb" ,"","","Real data with Year3 study geometry ",kFALSE},
  {"RY2003b","","","db,detDb" ,"","","Real data with Year3 study geometry ",kFALSE},
  {"RY2003c","","","db,detDb" ,"","","Real data with Year3 study geometry, new SVT ",kFALSE},
  {"RY2003X","","","db,detDb" ,"","","tempative 2003: Real data with Year4 trigger study",kFALSE},
  {"RY2004" ,"","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004a","","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004b","","","db,detDb" ,"","","Real data with Year4 study geometry",kFALSE},
  {"RY2004X","","","db,detDb" ,"","","Year4 full barrel study geometry",kFALSE},
  {"RY2004Y","","","db,detDb" ,"","","Year4 full Barrel+TPC backplane+rad length+SVT copper cable",kFALSE},
  {"RY2004c","","","db,detDb" ,"","","Year4 geometry fixed",kFALSE},
  {"RY2004d","","","db,detDb" ,"","","Year4 geometry with ne wSVT",kFALSE},
  {"RY2005" ,"","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005x","","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005b","","","db,detDb" ,"","","Real data with Year5 study geometry",kFALSE},
  {"RY2005c","","","db,detDb" ,"","","the best Year5 geometry",kFALSE},
  {"RY2005d","","","db,detDb" ,"","","y2005c + new SVT",kFALSE},
  {"RY2006","","","db,detDb" ,"","","y2006 for p+p run",kFALSE},
  {"RY2007","","","db,detDb" ,"","","y2007 for AuAu run",kFALSE},

  {"Y2a" ,"","","db,detDb" ,"","","Old (CDR time) complete STAR",kFALSE},
  {"Y2b" ,"","","db,detDb" ,"","","2001 geometry 1st guess:TPC+CTB+FTPC+RICH+CaloPatch+SVT",kFALSE},
  {"Y2001" ,"","","db,detDb" ,"","","year2001: geometry - TPC+CTB+FTPC+RICH+CaloPatch+SVT+FPD",kFALSE},
  {"Y2001n","","","db,detDb","","", "year2001: new geometry - TPC+CTB+FTPC+RICH+CaloPatch+SVT+FPD",kFALSE},
  {"Y2003" ,"","","db,detDb","","",
                               "year2003: new geometry - TPC+CTB+FTPC+CaloPatch2+SVT3+BBC+FPD+ECAL",kFALSE},
  {"Y2003X" ,"","","db,detDb","","",
                  "y2003X: new geometry - TPC+CTB+FTPC+CaloPatch2+SVT3+BBC+FPD+ECAL - Full B/E EMC",kFALSE},
  {"Y2003a" ,"","","db,detDb","","",
                                  "Year2003 geometry with corrected barrel EMC and SVT layer radii",kFALSE},
  {"Y2003b" ,"","","db,detDb","","",
    "Year2003 geometry with corrected barrel EMC and SVT layer radii and extra material in the SVT",kFALSE},
  {"Y2003c" ,"","","db,detDb","","",
"Year2003 geometry with corrected barrel EMC and SVT layer radii and extra material in the new SVT",kFALSE},

  {"Y2004" ,"","","db,detDb","","",
       "Initial Yea4 geometry - TPC, SVT, SSD, CTB(TOF), FTPC, EMC, ECAL, PMD, BBC, ZDC, FPD, pVPD",kFALSE},
  {"Y2004a" ,"","","db,detDb","","", "Y2004 with PMD adjusted",kFALSE},
  {"Y2004b" ,"","","db,detDb","","", "Y2004a + SSD materiau",kFALSE},
  {"Y2004x" ,"","","db,detDb","","", "Y2004 with full barrel EMC and two caps ECAL",kFALSE},
  {"Y2004y" ,"","","db,detDb","","", "Y2004 full barrel EMC and two caps ECAL+TPC back+SVT cables",kFALSE},
  {"Y2004c" ,"","","db,detDb","","", "Y2004a + SSD materiau V2",kFALSE},
  {"Y2004d" ,"","","db,detDb","","", "Y2004c + new SVT",kFALSE},

  {"Y2005" ,"","","db,detDb","","", "Initial Year5 geometry", kFALSE},
  {"Y2005x" ,"","","db,detDb","","", "Full barrel EMC Year5 geometry", kFALSE},
  {"Y2005b" ,"","","db,detDb","","", "Year5 geometry + corrections SVT, FTPC gas + SSD y4c", kFALSE},
  {"Y2005c" ,"","","db,detDb","","", "Year5 geometry + more corrections SVT, FTPC gas + SSD y4c", kFALSE},
  {"Y2005d" ,"","","db,detDb","","", "y2005c + new SVT", kFALSE},
  {"ForceGeometry","","","","","", "Force geometry to overwrite the geometry caming from fz-file", kFALSE},

  {"Complete","","","db,detDb" ,"","","complete: new (currently foreseen) complete STAR",kFALSE},
  {"Ist1" ,"","","db,detDb" ,"","","Development geometry STAR",kFALSE},



  {"NoDb" ,"" ,"","-db,-tpcDb,-magF" ,"","","Take out Db from Chain",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Valid Db    ","Versions   ","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"DbV" ,"" ,"","db,ry1h" ,"","","19940614/0 Db Version for none",kFALSE},
  {"DbV0614" ,"" ,"","db,ry1h" ,"","","20000614/0 Db Version for p00hd",kFALSE},
  {"DbV0624" ,"" ,"","db,ry1h" ,"","","20000624/0 Db Version for p00hd_1",kFALSE},
  {"DbV0713" ,"" ,"","db,ry1h" ,"","","20000713/0 Db Version for p00he",kFALSE},
  {"DbV0727" ,"" ,"","db,ry1h" ,"","","20000727/0 Db Version for p00he",kFALSE},
  {"DbV0819" ,"" ,"","db,ry1h" ,"","","20000819/0 Db Version for p00hg",kFALSE},
  {"DbV1123" ,"" ,"","db,ry1h" ,"","","20001123/0 Db wo TpcDriftVel. from StTpcT0Maker",kFALSE},
  {"DbV0523" ,"" ,"","db,ry1h" ,"","", "20010523/0 Db Version for p01he",kFALSE},
  {"DbV1007" ,"" ,"","db,ry1h" ,"","", "20011007/0 Db Version for p01hi",kFALSE},
  {"DbV1107" ,"" ,"","db,ry1h" ,"","", "20011107/0 Db Version for pass1 p01gk",kFALSE},
  {"DbV1211" ,"" ,"","db,ry1h" ,"","", "20011211/0 Db Version for prod p01gl",kFALSE},

  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Trigger Type","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"Physics" ,"","","trg" ,"","","Select Physics events",kFALSE},
  {"LaserTest" ,"","","trg" ,"","","Select Laser events",kFALSE},
  {"PulserSvt" ,"","","trg" ,"","","Select SVT Pulser events",kFALSE},
  {"alltrigger" ,"","","trg" ,"","","Select all events (no trig sel)",kFALSE},






  {"phys_off" ,"","","" ,"","","Turn off physics in simulation",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"C H A I N S ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"doEvents" ,"" ,"","in,StEvent,analysis,NoDb" ,"","","",kFALSE},
  {"drawDst" ,"" ,"","in,ry1h,globT,SCL,geant,display,NoDb,TbUtil" ,"","","",kFALSE},
  {"Cdst" ,"" ,"","global,dst,event,analysis,EventQA" ,"","","",kFALSE},
  {"C1default" ,"" ,"","tpc,rich,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits" ,"","","Year 1 chain",kFALSE},
  {"C2default" ,"" ,"","tpc,rich,l0,Cdst,Kalman,tags,Tree,EvOut,ftpc,svt,emcY2"
                                                                              ,"","","Year 2 chain",kFALSE},
  {"C3default" ,"" ,"","tpc,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits,ftpc,svt,bbcsim,emcY2"
                                                                    ,"","","Year 3 simu base chain",kFALSE},
  {"CAdefault" ,"" ,"","tpc,l0,Cdst,Kalman,tags,Tree,EvOut,NoHits,ftpc,svt,emcY2"
                                                                         ,"","","Assymptotic chain",kFALSE},
  {"Cy1a" ,"" ,"","y1a,C1default" ,"","","Turn on chain y1a",kFALSE},
  {"Cy1b" ,"" ,"","y1b,C1default" ,"","","Turn on chain y1b",kFALSE},
  {"Cy1s" ,"" ,"","y1s,C1default" ,"","","Turn on chain y1s",kFALSE},
  {"Cy1d" ,"" ,"","y1d,C1default" ,"","","Turn on chain y1d",kFALSE},
  {"cy1e" ,"" ,"","y1e,C1default" ,"","","Turn on chain y1h",kFALSE},
  {"cy1h" ,"" ,"","y1h,C1default" ,"","","Turn on chain y1e",kFALSE},
  {"Cy2a" ,"" ,"","y2a,CAdefault" ,"","","Turn on chain y2a",kFALSE},
  {"Cy2b" ,"" ,"","y2b,C2default" ,"","","Turn on chain y2b",kFALSE},
  {"C2000" ,"" ,"","y2000,C1default" ,"","","Turn on chain Y2000",kFALSE},
  {"C2001" ,"" ,"","y2001,C2default" ,"","","Turn on chain Y2001",kFALSE},
  {"C2003" ,"" ,"","y2003,C3default" ,"","","Turn on chain Y2003",kFALSE},
  {"C2003X" ,"" ,"","y2003X,C3default" ,"","","Turn on chain Y2003X (full B/E EMC)",kFALSE},

  {"mdc3" ,"" ,"","cy1h,GeantOut" ,"","","MDC3 default chain",kFALSE},
  {"MDC4" ,"" ,"","C2001,trs,srs,fss,rrs,big,GeantOut" ,"","","Turn on chain for MDC4",kFALSE},
  {"MDC4New" ,"" ,"","y2001n,C2default,trs,srs,fss,rrs,big,GeantOut","","",
                                                     "Turn on chain for MDC4 (for after September)",kFALSE},
  {"PostMDC4" ,"" ,"","C2001,trs,sss,fss,rrs,big,GeantOut" ,"","","Turn on Post MDC4 chain",kFALSE},

  {"ppMDC4" ,"" ,"","ppOpt,C2001,-PreVtx,mwc,trs,srs,rrs,big,GeantOut",
                                                                    "","","Turn on chain for ppMDC",kFALSE},

  {"dAuMDC" ,"" ,"","ppOpt,C2003,-PreVtx,trs,srs,fss,big,GeantOut","","" ,"Chain for d+Au",kFALSE},

  {"dAuMDCa" ,"" ,"","ppOpt,C2003,-PreVtx,trs,srs,fss,big,GeantOut,est","","","Chain for d+Au",kFALSE},

  {"CComplete" ,"" ,"","Complete,C2default" ,"","","Turn on chain for Complete STAR",kFALSE},

  {"SvtD" ,"","","SvtDb,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit", "","","SVT chain for Data",kFALSE},

  {"P00h" ,"" ,"","ry1h,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout,ExB,NoHits","",""
                                                           ,"Production chain for summer 2000 data",kFALSE},
  {"P2000" ,"" ,"","ry2000,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout,ExB,NoHits","",""
                                                           ,"Production chain for summer 2000 data",kFALSE},
  {"B2000" ,"" ,"","ry2000a,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                  ,"Base chain for 2001 (tpc+rhic)",kFALSE},
  {"P2000a" ,"" ,"","B2000,Corr1","","" ,"Production chain for summer 2000 data",kFALSE},


  {"B2001" ,"" ,"","ry2001,in,tpc_daq,tpc,rich,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                  ,"Base chain for 2001 (tpc+rhic)",kFALSE},
  {"P2001" ,"" ,"","B2001,l3onl,tofDat,Corr2,OSpaceZ","",""
                                               ,"Production chain for summer 2001 data (+ l3, tof)",kFALSE},
  {"P2001a" ,"" ,"","B2001,svt_daq,SvtD,ftpc,l3onl,tofDat,emcDY2,Corr2,OSpaceZ","",""
                               ,"Production chain for summer 2001 data (+ ftpc, svt, l3, tof, emc)",kFALSE},

  {"pp2001" ,"" ,"","ppOpt,B2001,-PreVtx,l3onl,tofDat,emcDY2,Corr2","",""
                                                                        ,"pp 2001 (+ l3, tof, emc)",kFALSE},
  {"pp2001a" ,"" ,"","pp2001,svt_daq,SvtD,ftpc","",""
                                                             ,"pp 2001 (+ ftpc, svt, l3, tof, emc)",kFALSE},


  {"B2003" ,"" ,"","ry2003,in,tpc_daq,tpc,Physics,Cdst,Kalman,tags,Tree,evout","",""
                                                                       ,"Base chain for 2003 (tpc)",kFALSE},
  {"dau2003" ,"" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc","",""
                 ,"Production chain for winter 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc)",kFALSE},
  {"dau2003a" ,"" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd","",""
           ,"Production chain for winter 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc, trgd)",kFALSE},
  {"pp2003" , "" ,"","B2003,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd","",""
           ,"Production chain for Spring 2003 data (+ tof, bcc/fpd, svt (no est), ftpc, emc, trgd)",kFALSE},

  {"Idst" ,"" ,"", "dst,event,compend,EventQA" ,"","","Turn on DST for ITTF",kFALSE},
  {"IAna" ,"" ,"","dEdxY2,Kink2,xi2,CMuDst,analysis","","","Turn on User Maker, dEdx and MuDst",kFALSE},
  {"B2003I" ,"","","ry2003,in,tpc_daq,tpcI,fcf,Physics,Idst,l0,tags,Tree,evout"
                                                                  ,"","","Base chain for 2003 ITTF",kFALSE},
  {"dau2003i" ,"","","B2003I,IAna,CtbMatchVtx,Corr2,ppOpt,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd",
                                   "","","Production chain for winter 2003 data dau2003a with ITTF",kFALSE},
  {"pp2003i" ,"" ,"",
                  "B2003I,IAna,CtbMatchVtx,Corr2,ppOpt,-PreVtx,l3onl,ToF,emcDY2,fpd,svt_daq,SvtD,ftpc,trgd",
                                   "","","Production chain for winter 2003 data dau2003a with ITTF",kFALSE},
  {"B2004" ,"" ,"","ry2004,in,tpc_daq,tpcI,svt_daq,SvtD,Physics,Idst,l0,tags,Tree,evout","",""
                                                              ,"Base chain for 2004 ITTF (tpc+svt)",kFALSE},




  {"P2004" ,"" ,"",
     "B2004,IAna,fcf,VFMinuit,l3onl,ToF,emcDY2,fpd,ftpc,trgd,ZDCvtx,svtIT,Corr4,OSpaceZ2",
              "","","Production chain for 2003/2004 data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},
  {"pp2004" ,"" ,"",
     "B2004,IAna,fcf,ppOpt,VFppLMV5,CtbMatchVtx,l3onl,ToF,emcDY2,fpd,ftpc,trgd,ZDCvtx,svtIT,Corr4,OSpaceZ2",
              "","","Production chain for 2003/2004 data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},

  {"B2005" ,"" ,"","ry2005b,in,tpc_daq,tpcI,svt_daq,SvtD,Physics,Idst,l0,tags,Tree,evout","",""
                                                              ,"Base chain for 2005 ITTF (tpc+svt)",kFALSE},

  {"B2005a" ,"" ,"","ry2005b,in,tpc_daq,tpcI,Physics,Idst,-SvtDedx,l0,tags,Tree,evout","",""
                                                             ,"Base chain for 2005 ITTF (tpc only)",kFALSE},




  {"P2005" ,"" ,"",
     "B2005,IAna,fcf,VFMinuit,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,svtIT,Corr3",
              "","","Production chain for 2004/2005 data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},
  {"pp2005" ,"" ,"",
     "B2005,IAna,fcf,ppOpt,VFppLMV5,CtbMatchVtx,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,svtIT,Corr3",
                "","","Production chain for 2005 pp data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},
  {"pp2005a" ,"" ,"",
   "B2005a,IAna,fcf,ppOpt,VFPPV,beamline,CtbMatchVtx,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr4",
                "","","Production chain for 2005 pp data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},


  {"B2006" ,"" ,"","ry2005d,in,tpc_daq,tpcI,svt_daq,SvtD,Physics,Idst,l0,tags,Tree,evout","",""
                                                              ,"Base chain for 2006 ITTF (tpc+svt)",kFALSE},

  {"B2006a" ,"" ,"","ry2005d,in,tpc_daq,tpcI,Physics,Idst,-SvtDedx,l0,tags,Tree,evout","",""
                                             ,"Base chain for 2006 with 2005d geom ITTF (tpc only)",kFALSE},
  {"B2006b" ,"" ,"","ry2006,in,tpc_daq,tpcI,Physics,Idst,-SvtDedx,l0,tags,Tree,evout","",""
                                                             ,"Base chain for 2006 ITTF (tpc only)",kFALSE},







  {"pp2006a" ,"" ,"",
   "B2006a,IAna,fcf,ppOpt,VFPPVnoCTB,beamline,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr3",
                "","","Production chain for 2005 pp data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},
  {"pp2006b" ,"" ,"",
   "B2006b,IAna,fcf,ppOpt,VFPPVnoCTB,beamline,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,Corr4,BeamBack",
                "","","Production chain for 2005 pp data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},


  {"B2007","","","ry2007,MakeEvent,in,tpc_daq,tpcI,fcf,svt_daq,SvtD,ssddat,spt,Physics,Idst,l0,tags,Tree,evout",
                                                        "","","Base chain for 2007 ITTF (tpc+svt+ssd)",kFALSE},
  {"P2007" ,"" ,"",
   "B2007,IAna,KeepSvtHit,hitfilt,skip1row,VFMinuit,l3onl,emcDY2,fpd,ftpc,trgd,ZDCvtx,svtIT,ssdIT,SCEbyE,"
   "OGridLeak3D,OShortR,OSpaceZ2,Corr4",
                      "","","Production chain for 2007 data (+ l3, tof, bcc/fpd, ftpc, e/b-emc, trgd)",kFALSE},







  {"LaserCal0","" ,"","db,detDb,tpc_daq,tpcDb,tcl,globT,laser,LaserTest","","",
                                                                    "Laser Calibration Chain (tcl)",kFALSE},
  {"LaserCal","" ,"","db,detDb,tpc_daq,tpcDb,fcf,globT,laser,LaserTest","","",
                                                                          "Laser Calibration Chain",kFALSE},
  {"L3Counter","" ,"","db,detDb,in,l3count","","", "L3 Counter extraction pass",kFALSE},
  {"VtxSeedCal","","","ppOpt,ry2001,in,tpc_daq,tpc,global,-Tree,Physics,-PreVtx,FindVtxSeed,NoEvent,Corr2",
                                                                     "","","Pass0 Vertex evaluator",kFALSE},
  {"SpcChgCal","","","B2004,fcf,Corr3,OSpaceZ2,OShortR,SCEbyE,-Tree,-tags,-EvOut,-EventQA",
                                                                "","","Pass0 SpaceCharge evaluator",kFALSE},


  {"SpcChgCalG","","","MuDST,fcf,Corr4,OSpaceZ2,OGridLeak3D,SCEbyE,-Tree,-tags,-EvOut,-EventQA",
                                                  "","","Pass0 SpaceCharge evaluator with GridLeak",kFALSE},

  {"VtxSeedCalG","","","MuDST,fcf,Corr4,FindEvtVtxSeed,-Tree,-tags,-EvOut,-EventQA",
                                                                     "","","Pass0 Vertex evaluator",kFALSE},


  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"OPTIONS     ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"ITTF" ,"" ,"","Sti", "","","Turn on ITTF chain",kFALSE},

  {"SvtHitFilt" ,"", "","", "","","SVT Hit filter Maker",kFALSE},
  {"NoHits" ,"" ,"","" ,"","","Don't write hits into Event.Branch",kFALSE},
  {"Kalman" ,"" ,"","geant" ,"","","",kFALSE},
  {"Eval" ,"" ,"","","","" ,"Turn on evaluation switch for different makers",kFALSE},
  {"Ev03" ,"" ,"","","","" ,"Turn on alternative V0 method",kFALSE},
  {"off" ,"" ,"","","","" ,"Turn off default chain",kFALSE},
  {"clearDAQCTB" ,"" ,"","","" ,"" ,"clear DAQ CTB Hits for embedding",kFALSE},
  {"NoInput" ,"" ,"","","" ,"" ,"No input file",kFALSE},
  {"util" ,"" ,"","","","StAnalysisUtilities", "Load StAnalysisUtilities",kFALSE},
  {"FieldOn" ,"" ,"","MagF" ,"","" ,"Constant nominal field",kFALSE},
  {"FieldOff" ,"" ,"","MagF" ,"","" ,"No Field option",kFALSE},
  {"HalfField" ,"" ,"","MagF" ,"","","Half Field option",kFALSE},
  {"ReverseField","" ,"","MagF" ,"","","Reverse Field option",kFALSE},
  {"NoCintDb" ,"" ,"","" ,"","","Switch off standard Cint Db",kFALSE},
  {"NoCintCalDb" ,"" ,"","" ,"","","Switch off local Cint Db",kFALSE},
  {"NoMySQLDb" ,"" ,"","" ,"","","Switch off MySQL Db",kFALSE},
  {"NoEvent" ,"" ,"","-event,-analysis" ,"","","Switch Off StEvent and StAnalysis Makers",kFALSE},
  {"MakeDoc" ,"" ,"","" ,"","","Make HTML documentation for the given Chain",kFALSE},
  {"Debug" ,"" ,"","" ,"","","Set debug flag = 1",kFALSE},
  {"Debug1" ,"" ,"","" ,"","","Set debug flag = 1",kFALSE},
  {"Debug2" ,"" ,"","" ,"","","Set debug flag = 2",kFALSE},
  {"IdTruth" ,"" ,"","" ,"","","Enable IdTruth association in StAssociationMaker",kFALSE},
  {"useInTracker","" ,"","","","" ,"switch from EGR to Sti global tracks in StAssociationMaker",kFALSE},
  {"noRepeat" ,"" ,"","" ,"","","No repeat in Messenger",kFALSE},
  {"useInTracker","" ,"","","","" ,"switch from EGR to Sti global tracks in StAssociationMaker",kFALSE},
  {"noHistos" ,"" ,"","" ,"","","Disables Attributes histos",kFALSE},
  {"Higz" ,"" ,"","" ,"","","Pop Higz window",kFALSE},
  {"big" ,"" ,"","" ,"","","Set NwGEANT =20Mwords",kFALSE},
  {"bigbig" ,"" ,"","" ,"","","Set NwGEANT =40Mwords",kFALSE},

  {"clearmem" ,"" ,"","" ,"","","Instruct StiMaker to clear factory",kFALSE},

  {"InTree" ,"" ,"","in","" ,"","bfcTree Input Tree name",kFALSE},
  {"OutTree" ,"" ,"","Tree","" ,"","bfcTree Output Tree name",kFALSE},
  {"DstOut" ,"" ,"","Tree" ,"","","Write dst to StTree",kFALSE},
  {"McEvOut" ,"" ,"","StMcEvent,Tree" ,"","","Write StMcEvent to StTree",kFALSE},
  {"EvOut" ,"" ,"","Tree" ,"","","Write StEvent to StTree",kFALSE},
  {"GeantOut" ,"" ,"","Tree" ,"","","Write g2t tables to StTree",kFALSE},
  {"Simu" ,"" ,"","" ,"","","Simulated Data",kFALSE},
  {"HitsBranch" ,"" ,"","" ,"","","take out points from dst branch and put them into HitsBranch",kFALSE},
  {"paw" ,"" ,"","" ,"","","Allocate memory for pawc",kFALSE},
  {"AllEvent" ,"" ,"","Tree" ,"","","Write whole event to StTree",kFALSE},
  {"AllTables" ,"" ,"","","" ,"St_Tables","Load Star Tables",kFALSE},

  {"Corr1" ,"" ,"","AlignSectors,ExB,OBmap,OClock,OPr13","","",
                                                      "... AlignSectors,ExB,OBmap,OClock,OPr13 ...",kFALSE},
  {"Corr2" ,"" ,"","AlignSectors,ExB,OBmap,OClock,OPr13,OTwist,OIFC","","",
                                          "... AlignSectors,ExB,OBmap,OClock,OPr13,OTwist,OIFC ...",kFALSE},
  {"Corr3" ,"" ,"","AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC","","",
                                        "... AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC ...",kFALSE},
  {"Corr4" ,"" ,"","AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC,OShortR","","",
                               "... AlignSectors,ExB,OBmap2D,OClock,OPr13,OTwist,OIFC , OShortR...",kFALSE},

  {"ExB" ,"" ,"","","" ,"","Activate ExB correction",kFALSE},
  {"EB1" ,"" ,"","","" ,"","Force ExB configuration 1",kFALSE},
  {"EB2" ,"" ,"","","" ,"","Force ExB configuration 2",kFALSE},
  {"OBmap" ,"" ,"","","" ,"","ExB shape correction",kFALSE},
  {"OBmap2D" ,"" ,"","","" ,"","ExB 2 D shape correction",kFALSE},
  {"OTwist" ,"" ,"","","" ,"","ExB twist correction",kFALSE},
  {"OClock" ,"" ,"","","" ,"","Clock/tpc rot. correction",kFALSE},
  {"OPr13" ,"" ,"","","" ,"","PadRow 13 distortion",kFALSE},
  {"OCentm" ,"" ,"","","" ,"","Central membrane correction",kFALSE},
  {"OECap" ,"" ,"","","" ,"","EndCap (curved) correction",kFALSE},
  {"OIFC" ,"" ,"","","" ,"","Field Cage correction",kFALSE},
  {"OSpaceZ" ,"" ,"","","" ,"","Space Charge corrections",kFALSE},
  {"OSpaceZ2" ,"" ,"","","" ,"","Space Charge corrections R2",kFALSE},
  {"OShortR" ,"" ,"","","" ,"","Shorted Ring correction",kFALSE},
  {"OGridLeak" ,"" ,"","","" ,"","Grid Leak correction",kFALSE},
  {"OGridLeak3D" ,"" ,"","","" ,"","3D Grid Leak correction",kFALSE},
  {"AlignSectors","" ,"","","" ,"","Activate Sector Alignment correction",kFALSE},

  {"EastOff" ,"" ,"","","" ,"","Disactivate East part of tpc",kFALSE},
  {"WestOff" ,"" ,"","","" ,"","Disactivate West part of tpc",kFALSE},
  {"AllOn" ,"" ,"","","" ,"","Activate both East and West parts of tpc",kFALSE},
  {"ReadAll" ,"" ,"","","" ,"","Activate all branches to read",kFALSE},

  {"pp" ,"" ,"","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"ppOpt" ,"" ,"","TrsPileUp","","", "pp option without enabling special cases",kFALSE},
  {"TrsPileUp" ,"" ,"","","","", "Trs pile up mode",kFALSE},
  {"TrsToF" ,"" ,"","","","", "Trs account for particle time of flight",kFALSE},





  {"VtxOffSet" ,"" ,"","","" ,"","Account Primary Vertex offset from y2000 data",kFALSE},
  {"Calibration" ,"" ,"","","" ,"","Calibration mode",kFALSE},
  {"beamLine" ,"" ,"","","" ,"","LMV Beam line constrain",kFALSE},
  {"CtbMatchVtx" ,"" ,"","genvtx","" ,"","... CTB Matching ON in Vertex Finding",kFALSE},
  {"VFPPV" ,"" ,"","genvtx","" ,"","... Pile-up proof vertex finder",kFALSE},
  {"VFPPVnoCTB" ,"" ,"","genvtx","" ,"","... Pile-up proof vertex finder, noCTB",kFALSE},
  {"VFMinuit" ,"" ,"","genvtx","" ,"","... Generic VF will use Minuit method",kFALSE},
  {"VFFV" ,"" ,"","genvtx","" ,"","... Fixed dummy VF method",kFALSE},
  {"VFMCE" ,"" ,"","genvtx","" ,"","... Fixed vertex from MCEvent",kFALSE},

  {"VFppLMV" ,"" ,"","genvtx","" ,"","...VertexMaker will use ppLMV method",kFALSE},
  {"VFppLMV5" ,"" ,"","genvtx","" ,"","...VertexMaker will use ppLMV method (tuned)",kFALSE},



  {"onlcl" ,"" ,"","","" ,"","Read/use TPC DAQ100 clusters",kFALSE},
  {"onlraw" ,"" ,"","","" ,"","Read/use TPC raw hits",kFALSE},

  {"ezTree" ,"" ,"","","" ,"","Create ezTree branch",kFALSE},
  {"BEmcDebug","" ,"","","" ,"","Turn OFF B-EMC hit reconstruction cuts",kFALSE},


  {"useLDV" ,"" ,"","","" ,"","... uses laserDV database flavor",kFALSE},
  {"useCDV" ,"" ,"","","" ,"","... uses ofl database flavor",kFALSE},

  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Tables      ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"tables" ,"" ,"",
     "StDbT,ctf_T,ebyeT,emc_T,ftpcT,gen_T,geomT,globT,l3_T,mwc_T,sim_T,svt_T,tpc_T,trg_T,vpd_T",
                                                                                           "","","",kFALSE},



  {"StDbT" ,"" ,"","","" ,"StDb_Tables","Load StDb_Tables",kFALSE},
  {"ctf_T" ,"" ,"","","" ,"ctf_Tables","Load ctf_Tables",kFALSE},
  {"ebyeT" ,"" ,"","","" ,"ebye_Tables","Load ebye_Tables",kFALSE},
  {"emc_T" ,"" ,"","","" ,"emc_Tables","Load emc_Tables",kFALSE},
  {"ftpcT" ,"" ,"","","" ,"ftpc_Tables","Load ftpc_Tables",kFALSE},
  {"gen_T" ,"" ,"","","" ,"gen_Tables","Load gen_Tables",kFALSE},
  {"geomT" ,"" ,"","","" ,"geometry_Tables","Load geometry_Tables",kFALSE},
  {"globT" ,"" ,"","","" ,"global_Tables","Load global_Tables",kFALSE},
  {"l3_T" ,"", "","","" ,"l3_Tables","Load l3_Tables",kFALSE},

  {"mwc_T" ,"" ,"","","" ,"mwc_Tables","Load mwc_Tables",kFALSE},



  {"sim_T" ,"" ,"","","" ,"sim_Tables","Load sim_Tables",kFALSE},
  {"svt_T" ,"" ,"","","" ,"svt_Tables","Load svt_Tables",kFALSE},
  {"tpc_T" ,"" ,"","","" ,"tpc_Tables","Load tpc_Tables",kFALSE},

  {"trg_T" ,"" ,"","","" ,"trg_Tables","Load trg_Tables",kFALSE},
  {"vpd_T" ,"" ,"","","" ,"vpd_Tables","Load vpd_Tables",kFALSE},





  {"NoSvtIT" ,"" ,"","-SvtIT","" ,"","ITTF: track with switch off SVT geom",kFALSE},
  {"SvtIT" ,"" ,"","","" ,"","ITTF: track using SVT geom",kFALSE},
  {"SsdIT" ,"" ,"","","" ,"","ITTF: track using SSD geom",kFALSE},
  {"HpdIT" ,"" ,"","StiRnD","" ,"","ITTF: track using Hpd geom",kFALSE}
  {"PixelIT" ,"" ,"","StiRnD","" ,"","ITTF: track using Pixel geom",kFALSE},
  {"IstIT" ,"" ,"","StiRnD","" ,"","ITTF: track using Ist geom",kFALSE},
  {"skip1row" ,"" ,"","","" ,"","ITTF: skip the first pad row in TPC",kFALSE},

  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Utilities   ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Geometry+Mag","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"pgf77" ,"" ,"","","" ,"pgf77VMC","Fortran",kFALSE},
  {"minicern" ,"" ,"","","" ,"minicern","minicern",kFALSE},
  {"mysql" ,"" ,"","","" ,"mysqlclient","MySQL",kFALSE},
  {"geometry" ,"" ,"","","" ,"geometry","geometry+Mag.Field",kFALSE},
  {"StarMagField","", "","magF" ,"","StarMagField","Load StarMagField",kFALSE},
  {"geomNoField" ,"" ,"","-geometry,StarMagField" ,"","geometryNoField","geometry-Mag.Field",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},

  {"vpd" ,"" ,"","vpd_T","" ,"St_vpd","",kFALSE},



  {"tls" ,"" ,"","","" ,"tls","",kFALSE},
  {"daq" ,"" ,"","","" ,"StDaqLib,StDAQMaker","Load StDAQMaker",kFALSE},
  {"SCL" ,"" ,"","","" ,"StarClassLibrary","Load StarClassLibrary",kFALSE},
  {"SvtCL" ,"" ,"","","" ,"StSvtClassLibrary","",kFALSE},
  {"TbUtil" ,"" ,"","sim_T,tpc_t,globT,SCL","" ,"StTableUtilities","Load StTableUtilities",kFALSE},
  {"TRGDef" ,"" ,"","","" ,"StTriggerDataMaker","Load StTriggerData",kFALSE},
  {"TofUtil" ,"" ,"","","" ,"StTofUtil","Load StTofUtil",kFALSE},
  {"StBichsel" ,"" ,"","","" ,"StBichsel","Load Bichsel model for dE/dx",kFALSE},
  {"StEvent" ,"" ,"","globT,SCL,TRGDef,StBichsel","" ,"StEvent","Load StEvent",kFALSE},
  {"SsdUtil" ,"" ,"","","" ,"StSsdUtil","Load SSD Util",kFALSE},
  {"EmcUtil" ,"" ,"","emc_T,geomT,StDbT","" ,"StEmcUtil","Load StEmcUtil",kFALSE},
  {"EEmcUtil" ,"" ,"","","" ,"StEEmcUtil","Load StEEmcUtil",kFALSE},
  {"l3Util" ,"" ,"","","" ,"Stl3Util","Load Stl3Util",kFALSE},
  {"PmdUtil" ,"" ,"","","", "StPmdUtil","Load StPmdUtil",kFALSE},
  {"QUtils" ,"" ,"","PmdUtil,EmcUtil","", "","Load QA Libs dependencies",kFALSE},
  {"MuDSTDeps" ,"" ,"","StEvent","","Physics,StEventUtilities,StStrangeMuDstMaker",
                                                              "Load MuDST misc. dependencies (all)",kFALSE},
  {"MuDST" ,"" ,"","MuDSTDeps,EmcUtil,TofUtil,PmdUtil","","StMuDSTMaker","Load MuDST library",kFALSE},
  {"geantL","","","geomT,gen_T,sim_T,StarMagField,geomNoField","","Geom,St_g2t,St_geant_Maker"
                                                                                  ,"Load GeantLibs",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"I/O Makers  ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"gstar" ,"geant" ,"","-fzin,-ntin,-geant,Simu,geantL","St_geant_Maker",
                                      "","gstar for 80 muon tracks with pT = 1GeV in |eta|<4",kFALSE},
  {"tdaq" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"miniDAQ" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"fzin" ,"geant","","Simu,-gstar,-ntin,-geant,geantL","St_geant_Maker","",
                                                                               "read gstar fz-file",kFALSE},
  {"in" ,"" ,"","" , "StIOMaker","StIOMaker","Read [DAQ|ROOT] input file",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"Db makers   ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"dbutil" ,"" ,"","StDbT" ,"","StDbUtilities","Load StDbUtilities",kFALSE},
  {"db" ,"db" ,"","StDbT" ,"St_db_Maker","StDbLib,StDbBroker,St_db_Maker","",kFALSE},
  {"magF" ,"MagField","","StDbT,db","StMagFMaker","StarMagField,StMagF"
                                                         ,"Mag.field map with scale factor from Db",kFALSE},
  {"svtDb" ,"svtDb","","SvtCL,dbutil,db","StSvtDbMaker","StSvtDbMaker","Load and run SvtDbMaker",kFALSE},
  {"ssdDb" ,"ssdDb","","SsdUtil,db","StSsdDbMaker","StSsdDbMaker","Load and run StSsdDbMaker",kFALSE},
  {"detDb" ,"","","","StDetectorDbMaker","StDetectorDbMaker","Load and run StDetectorDbMaker",kFALSE},
  {"eemcDb" ,"eeDb" ,"","db", "StEEmcDbMaker","StEEmcDbMaker","",kFALSE},
  {"tpcDB" ,"tpcDB","","tpc_T,dbutil,db" ,"StTpcDbMaker","StTpcDb","",kFALSE},
  {"trgd" ,"trgd","","TRGDef" ,"StTriggerDataMaker","StTriggerDataMaker","Get trigger data",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"MAKERS      ","-----------","-----------","------------------------------------------","","","",kFALSE},
  {"------------","-----------","-----------","------------------------------------------","","","",kFALSE},



  {"ntin" ,"geant" ,"","paw,-fzin,-geant,-gstar,Simu,geantL,paw","St_geant_Maker",
                                                       "gstar","read event generated Hbook nt-file",kFALSE},
  {"geant" ,"geant","","geantL" ,"St_geant_Maker","","passive GEANT",kFALSE},
  {"RootVMC","","" ,"-geant,-fzin,-ntin,StarMagField,-geantL,-geometry,-geomNoField","",
                                         "Geom,VMC,Physics,EG,Pythia6,EGPythia6,minicern,geant3","",kFALSE},
  {"VMCAppl" ,"","","geomT,gen_t,sim_T,RootVMC","" ,"StarVMCApplication","VMC G3",kFALSE},
  {"VMC" ,"geant","","Simu,VMCAppl,-geant","StVMCMaker", "StVMCMaker","VMC Maker",kFALSE},
  {"VMCPassive" ,"geant","","VMCAppl" ,"StVMCMaker", "StVMCMaker","VMC Maker in Passive Mode",kFALSE},
  {"StMcEvent" ,"","","gen_t,sim_T", ,"StMcEvent","",kFALSE},
  {"McEvent" ,"","","StEvent,EEmcUtil,EmcUtil,StMcEvent","StMcEventMaker" ,"StMcEventMaker","",kFALSE},
  {"MakeEvent","0Event","","StEvent,tpcDB,detDb","StEventMaker","StEventMaker",
                                                                         "<Early StEvent creation>",kFALSE},


  {"l0" ,"l0Chain","","trg_T,globT,ctf,trg" ,"StMaker","StChain","",kFALSE},



  {"ctf" ,"ctf","l0Chain","ctf_T,db" ,"St_ctf_Maker","St_ctf,St_ctf_Maker","",kFALSE},

  {"mwc" ,"mwc","l0Chain","mwc_T,db,tpcDB" ,"St_mwc_Maker","St_mwc,St_mwc_Maker","",kFALSE},
  {"trg" ,"trg","l0Chain","trg_T,globT,db" ,"St_trg_Maker","St_trg,St_trg_Maker","",kFALSE},
  {"ppMCTrig" ,"ppMC_trig1","l0Chain",""
                         ,"StppTrigMaker","StppSpin","Add emulation of pp Trigger based on CTB+MWC",kFALSE},






  {"tpc" ,"tpcChain","","tpc_T,globT,tls,db,tpcDB,tcl,tpt,PreVtx" ,"StMaker","StChain","",kFALSE},
  {"tpcI" ,"tpcChain","","tpc_T,globT,tls,db,tpcDB,TpcHitMover","StMaker","StChain","tpc with ITTF",kFALSE},
  {"Trs" ,"Trs","tpcChain","scl,tpcDB,tpc_daq,Simu" ,"StTrsMaker","StTrsMaker","",kFALSE},
  {"TrsMini" ,"","tpcChain","scl,tpcDB,-Trs,-tpc_daq,Simu","StTrsMiniMaker","StTrsMiniMaker","",kFALSE},

  {"Mixer" ,"tpc_raw","","","StMixerMaker" ,"StDaqLib,StDAQMaker,StTrsMaker,StMixerMaker","",kFALSE},
  {"St_tpc" ,"","","tpc_T,tpcDb" ,"","St_tpc","",kFALSE},
  {"St_svt" ,"","","svt_T,svtDb" ,"","St_svt","",kFALSE},

  {"tpc_daq" ,"tpc_raw","tpcChain","detDb,tpc_T" ,"St_tpcdaq_Maker","St_tpcdaq_Maker","",kFALSE},
  {"tfs" ,"","tpcChain","Simu,tcl" ,"","","use tfs (no StTrsMaker)",kFALSE},
  {"tcl" ,"tpc_hits","tpcChain","tls,St_tpc,StEvent","St_tcl_Maker","St_tcl_Maker",
                                                                        "Cluster Finder (from raw)",kFALSE},
  {"fcf" ,"","tpcChain","daq,-tcl", "StRTSClientFCFMaker","StRTSClientFCF,StRTSClientFCFMaker",
                                                                       "Offline FCF Cluster finder",kFALSE},
  {"Velo" ,"","tpcChain","tpc_T,tls" ,"StVeloMaker","StVeloMaker","",kFALSE},

  {"TpcHitFilter","tpc_hit_filter","tpcChain","" ,"StTpcHitFilterMaker","StTpcHitFilterMaker","",kFALSE},

  {"TpcHitMover" ,"tpc_hit_mover","tpcChain","StEvent",
                      "StTpcHitMover","StTpcHitMoverMaker","TPC hits coord transform + corrections",kFALSE},
  {"tpt" ,"tpc_tracks","tpcChain","tls,St_tpc,TpcHitMover", "St_tpt_Maker","St_tpt_Maker","",kFALSE},
  {"tpt_old" ,"tpc_tracks","tpcChain","St_tpc,tls", "St_tpt_Maker","St_tpt_Maker","",kFALSE},
  {"TpcT0" ,"TpcT0","","ctf_T,ftpcT,tls,St_tpc,St_svt,tpc_daq,kalman,StEvent","StTpcT0Maker",
                            "St_tcl_Maker,St_tpt_Maker,St_global,St_dst_Maker,StPass0CalibMaker","",kFALSE},

  {"ChargeStep","","","tpc_T,globT,tls,db,tpcDB,tpc_daq","StChargeStepMaker","StChargeStepMaker","",kFALSE},

  {"laser" ,"tpc_tracks","LaserTest,tpcChain","tdaq,tpc,-tpt,-PreVtx"
                                           ,"StLaserEventMaker","StLaserEvent,StLaserEventMaker","",kFALSE},
  {"PreVtx" ,"","tpcChain","tpt,SCL,sim_T,St_tpc,St_svt,ftpcT,ctf_T",
                                                     "StPreVertexMaker","St_global,St_dst_Maker","",kFALSE},

  {"svt" ,"svtChain","","svt_T,SvtCL,Est" ,"StMaker","StChain","",kFALSE},



  {"sss" ,"","","SvtSlowSim" ,"","","Short cut for SvtSlowSim",kFALSE},
  {"SvtSlowSim" ,"","","SvtSSim,SvtOnlSeq" ,"","","Short cut for SvtSlowSim and SvtOnlSeq",kFALSE},
  {"SvtSSim","SvtSSimu","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit"
                                  ,"StSvtSimulationMaker","StSvtSimulationMaker,StSvtCalibMaker","",kFALSE},

  {"SvtEmbed" ,"","","SvtSSim,SvtEm,SvtOnlSeq" ,"","","Short cutfor SvtSlowSim and SvtOnlSeq",kFALSE},
  {"SvtEm","SvtEm","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit","StSvtEmbeddingMaker",
                                                          "StSvtSimulationMaker,StSvtCalibMaker","",kFALSE},
  {"SvtOnlSeq" ,"SvtOnlSeq","svtChain","svtDb,SvtCL,Simu,SvtSeqAdj,SvtClu,SvtCluAnal,SvtHit"
                                             ,"StSvtOnlineSeqAdjSimMaker","StSvtSimulationMaker","",kFALSE},

  {"srs" ,"svt_hits","svtChain","svtDb,tls,Simu,St_tpc,St_svt,SvtCL,-sss,-SvtSlowSim,StEvent"
                                                ,"St_srs_Maker","StSvtClusterMaker,St_srs_Maker","",kFALSE},
  {"svt_daq" ,"svt_raw","svtChain","SvtCL" ,"StSvtDaqMaker","StSvtDaqMaker","",kFALSE},
  {"SvtSeqAdj" ,"SvtSeqAdj","svtChain","SvtCL" ,"StSvtSeqAdjMaker","StSvtSeqAdjMaker","",kFALSE},
  {"SvtClu" ,"SvtClu","svtChain","svt_T,StEvent,SvtCL","StSvtClusterMaker","StSvtClusterMaker","",kFALSE},
  {"SvtCluAnal" ,"SvtCluAnal","svtChain","SvtCL","StSvtClusterAnalysisMaker","StSvtClusterMaker","",kFALSE},
  {"SvtHit" ,"svt_hits","svtChain","SvtCL" ,"StSvtHitMaker","StSvtClusterMaker","",kFALSE},

  {"SvtVtx" ,"SvtVtx","SvtChain","" ,"StSvtVertexFinderMaker","StSvtClusterMaker","",kFALSE},

  {"stk" ,"svt_tracks","svtChain","tls,St_tpc,St_svt,SvtCL","St_stk_Maker","St_stk_Maker","",kFALSE},
  {"Est" ,"","svtChain","St_svt" ,"StEstMaker","St_global,StEstMaker","",kFALSE},

  {"global" ,"globalChain","","globT,St_tpc,St_svt,Match,vertex,primary,dst,SCL,dEdxY2"
                                                                            ,"StMaker","StChain","",kFALSE},
  {"Match" ,"match","globalChain","SCL,tpc_T,St_svt,tls"
                                                        ,"StMatchMaker","St_global,St_dst_Maker","",kFALSE},

  {"Vertex" ,"Vertex","globalChain","SCL,St_svt,tls"
                                   ,"StVertexMaker","St_global,St_dst_Maker","Primary Vertex finder",kFALSE},
  {"Primary" ,"primary","globalChain","SCL,St_svt,tls","StPrimaryMaker","St_global,St_dst_Maker","",kFALSE},
  {"V0" ,"v0","globalChain","SCL,St_svt,tls" ,"StV0Maker","St_global,St_dst_Maker","",kFALSE},
  {"Xi" ,"xi","globalChain","SCL,St_svt,tls" ,"StXiMaker","St_global,St_dst_Maker","",kFALSE},
  {"Kink","kink","globalChain" ,"SCL,tls,St_svt" ,"StOldKinkMaker" ,"St_global,St_dst_Maker","",kFALSE},

  {"Fglobal" ,"","","","","" ,"WARNING *** Option is OBSOLETE ***",kFALSE},
  {"Fprimary" ,"","","","","" ,"WARNING *** Option is OBSOLETE ***",kFALSE},

  {"dst" ,"dst","globalChain","St_svt,dstOut,SCL,tls,gen_t,sim_T,ctf_T,trg_T,l3_T,ftpcT"
                                                        ,"St_dst_Maker","St_global,St_dst_Maker","",kFALSE},



  {"dEdx" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"svtdEdx" ,"","","", "","","WARNING *** Option is OBSOLETE ***",kFALSE},
  {"Event", "","","StEvent,tpcDB,detDb","StEventMaker","StEventMaker","<StEvent creation/filling>",kFALSE},



  {"pixFastSim","","","StMcEvent,StEvent",
                                   "StPixelFastSimMaker","StPixelFastSimMaker","FastPixelSimulator",kFALSE},
  {"ssdUtil", ,"","","", ,"","StSsdUtil","Ssd utilities",kFALSE},
  {"ssddat" ,"","","ssd_daq" ,"","","SSD full chain for Real Data",kFALSE},
  {"ssd_daq","SpaStrip","","ssddb,St_svt,-sls,-spa,ssdUtil","StSsdDaqMaker","StSsdDaqMaker","... SSD Daq",kFALSE},
  {"ssd" ,"","","sls,spa,spt" ,"","","SSD full chain for simulation",kFALSE},
  {"sls" ,"","","tls,Simu,St_tpc,St_svt,SvtCL","St_sls_Maker","StSsdSimulationMaker",
                                                                           "... SSD slow simulator",kFALSE},
  {"spa" ,"SpaStrip","","tls,Simu,St_tpc,St_svt,SvtCL,ssdUtil","St_spa_Maker","StSsdSimulationMaker",
                                                                     "... SSD Pedestal Annihilator",kFALSE},
  {"spt" ,"","","St_svt,ssdUtil","StSsdPointMaker","StSsdPointMaker","... SSD Point Creator",kFALSE},
  {"emcDY2" ,"emcRaw","emcY2",
     "daq,eemcDb,EEmcUtil,emc_T,EmcUtil,StEvent,PreEcl,Epc","StEmcRawMaker","StEmcRawMaker",
                                                                        "B/E EMC data common maker",kFALSE},
  {"emcAtoE" ,"","" ,"db,emcDY2","StEmcADCtoEMaker","StEmcADCtoEMaker", "B-EMC ADC to E converter",kFALSE},
  {"eemcD" ,"","","","","", "WARNING *** Option is OBSOLETE ***",kFALSE},
  {"ZDCVtx" ,"","","db" ,"StZdcVertexMaker","StZdcVertexMaker","",kFALSE},

  {"emcY2" ,"emcY2","","emc_T,tpc_T,db,emcSim,PreEcl,epc" ,"StMaker","StChain",
                            "EMC Chain for Y2A (must be before makers which include in this chain)",kFALSE},
  {"emcSim" ,"","emcY2","emc_T,EmcUtil,StMcEvent","StEmcSimulatorMaker","StEmcSimulatorMaker",
                                                                           "New simulator for BEMC",kFALSE},
  {"EEfs" ,"eefs","","db,EEmcUtil,MuDst",
                                     "StEEmcFastMaker","StEEmcSimulatorMaker","EEMC fast simulator",kFALSE},

  {"genvtx" ,"","","EEmcUtil","StGenericVertexMaker","Minuit,Sti,StGenericVertexMaker"
                                                                           ,"Generic Vertex Finder",kFALSE},
  {"StiUtil" ,"","","", "","StiUtilities","Load StiUtilities library",kFALSE},
  {"Sti" ,"Sti","","SCL,StEvent,tables,TpcDb,SvtDb,ssdDb,StiUtil","StiMaker",
                               "StEventUtilities,Sti,StiMaker,StiTpc,StiSvt,StiSsd" ,"ITTF tracker",kFALSE},
  {"StiRnD" ,"","","Sti", "","StiRnD", "Load StiRnD shared library",kFALSE},
  {"StiPulls" ,"","","Sti", "","", "Request to make Sti Pulls",kFALSE},
  {"BeamBack" ,"","","StEvent","StBeamBackMaker","StBeamBackMaker"
                                                              ,"Beam background tracker in the TPC",kFALSE},
  {"dEdxY2" ,"dEdxY2","","tpcDb,StEvent","StdEdxY2Maker","StdEdxY2Maker",
                                                                     "Bichsel method used for dEdx",kFALSE},


  {"FindVtxSeed" ,"FindVtxSeed" ,"","","StVertexSeedMaker", "St_global,St_dst_Maker,StPass0CalibMaker",
                                                                     "Performs vertex seed finding",kFALSE},
  {"FindEvtVtxSeed","FindEvtVtxSeed","","","StEvtVtxSeedMaker",
                                   "StPass0CalibMaker","Performs vertex seed finding using StEvent",kFALSE},


  {"Ftpc" ,"ftpcChain" ,"","ftpcT,fcl,fpt" ,"StMaker","StChain","",kFALSE},
  {"fss" ,"ftpc_raw","ftpcChain","SCL,Simu",
                                    "StFtpcSlowSimMaker","StFtpcSlowSimMaker","FTPC Slow simulator",kFALSE},
  {"Fcl" ,"ftpc_hits","ftpcChain","SCL","StFtpcClusterMaker",
                    "StDaqLib,StDAQMaker,StFtpcTrackMaker,StFtpcClusterMaker","FTPC cluster finder",kFALSE},
  {"fpt" ,"ftpc_tracks","ftpcChain","SCL"
                                          ,"StFtpcTrackMaker","StFtpcTrackMaker","FTPC Track Maker",kFALSE},
  {"fdbg" ,"","","fcl,fpt","","","StFtpcClusterMaker and StFtpcTrackMaker will write debugfile",kFALSE},
  {"flaser" ,"","","fpt" ,"","","StFtpcTrackMaker in LASERTRACKING",kFALSE},


  {"pmdRaw" ,"pmdRaw","","PmdUtil,pmdRead,pmdClust" ,"StMaker","StChain","PMD Raw chain",kFALSE},
  {"pmd" ,"pmd","","pmdSim,pmdClust,pmdDis","StMaker" ,"StChain", "PMD Simulation chain",kFALSE},
  {"pmdRead" ,"","","PmdUtil","StPmdReadMaker" ,"StPmdReadMaker", "DAQ reader for PMD",kFALSE},
  {"pmdSim" ,"","","PmdUtil","StPmdSimulatorMaker","StPmdSimulatorMaker","Hit Simulator for PMD",kFALSE},
  {"pmdClust" ,"pmdClust","","","StPmdClusterMaker", "StPmdClusterMaker","ClusterMaker for PMD",kFALSE},
  {"pmdDis" ,"pmdDis","PmdClust","","StPmdDiscriminatorMaker",
                                                  "StPmdDiscriminatorMaker","Discriminator for PMD",kFALSE},




  {"Kink2" ,"kink2","","db,MuDST,-kink","StKinkMaker","StSecondaryVertexMaker",
                                                                          "Find Kinks from StEvent",kFALSE},
  {"V02" ,"v02","","db,MuDST,-V0","StV0FinderMaker","StSecondaryVertexMaker",
                                                                            "Find V0s from StEvent",kFALSE},
  {"Xi2" ,"xi2","","db,MuDST,-V02,-Xi","StXiFinderMaker","StSecondaryVertexMaker",
                                                                         "Xis AND V0s from StEvent",kFALSE},

  {"V0svt" ,"v0svt","","db,MuDST","StV0FinderMaker","StSecondaryVertexMaker",
                                                              "Special: use estGlobal from StEvent",kFALSE},
  {"Xisvt" ,"xisvt","","db,MuDST","StXiFinderMaker","StSecondaryVertexMaker",
                                                              "Special: use estGlobal from StEvent",kFALSE},

  {"SCEbyE" ,"scebye","","","StSpaceChargeEbyEMaker","StEvent,StPass0CalibMaker",
                                                         "Determine EbyE SpaceCharge using StEvent",kFALSE},
  {"SCScalerCal" ,"scscalercal","","","StSpaceChargeEbyEMaker","StEvent,StPass0CalibMaker",
                                                                    "Calibrate SpaceCharge scalers",kFALSE},
  {"PostEmc" ,"PostChain","","emc_T,tpc_T,db,PreEcl,EmcUtil" ,"StMaker","StChain","",kFALSE},
  {"PreEcl" ,"preecl","PostChain","" ,"StPreEclMaker", "StPreEclMaker","B-EMC Cluster finder",kFALSE},
  {"Epc" ,"epc","PostChain","PreEcl,EmcUtil" ,"StEpcMaker","StEpcMaker","B-EMC point maker",kFALSE},
  {"fpd" ,"fpd","","", "StFpdMaker","StFpdMaker","FPD/BBC Data base chain",kFALSE},
  {"rich" ,"RichChain","","rch,RichPiD,RichSpectra", "StMaker","StChain","RICH chain",kFALSE},
  {"Rrs" ,"","RichChain","sim_T,Simu" ,"StRrsMaker","StRrsMaker","",kFALSE},
  {"rch" ,"","RichChain","sim_T,globT" ,"StRchMaker","StRrsMaker,StRchMaker","",kFALSE},
  {"RichPiD" ,"","RichChain","Event" ,"StRichPIDMaker","StRichPIDMaker","",kFALSE},

  {"ToF" ,"TofChain","","tofDat,tofrMatch,tofpMatch,tofCalib","StMaker","StChain","ToF Chain",kFALSE},
  {"tofDat" ,"tof_raw","TofChain","db,Tofutil","StTofMaker","StEvent,StTofMaker",
                                                                              "TOF Data base chain",kFALSE},
  {"tofsim" ,"","TofChain","TofUtil","StTofSimMaker","StEvent,StTofMaker,StTofSimMaker",
                                                                                    "TOF Simulator",kFALSE},
  {"tofrMatch" ,"","TofChain","db,TofUtil","StTofrMatchMaker","StTofrMatchMaker",
                                                                       "TPC to TOFr track matching",kFALSE},
  {"tofpMatch" ,"","TofChain","db,TofUtil","StTofpMatchMaker","StTofpMatchMaker",
                                                                       "TPC to TOFp track matching",kFALSE},
  {"tofCalib" ,"","TofChain","db,TofUtil","StTofCalibMaker","StTofCalibMaker", "TOF calibration",kFALSE},

  {"l3" ,"l3Chain","","l3cl,l3t" ,"StMaker","StChain","",kFALSE},
  {"l3cl" ,"","l3Chain","l3_T,l3util" ,"St_l3Clufi_Maker","St_l3,St_l3Clufi_Maker","",kFALSE},
  {"l3t" ,"","l3Chain","l3_T,l3util" ,"St_l3t_Maker","St_l3,St_l3t_Maker","",kFALSE},
  {"l3onl" ,"","","" ,"Stl3RawReaderMaker","Stl3RawReaderMaker","",kFALSE},
  {"l3count" ,"","","" ,"Stl3CounterMaker","Stl3RawReaderMaker","",kFALSE},

  {"bbcSim" ,"","","db","StBbcSimulationMaker" ,"StBbcSimulationMaker","BBC Simulator",kFALSE},

  {"analysis" ,"","","StEvent" ,"StAnalysisMaker","StAnalysisMaker","Example of Analysis",kFALSE},

  {"compend" ,"","","event","StEventCompendiumMaker","StEventCompendiumMaker",
                                                                 "Fill event summary in ITTF Chain",kFALSE},

  {"pec" ,"PeC","","Event" ,"StPeCMaker","StPeCMaker","PCollAnalysis",kFALSE},
  {"RichSpectra" ,"","","" ,"StRichSpectraMaker","StRichSpectraMaker","",kFALSE},

  {"TagsChain" ,"TagsChain","","" ,"StMaker","StChain","",kFALSE},

  {"TpcTag" ,"","TagsChain","" ,"StTpcTagMaker","StTpcTagMaker","",kFALSE},

  {"Flow" ,"","TagsChain","StEvent" ,"StFlowMaker","StEventUtilities,StFlowMaker","",kFALSE},

  {"FlowTag" ,"","TagsChain","StEvent,Flow" ,"StFlowTagMaker","StFlowTagMaker","",kFALSE},

  {"FlowAnalysis","","TagsChain","StEvent,Flow" ,"StFlowAnalysisMaker","StFlowAnalysisMaker","",kFALSE},
  {"StrangeTags" ,"","TagsChain","StEvent" ,"StStrangeTagsMaker","StStrangeTagsMaker","",kFALSE},
  {"SpectraTag" ,"","TagsChain","StEvent" ,"StSpectraTagMaker","StSpectraTagMaker","",kFALSE},
  {"HeavyTags" ,"","TagsChain","StEVent" ,"StHeavyTagMaker","StHeavyTagMaker","",kFALSE},
  {"HighPtTags" ,"","TagsChain","StEVent" ,"StHighPtTagsMaker","StHighPtTagsMaker","",kFALSE},



  {"PCollTag" ,"","TagsChain","StEvent" ,"StPCollTagMaker","StPCollTagMaker","",kFALSE},
  {"tags" ,"","TagsChain", "globT,Event,StrangeTags,SpectraTag,HeavyTags,PCollTag,HighPtTags"
                                           ,"StTagsMaker","StTagsMaker","Collect all tags to TTree",kFALSE},

  {"MuDSTChain","MuDSTChain","EMCmDST,CMuDST","" ,"StMaker","StChain","",kFALSE},
  {"StrngMuDST","","MuDSTDeps","", "StStrangeMuDstMaker","","Creates Stangeness MuDST",kFALSE},
  {"EMCmDST" ,"","MuDSTChain","MuDst", "StEmcMicroDstMaker","","Creates EMC MuDST",kFALSE},
  {"CMuDST" ,"","MuDSTChain","MuDst,StrngMuDST", "StMuDstMaker","","Writes Common MuDST",kFALSE},
  {"St_geom" ,"" ,"","" , "St_geom_Maker","St_geom_Maker","",kFALSE},
  {"Display" ,"","","TbUtil,St_geom",
               "StEventDisplayMaker","StEvent,StEventUtilities,StEventDisplayMaker","Event Display",kFALSE},
  {"Mc" ,"McChain","McEvent","sim_T,globT,McAss,McAna" ,"StMaker","StChain","",kFALSE},
  {"McAss" ,"","McChain","McEvent", "StAssociationMaker","StAssociationMaker","",kFALSE},
  {"McAnaTpc" ,"","","McAna" "","","Mc Analysis for Tpc",kFALSE},
  {"McAnaSvt" ,"","","McAna" "","","Mc Analysis for Svt",kFALSE},
  {"McAnaSsd" ,"","","McAna" "","","Mc Analysis for Ssd",kFALSE},
  {"McAna" ,"","McChain","McEvent,McAss", "StMcAnalysisMaker","StMcAnalysisMaker","",kFALSE},
  {"McQa" ,"","McChain","McEvent", "StMcQaMaker","StMcQaMaker","QA histogramms for McEvent",kFALSE},
  {"McTpcAna" ,"","McAnaChain","McEvent,McAss",
                                    "StTpcMcAnalysisMaker","StTrsMiniMaker,StTpcMcAnalysisMaker","",kFALSE},
  {"MiniMcEvent" ,"","","","", "StMiniMcEvent","Loads StMiniMcEvent library only",kFALSE},
  {"MiniMcMk" ,"","","McAss,MiniMcEvent","StMiniMcMaker","StMiniMcMaker",
                                                                 "Creates tree in minimc.root file",kFALSE},
  {"SvtMatTree","","","","SvtMatchedTree",
                                  "StSvtPoolEventT,StSvtPoolSvtMatchedTree","Create SvtMatchedTree",kFALSE},
  {"LAna" ,"","","in,RY1h,tpcDb","StLaserAnalysisMaker"
                                                      ,"StLaserAnalysisMaker","Laser data Analysis",kFALSE},

  {"SpinTag" ,"SpinTag","","","StSpinTagMaker","StppSpin","tag for analysis of polarized pp events",kFALSE},
  {"ppLPfind1" ,"ppLPfind1" ,"","" ,"StppLPfindMaker","StppSpin","Find leading particle for pp",kFALSE},
  {"SpinSortA" ,"SpinSortA" ,"","" ,"StSpinSortMaker","StppSpin","Spin sort event",kFALSE},
  {"ppLPprojectA","ppLPprojectA","",""
                      ,"StppLPprojectMaker","StppSpin","project LP to the spin dependent phi-histo",kFALSE},
  {"ppLPeval1" ,"ppLPeval1" ,"","" ,"StppLPevalMaker","StppSpin","Evaluation of LP algo for pp",kFALSE},
  {"ppDAQfilter1","ppDAQfilter1" ,"","" ,"StDAQfilterMaker","StppSpin","DAQ filter (used for pp)",kFALSE},
  {"QA" ,"QA","","QUtils,globT,SCL,global","St_QA_Maker","St_QA_Maker","Filling Y1/Y2 Qa histo",kFALSE},
  {"EventQA","EventQA","","QUtils,Event","StEventQAMaker" ,"St_QA_Maker","Filling Y2/Y3 Qa histo",kFALSE},
  {"QAC" ,"CosmicsQA","globT","" ,"StQACosmicMaker","StQACosmicMaker","",kFALSE},
  {"HitFilt" ,"", "","", "StHitFilterMaker","StHitFilterMaker","Hit filter Maker",kFALSE},
  {"KeepTpcHit" ,"", "","", "","","Keep all TPC hits in StHitFilterMaker",kFALSE},
  {"KeepSvtHit" ,"", "","", "","","Keep all SVT hits in StHitFilterMaker",kFALSE},
  {"Tree" ,"OutTree","","","StTreeMaker","StTreeMaker","Write requested branches into files",kFALSE},
  {"logger" ,"" ,"","" ,"","","Use log4cxx package to manage the program messages",kFALSE},



  {"NoDefault" ,"" ,"","" ,"","","No Default consistency check",kFALSE}
};
#endif

// NoChainOptions -> Number of chain options auto-calculated
ClassImp(StBFChain)

//_____________________________________________________________________________
// Hack constructor.
/*!
 * This method can be called with mode 1 or 2 to enable chain setup 1 or chain
 * setup 2.
 *
 * Note: This constructor now accepts a second argument for the chain name.
 * Embedding scripts were modified accordingly.
 *
 * This was primarily set to make possible the transition between the regular
 * chain and the ITTF chain options.
 */
void StBFChain::Setup(Int_t mode) {
  static Char_t *path  = "./StRoot/StBFChain:$STAR/StRoot/StBFChain";
  TString chain("BFC.C");
  if (mode == 2) chain = "BFC2.C";
  Char_t *file = gSystem->Which(path,chain,kReadPermission);
#ifdef STAR_LOGGER
  if (! file) { LOG_FATAL  << Form("StBFChain::Setup","File %s has not been found in path %s",chain.Data(),path) << endm; }
  else        { LOG_WARN   << Form("StBFChain::Setup","File %s has been found as %s",chain.Data(),file) << endm; }
#else

  if (! file)   Fatal("StBFChain::Setup","File %s has not been found in path %s",chain.Data(),path);
  else        Warning("StBFChain::Setup","File %s has been found as %s",chain.Data(),file);
#endif
  TString cmd(".L ");
  cmd += file;
  gInterpreter->ProcessLine(cmd);
  fchainOpt  = (St_Bfc *) gInterpreter->Calc("CreateTable()");
  cmd = ".U ";
  cmd += file;
  gInterpreter->ProcessLine(cmd);
  assert(fchainOpt);
  fNoChainOptions = fchainOpt->GetNRows();
  fBFC = fchainOpt->GetTable();
  FDate  = FTime  = 0;
  FDateS = FTimeS = 0;
}
//_____________________________________________________________________________
/// Destructor. Call Finish() . See this method for detail on what is cleaned.
StBFChain::~StBFChain(){
  Finish();
}
//_____________________________________________________________________________
/// Routine handling library loading depending on chain options
Int_t StBFChain::Load()
{
  static const Char_t *prefix[3] = {"lib_","lib",""};
  Int_t status = kStOk;
  Int_t i, iok;
  TString lib(gSystem->GetLibraries(0,"D"));
  TObjArray LoadedLibs;
  ParseString(lib,LoadedLibs);
  TIter next(&LoadedLibs);
  TObjString *LoadedLib;
  while ((LoadedLib = (TObjString *) next())){
    TString Base(gSystem->BaseName(LoadedLib->GetName()));
    Base.ReplaceAll(".so","");
    Base.ReplaceAll(".sl","");
    if (Base.BeginsWith("lib_")) Base.ReplaceAll("lib_","");
    if (Base.BeginsWith("lib"))  Base.ReplaceAll("lib","");
    LoadedLib->SetString(Base);
  }
  for (i = 1; i< fNoChainOptions; i++) { // Load Libraries if any
    if (fBFC[i].Flag) {
      if (strlen(fBFC[i].Libs) > 0) {
	TObjArray Libs;
	ParseString(fBFC[i].Libs,Libs);
	TIter nextL(&Libs);
	TObjString *libe = 0;
	Char_t *path = 0;
	while ((libe = (TObjString *) nextL())) {
	  TString libN(libe->GetString());
	  if (libN.BeginsWith("lib_")) libN.ReplaceAll("lib_","");
	  if (libN.BeginsWith("lib"))  libN.ReplaceAll("lib","");

	  TString libL("");
	  for (Int_t j = 0; j < 3; j++) {
	    libL = prefix[j]; libL += libN;
	    if ((path = gSystem->DynamicPathName(libL,kTRUE))) break;
	  }
	  iok = -1;
	  if (path) {
	    TIter next(&LoadedLibs);
	    TObjString *LoadedLib;
	    while ((LoadedLib = (TObjString *) next())){
	      TString Base(LoadedLib->GetName());
	      if (Base == libN) {iok = 1; break;}
	    }
	    if (iok > 0) continue;
	    iok = gSystem->Load(libL);
	    if (iok < 0)  {

         LOG_QA  << "problem with loading of " << libL.Data() << endm;
         LOG_QA  <<  fBFC[i].Key << " is switched off \t!!!!" << endm;

	      fBFC[i].Flag = kFALSE;
	      status = kStErr;
	      assert(iok >= 0);
	      break;
	    } else {
	      if (Debug() > 1) {  TString ts("load "); ts += libL; TMemStat::PrintMem(ts.Data());}

         LOG_QA  << "Library " << Form("%-20s\t(%s)\tis loaded",libL.Data(),path) << endm;

	      LoadedLibs.Add(new TObjString(libN));
	    }
	  }
	}
	Libs.Delete();
      }
    }
  }
  LoadedLibs.Delete();
  return status;
}

//_____________________________________________________________________________
/// Maker-instantiation handler.
/*!
  This routine contains it all (make instantiation that is), from calibration
  precedence to parameter setting depending on option etc ... Other thing done
  here which deserves attention
  - The maker's SetMode() mechanism is treated here.
  - Calibration options like NoMySQLDb, NoCintCalDb or NoCintDb and path are set
  - SetFlavor() sim+ofl or sim is made

  If a maker is added along with some flag options, this is the place to
  implement the switches.
*/
Int_t StBFChain::Instantiate()
{
  Int_t status = kStOk;
  Int_t i, iFail=0;
  for (i = 1; i< fNoChainOptions; i++) {// Instantiate Makers if any
    if (! fBFC[i].Flag) continue;
    if (strlen(fBFC[i].Maker) == 0) continue;
    TString maker(fBFC[i].Maker);
    TString Key(fBFC[i].Key);
    Key.ToLower();
    StMaker *myChain = 0;
    StMaker *mk = 0;
    if (strlen(fBFC[i].Chain) > 0) myChain = GetMaker(fBFC[i].Chain);
    if (maker == "St_db_Maker"){// only one instance for whole chain
      St_db_Maker *dbMk = (St_db_Maker *) GetChain()->Maker(fBFC[i].Name);
      mk = dbMk;
      if (dbMk) continue;
      if (Key.CompareTo("db",TString::kIgnoreCase) == 0) {
	TString MySQLDb("MySQL:StarDb");
	TString MainCintDb("$STAR/StarDb");
	TString MyCintDb("$PWD/StarDb");

	if (GetOption("NoMySQLDb"))   {MySQLDb = "";}
	// Removed twice already and put back (start to be a bit boring)
	// DO NOT REMOVE THE NEXT OPTION - Used in AutoCalibration
	if (GetOption("NoCintCalDb")) {MyCintDb = "";}
	if (GetOption("NoCintDb"))    {MainCintDb = ""; MyCintDb = "";}

	TString Dirs[3];
	Int_t j;
	for (j = 0; j < 3; j++) Dirs[j] = "";
	j = 0;
	if (MySQLDb    != "") {Dirs[j] = MySQLDb;    j++;}
	if (MainCintDb != "") {Dirs[j] = MainCintDb; j++;}
	if (MyCintDb   != "") {Dirs[j] = MyCintDb;   j++;}
	dbMk = new St_db_Maker(fBFC[i].Name,Dirs[0],Dirs[1],Dirs[2]);
	if (!dbMk) goto Error;
	mk = dbMk;
	strcpy (fBFC[i].Name, (Char_t *) dbMk->GetName());
	if (GetOption("Simu"))    dbMk->SetFlavor("sim+ofl");
	else                      dbMk->SetFlavor("ofl");
	goto Add2Chain;
      }
    }
    if (maker == "StIOMaker" && fSetFiles) {
      StIOMaker *inpMk=0;
      if (GetOption("InTree")) {
	Char_t line[80] = "bfcTree";
	Int_t k = kOpt("InTree");
	sscanf(fBFC[k].Comment,"%s",line);
	inpMk = new StIOMaker("inputStream","r",fSetFiles,line);
      }
      else inpMk = new StIOMaker("inputStream","r",fSetFiles);
      if (inpMk) {
	strcpy (fBFC[i].Name,(Char_t *) inpMk->GetName());
	SetInput("StDAQReader",".make/inputStream/.make/inputStream_DAQ/.const/StDAQReader");
	if (GetOption("ReadAll")) {	//activate all branches
	  // inpMk->SetBranch("*",0,"r");
	  const Char_t *allBranches[] = {
	    "dstBranch","dstHitsBranch","emc_rawBranch","eventBranch","ftpc_rawBranch",
	    "geantBranch","globalBranch","McEventBranch","svt_hitsBranch","svt_tracksBranch",
	    "tpc_hitsBranch","tpc_rawBranch","tpc_tracksBranch","trgBranch",0};
	  for (Int_t i = 0; allBranches[i]; i++) inpMk->SetBranch(allBranches[i],0,"r");
	}
	goto Add2Chain;
      }
      goto Error;
    }
    if (maker == "StTreeMaker" && fFileOut != "") {
      StTreeMaker    *treeMk  = 0;
      if (GetOption("OutTree")) {
	Char_t line[80] = "bfcTree";
	Int_t k = kOpt("OutTree");
	sscanf(fBFC[k].Comment,"%s",line);
	treeMk = new StTreeMaker("outputStream",fFileOut.Data(),line);
      }
      else treeMk = new StTreeMaker("outputStream",fFileOut.Data());
      if (treeMk) {
	strcpy (fBFC[i].Name,(Char_t *) treeMk->GetName());
	treeMk->SetIOMode("w");
	SetTreeOptions();
	if (myChain) myChain->AddMaker(treeMk);
	goto Add2Chain;
      }
    }
    // Special makers already created or action which
    // need to take place before 'maker' is created.
    if (maker == "StTpcDbMaker" ||
	maker == "St_geant_Maker" ||
	maker == "StVMCMaker") mk = GetChain()->GetMaker(fBFC[i].Name);
    // All Makers created here
//VP    if (maker == "StiMaker")
//VP      ProcessLine("StiToolkit::setToolkit( new StiDefaultToolkit() );");
      if (!mk) {
      if (strlen(fBFC[i].Name) > 0) mk = New(fBFC[i].Maker,fBFC[i].Name);
      else                          mk = New(fBFC[i].Maker);
      if (mk) {
	strcpy (fBFC[i].Name,(Char_t *) mk->GetName());
	if (maker == "St_geant_Maker") { // takes only first request for geant, if it is active then it should be the first one
	  Int_t NwGeant = 10; // default geant parameters
	  if (!GetOption("fzin") && !GetOption("ntin") &&
	      !GetOption("gstar"))                       NwGeant =  5;
	  if (GetOption("big"))                          NwGeant = 20;
	  if (GetOption("bigbig"))                       NwGeant = 40;
	  ProcessLine(Form("((St_geant_Maker *) %p)->SetNwGEANT(%i);",mk,NwGeant));
	  if (GetOption("Higz")) ProcessLine(Form("((St_geant_Maker *) %p)->SetIwtype(1);",mk));
	  if (GetOption("paw"))  ProcessLine(Form("((St_geant_Maker *) %p)->SetNwPAW(2);",mk));
	  if (GetOption("fzin") || GetOption("ntin") || GetOption("gstar")) mk->SetActive(kTRUE);
	  else                                                              mk->SetActive(kFALSE);
	}
      }
    }
    if (! mk) goto Error;

    // special maker options
    // m_Mode xyz
    //        x = 1 phys_off
    //        y = 1 Passive mode (do not call RunMC()
    //        z = 1 Mixer Mode
    if (maker == "StVMCMaker") {
      if (GetOption("VMCPassive")) {// don't use mk->SetActive(kFALSE) because we want to have InitRun
	mk->SetMode(mk->GetMode() + TMath::Sign(10,mk->GetMode()));
      }
      else {
	if (GetOption("phys_off")) mk->SetMode(mk->GetMode() + TMath::Sign(100,mk->GetMode()));
	if (fInFile != "")  ProcessLine(Form("((StVMCMaker *) %p)->SetInputFile(\"%s\")",mk,fInFile.Data()));
      }
    }
//		Sti(ITTF) start
    if (maker == "StiMaker") {
      if (GetOption("NoSvtIT")) mk->SetAttr("useSvt"	,kFALSE);
      else
	if (GetOption("SvtIT")){
	                        mk->SetAttr("useSvt"	,kTRUE);
	                        mk->SetAttr("activeSvt"	,kTRUE);
	}

      if (GetOption("SsdIT")){
				mk->SetAttr("useSsd"	,kTRUE);
				mk->SetAttr("activeSsd"	,kTRUE);
      }
      if (GetOption("PixelIT")){
				mk->SetAttr("usePixel"	,kTRUE);
				mk->SetAttr("activePixel",kTRUE);
      }
      if (GetOption("IstIT")){
	mk->SetAttr("useIst"  ,kTRUE);
	mk->SetAttr("activeIst",kTRUE);
      }

      if (GetOption("HpdIT")){
	mk->SetAttr("useHpd"  ,kTRUE);
	mk->SetAttr("activeHpd",kTRUE);
      }

      if (GetOption("StiPulls"))  mk->SetAttr("makePulls"  ,kTRUE);
      if (GetOption("skip1row"))  mk->SetAttr("skip1row"   ,kTRUE);
      mk->PrintAttr();
    }
//		Sti(ITTF) end
    if (maker=="StGenericVertexMaker") {
      int                   VtxOpt = 0;
      // VertexFinder methods
      if ( GetOption("VFMinuit") ){  VtxOpt |= (0x1 << 0);} //  1 0x01
      if ( GetOption("VFppLMV") ){   VtxOpt |= (0x1 << 1);} //  2 0x02
      if ( GetOption("VFppLMV5") ){  VtxOpt |= (0x1 << 2);} //  4 0x04
      if ( GetOption("VFPPV") ){     VtxOpt |= (0x1 << 3);} //  8 0x08
      if ( GetOption("VFPPVnoCTB") ){VtxOpt |= (0x1 << 4);} // 16 0x10
      if ( GetOption("VFFV") ){      VtxOpt |= (0x1 << 5);} // 32 0x20
      if ( GetOption("VFMCE") ){     VtxOpt |= (0x1 << 6);} // 64 0x40
      mk->SetMode(VtxOpt);

      // All VertexFinders implement those (or not)
      if (GetOption("beamLine") || GetOption("CtbMatchVtx")) {
	TString  cmd(Form("StGenericVertexMaker* gvtxMk = (StGenericVertexMaker*) %p;",mk));
	if (GetOption("beamLine"))    {cmd += "gvtxMk->UseBeamLine();";}
	if (GetOption("CtbMatchVtx")) {cmd += "gvtxMk->UseCTB();";}
	ProcessLine(cmd);
      }
    }
    if (maker=="StAssociationMaker") {

      LOG_QA << "StBFChain::Instantiate Setting the Parameters for the Association Maker" << endm;

      TString cmd("");
      if (GetOption("ITTF") || GetOption("useInTracker")) 
	cmd = Form ("((StAssociationMaker *) %p)->useInTracker();",mk);
      cmd += "StMcParameterDB* parameterDB = StMcParameterDB::instance();";
      // TPC
      cmd += "parameterDB->setXCutTpc(.5);"; // 5 mm
      cmd += "parameterDB->setYCutTpc(.5);"; // 5 mm
      cmd += "parameterDB->setZCutTpc(.5);"; // 5 mm
      cmd += "parameterDB->setReqCommonHitsTpc(3);"; // Require 3 hits in common for tracks to be associated
      // FTPC
      cmd += "parameterDB->setRCutFtpc(.3);"; // 3 mm
      cmd += "parameterDB->setPhiCutFtpc(5*(3.1415927/180.0));"; // 5 degrees
      cmd += "parameterDB->setReqCommonHitsFtpc(3);"; // Require 3 hits in common for tracks to be associated
      // SVT
      cmd += "parameterDB->setXCutSvt(.08);"; // 800 um
      cmd += "parameterDB->setYCutSvt(.08);"; // 800 um
      cmd += "parameterDB->setZCutSvt(.08);"; // 800 um
      cmd += "parameterDB->setReqCommonHitsSvt(1);"; // Require 1 hits in common for tracks to be associated
      if (GetOption("IdTruth")) cmd += Form("((StAssociationMaker *) %p)->useIdAssoc();",mk);
      ProcessLine(cmd);
    }
    if (maker == "StMiniMcMaker" && GetOption("IdTruth")) {
      mk->SetMode(1);
      gMessMgr->QAInfo() << "StBFChain::Instantiate create simplified MiniMcTree in " << maker  << endm;
    }
    // usually, we do maker first and option second but the
    // logic is more readable with option first here (as it
    // got a bit out of hand)
    if (GetOption("ppOpt") ) {                         // pp specific stuff
      if (maker == "StTrsMaker")
	mk->SetMode(1);       // Pile-up correction

      if (maker == "StVertexMaker"){
	cout << "QAInfo: ppOpt (pp mode) is turned ON" << endl;
	if( GetOption("SvtMatchVtx"))    mk->SetMode(4); // Switch vertex finder to ppLMV using EST
	else if ( GetOption("VFppLMV5")) mk->SetMode(8); // LMV4 with LMV5 cuts
	else                             mk->SetMode(1); // Switch vertex finder to ppLMV
	if( GetOption("beamLine"))                      // Add beam-line constrain
	  ProcessLine(Form("((StVertexMaker *) %p)->SetBeam4ppLMV();",mk));

	if( GetOption("fzin") || GetOption("ntin") ||GetOption("gstar") || GetOption("VMC")){// get CTB's from MC
	  LOG_QA << "QAInfo: Simulation is used, setting CTB Mode to 1" << endm;
	  ProcessLine(Form("((StVertexMaker *) %p)->SetCTBMode(1);",mk));
	} else if ( GetOption("clearDAQCTB") ){        // remove CTB from DAQ (embedding)
	  LOG_QA << "QAInfo: clearDAQCTB used, will removed CTB hits from DAQ"  << endm;
	  ProcessLine(Form("((StVertexMaker *) %p)->SetCTBMode(2);",mk));
	} else{
	  LOG_QA << "QAInfo: Will get CTB from DAQ file" << endm;
	  ProcessLine(Form("((StVertexMaker *) %p)->SetCTBMode(0);",mk));
	}
      }
    } else {
      // See section above associated to GetOption("ppOpt") for pp specific.
      // This part was reshaped to avoid confusion and possible
      // option overwrite if one is not carefull enough ... VtxOffset
      // way used in RY1h and RY2000 only and abandonned later. If re-appear,
      // maker == StVertexmaker would have to be its own block with a ppOpt
      // embedded logic.
      if ((maker == "StVertexMaker"  || maker == "StPreVertexMaker") &&
	  GetOption("VtxOffSet")){
	LOG_QA << "QAInfo: VtxOffSet is ON" << endm;
	if ( GetOption("SvtMatchVtx") )  mk->SetMode(3);
	else                             mk->SetMode(2);
      }
    }

    if (maker == "StStrangeMuDstMaker" && GetOption("CMuDST")&& GetOption("StrngMuDST") ) {
      TString cmd(Form("StStrangeMuDstMaker *pSMMk = (StStrangeMuDstMaker*) %p;",mk));
      cmd += "pSMMk->DoV0();";                                 // Set StrangeMuDstMaker parameters
      cmd += "pSMMk->DoXi();";
      cmd += "pSMMk->DoKink();";
      cmd += "pSMMk->SetNoKeep();";                            // Set flag for output OFF
      ProcessLine(cmd);
    }

    // Alex requested an option (not turned by default) to disable all
    // hit reco cuts. This will make allm hits saved to MuDST /ezTree.
    if ( maker == "StEmcRawMaker" && GetOption("BEmcDebug"))
      mk->SetMode(1); // only one option now, bit a bitmask

    // MuDST and ezTree. Combinations are
    //  ezTree         -> ezTree only
    //  CMuDST         -> regular MuDST only
    //  ezTree,CMuDST  -> both
    if (maker == "StMuDstMaker" && GetOption("ezTree") ){
      TString cmd(Form("StMuDstMaker *pMuMk = (StMuDstMaker *) %p;",mk));
      if ( ! GetOption("CMuDST")) cmd += "pMuMk->SetStatus(\"*\",0);";
      cmd += "pMuMk->SetStatus(\"EztAll\",1);";
      ProcessLine(cmd);
    }

    if (maker == "St_dst_Maker") SetInput("dst",".make/dst/.data/dst");
    if (maker == "St_dst_Maker" && GetOption("HitsBranch")) mk->SetMode(2);
    if (maker == "StMatchMaker" && !GetOption("Kalman")) mk->SetMode(-1);
    if (maker == "StLaserEventMaker"){
      // Bill stuff - Empty place-holder
    }
    if (maker == "St_tpt_Maker" && (GetOption("MINIDAQ") || GetOption("Eval"))) {
      TString cmd(Form("St_tpt_Maker *tptMk = (St_tpt_Maker *) %p;",mk));
      if (GetOption("MINIDAQ")) cmd += "tptMk->Set_final(kTRUE);";// Turn on the final ntuple.
      if (GetOption("Eval")) {
	cmd += "tptMk->tteEvalOn();";   //Turn on the tpc evaluation
	cmd += "tptMk->tptResOn();";    // Turn on the residual table
      }
      ProcessLine(cmd);
    }
    if ( (maker == "StTpcHitMover" || maker == "St_tpt_Maker") && GetOption("ExB")){
      // bit 0 is ExB ON or OFF
      // The next 3 bits are reserved for yearly changes.
      // Backward compatibility preserved.
      int mask=1;                                    // Al Saulys request
      if( GetOption("EB1") ){
	// Do nothing (i.e. bit 1 at 0)
      } else if ( GetOption("EB2") ){
	// Force bit 1 at 1 regardless
	mask = mask | 2;
      } else {
	// depend on RY option i.e. take default for that RealYear data
	// expectations.
	if( GetOption("RY2001")  ||
	    GetOption("RY2003")  ||
	    GetOption("RY2003a") ||
	    GetOption("RY2003b") ||
	    GetOption("RY2003X")) mask = mask | 2 ;  // Jim Thomas request
      }
      // Other options introduced in October 2001 for distortion corrections
      // studies and year1 re-production. Those are OR additive to the mask.
      //(void) printf("StBFChain:: Options list : %d %d %d %d %d %d %d %d\n",
      //		  kPadrow13,kTwist,kClock,kMembrane,kEndcap,
      //            kIFCShift,kSpaceCharge,kSpaceChargeR2);
      if( GetOption("OBmap")      ){	mask |=   (kBMap          << 1); }
      if( GetOption("OBMap2d")    ){    mask |=   (kFast2DBMap    << 1); }
      if( GetOption("OPr13")      ){	mask |=   (kPadrow13      << 1); }
      if( GetOption("OTwist")     ){	mask |=   (kTwist         << 1); }
      if( GetOption("OClock")     ){	mask |=   (kClock         << 1); }
      if( GetOption("OCentm")     ){	mask |=   (kMembrane      << 1); }
      if( GetOption("OECap")      ){	mask |=   (kEndcap        << 1); }
      if( GetOption("OIFC")       ){	mask |=   (kIFCShift      << 1); }
      if( GetOption("OSpaceZ")    ){	mask |=   (kSpaceCharge   << 1); }
      if( GetOption("OSpaceZ2")   ){    mask |=   (kSpaceChargeR2 << 1); }
      if( GetOption("OShortR")    ){    mask |=   (kShortedRing   << 1); }
      if( GetOption("OGridLeak")  ){    mask |=   (kGridLeak      << 1); }
      if( GetOption("OGridLeak3D")){    mask |=   (k3DGridLeak    << 1); }
      LOG_QA << "StBFChain::Instantiate ExB The option passed will be " << Form("%d 0x%X\n",mask,mask) << endm;
      mk->SetMode(mask);
    }
    if (maker == "St_tpt_Maker" && GetOption("AlignSectors"))
      ProcessLine(Form("((St_tpt_Maker *)%p)->AlignHits(kTRUE);",mk));
    if (maker == "StTpcHitMover" && GetOption("AlignSectors"))
      ProcessLine(Form("((StTpcHitMover *)%p)->AlignHits(kTRUE);",mk));
    if (maker == "St_tcl_Maker") {
      TString cmd(Form("St_tcl_Maker *tclMk = (St_tcl_Maker *) %p;",mk));
      Int_t kopts = 0;
      if (GetOption("EastOff")) {cmd += "tclMk->EastOff();"; kopts++;}
      if (GetOption("WestOff")) {cmd += "tclMk->WestOff();"; kopts++;}
      if (GetOption("AllOn"))   {cmd += "tclMk->AllOn();"; kopts++;}
      if (GetOption("ITTF"))    {cmd += "tclMk->SetMode(1);"; kopts++;}
      if (GetOption("Eval")) {
	cmd += "tclMk->tclPixTransOn();";// Turn on flat adcxyz table
	cmd += "tclMk->tclEvalOn();";    //Turn on the hit finder evaluation
	kopts++;
      }
      if (kopts) ProcessLine(cmd);
    }
    if (maker == "StTrsMiniMaker" && ! GetOption("TrsToF")) {
      Int_t mode = mk->GetMode();
      mode |= (1 << 10); // kNoToflight   //10 don't account for particle time of flight
      mk->SetMode(mode);
    }
    if (maker == "StTrsMaker") {
      Int_t mode = 0;
      if (GetOption("TrsPileUp")) mode += 1; // Pile-up correction
      if (GetOption("TrsToF"))    mode += 2; // accoutn for particle time of flight
      if (mode) mk->SetMode(mode);
    }
    if (maker == "St_tpcdaq_Maker") {
      Int_t DMode=0;
      TString cmd(Form("St_tpcdaq_Maker *tcpdaqMk = (St_tpcdaq_Maker *) %p;",mk));

      // Beware of those ...
      if      (GetOption("Trs"))   mk->SetMode(1); // trs
      else if (GetOption("Simu"))  mk->SetMode(2); // daq, no gain
      else                         mk->SetMode(0); // daq

      // DAQ100 or Raw switch options -- Please, adjust StRTSClientFCFMaker block as well
      if ( GetOption("onlcl") )   DMode = DMode | 0x2;  // use the online TPC clusters (DAQ100) info if any
      if ( GetOption("onlraw") )  DMode = DMode | 0x1;  // use the TPC raw hit information

      if (DMode != 0) // set flag, leave default = 1
	cmd += Form("tcpdaqMk->SetDAQFlag(%i);",DMode);
      // Correction depending on DAQ100 or not
      // bit 0  =   do GAIN_CORRECTION
      // bit 1  =   do NOISE_ELIM
      // bit 2  =   do ASIC_THRESHOLDS
      // WARNING Option FCF is checked in StDAQMaker
      Int_t Correction = 0;
      Int_t SequenceMerging = 0;
      if ( GetOption("fcf")   ){
	if ( GetOption("Trs")   )  Correction = 0x5; // ASIC + GAIN
	else                       Correction = 0x0; // fcf && ! trs => no corrections
      } else {
	SequenceMerging = 1;
	Correction = 0x7;
      }
      cmd += Form("tcpdaqMk->SetCorrection(%d);",Correction); // default Correction = 0x7
      cmd += Form("tcpdaqMk->SetSequenceMerging(%d);",SequenceMerging);
      LOG_QA << "StBFChain::Instantiate  maker==" << maker.Data()
			 << Form(" SetDAQFlag(%d) SetMode(%d) SetCorrection(%d) SetSequenceMerging(%d)",
				 DMode,mk->GetMode(),Correction,SequenceMerging) << endm;
      ProcessLine(cmd);
    }
    if (maker == "StRTSClientFCFMaker"){
      Int_t DMode=0;
      // use the online TPC clusters (DAQ100) info if any
      if ( GetOption("onlcl") && ! GetOption("onlraw") )  DMode = DMode | 0x2;
      // use the TPC raw hit information
      if ( GetOption("onlraw")&& ! GetOption("onlcl")  )  DMode = DMode | 0x1;
      if ( GetOption("Simu")                           )  DMode = DMode | 0x4;
      if (DMode) mk->SetMode(DMode);                 // set flag (matches tcpdaqMk->SetDAQFlag())
    }

    if (maker == "StTpcT0Maker"){
      Int_t mask = 0;
      if ( GetOption("tcl") ) mask = mask | 0x0;
      if ( GetOption("fcf") ) mask = mask | 0x1;
      LOG_QA << "StBFChain::Instantiate For " << maker.Data()
			 << " tcl is ";
      if (GetOption("tcl")) { LOG_QA << "on";  }
      else                  { LOG_QA << "off"; }
      LOG_QA << ", fcf is ";
      if (GetOption("fcf")) { LOG_QA << "on";  }
      else                  { LOG_QA << "off"; }
      LOG_QA << " => mask = " << mask << endm;
      mk->SetMode(mask);
    }

    if (maker == "StRchMaker") {
      if (GetOption("Rrs")) mk->SetMode(1); // rrs
      else                  mk->SetMode(0); // daq
    }

    // Place-holder. Would possibly be a bitmask
    if (maker == "StTofrMatchMaker"){
      mk->SetMode(0);
    }

    // Turn on alternative V0 method
    if (maker == "StV0Maker") {
      if (GetOption("Ev03")) mk->SetMode(1);
      if (GetOption("Eval")) ProcessLine(Form("((StV0Maker *) %p)->ev0EvalOn();",mk));
    }
    //if (maker == "StKinkMaker"){
    // // Placeholder for KinkMaker control.
    // // - SetMode(1)   TPT,
    // // - SetMode(2)   ITTF
    // // Default = Both
    //}
    if (maker == "StSpaceChargeEbyEMaker") {
      if ( GetOption("SpcChgCal") ||
	   GetOption("SpcChgCalG"))   mk->SetMode(2);
      if ( GetOption("SCScalerCal") ) mk->SetMode(4);
    }
    if (maker == "StEventQAMaker" && GetOption("alltrigger") )
      ProcessLine(Form("((StEventQAMaker *) %p)->AllTriggers();",mk));
    //Special options for V0s and Xis using estGlobal tracks
    if(maker=="StV0FinderMaker" && Key=="v0svt"){
      TString cmd(Form("StV0FinderMaker *V0mk=(StV0FinderMaker*) %p;",mk));
      cmd += "V0mk->SetLanguageUsage(0);";
      cmd += "V0mk->SetSVTUsage(1);";
      cmd += "V0mk->SetV0LanguageUsage(3);";
      ProcessLine(cmd);
    }
    if(maker=="StXiFinderMaker" && Key=="xisvt"){
      TString cmd(Form("StXiFinderMaker *Ximk=(StXiFinderMaker*) %p;",mk));
      cmd += "Ximk->SetLanguageUsage(0);";
      cmd += "Ximk->SetSVTUsage(1);";
      cmd += "Ximk->SetV0LanguageUsage(3);";
      cmd += "Ximk->SetXiLanguageUsage(5);";
      ProcessLine(cmd);
    }
#ifndef YF_CLeanUp
    if (maker == "St_trg_Maker") {
      Int_t mode = 0;
      if (! GetOption("alltrigger")){
	if (GetOption("Physics"))   mode += 1;
	if (GetOption("LaserTest")) mode += 2;
	if (GetOption("PulserSvt")) mode += 4;
      } else {
        LOG_QA << "'alltrigger' option on. All others ignored" << endm;
      }
      if (mode) mk->SetMode(mode);
    }
#endif
    if ((maker == "StdEdxMaker" || maker == "StdEdxY2Maker" ) &&
	GetOption("Simu"))  mk->SetMode(-10);
    if (maker == "StTpcDbMaker"){
      mk->SetMode(0);
      // this change may be temporary i.e. if Simulation includes
      // rotation/translation, this won't be necessarily true.
      // Will investigate further.
      if (GetOption("Simu")) mk->SetMode(1);
      // This is commented for now but may be used. Those extensions
      // were implemented by David H. on Jan 2 2002. DEfault is ofl+laserDV
      //mk->UseOnlyLaserDriftVelocity();    // uses laserDV database
      //mk->UseOnlyCathodeDriftVelocity();  // uses offl database
      if ( GetOption("useLDV") || GetOption("useCDV") ) {
	TString cmd(Form("StTpcDbMaker *Tmk=(StTpcDbMaker*) %p;",mk));
	if ( GetOption("useLDV") ) cmd += "Tmk->UseOnlyLaserDriftVelocity();";  // uses laserDV database
	if ( GetOption("useCDV") ) cmd += "Tmk->UseOnlyCathodeDriftVelocity();";// uses ofl database
	ProcessLine(cmd);
      }
    }
    if (maker == "StSvtDbMaker" || maker == "StSsdDbMaker"){
      mk->SetMode(0);
      // If simulation running make sure pick up simu stuff from db
      if (GetOption("Simu")) mk->SetMode(1);
    }

    // FTPC
    if ((maker == "StFtpcClusterMaker" ||
	 maker == "StFtpcTrackMaker"    )  &&
	GetOption("fdbg"))                     mk->SetMode(mk->GetMode()+2);
    if ( maker == "StFtpcTrackMaker"       &&
	 GetOption("flaser"))                  mk->SetMode(mk->GetMode()+1);
    // FTPC

    // Hit filtering will be made from a single maker in
    // future with flexible filtering method
    if (maker == "StHitFilterMaker") {
      if (GetOption("SvtHitFilt")){
	// Filter out SVT bad hits, TPC hits not on tracks and all hits if fabs(ZVert)>30
	LOG_QA << "SVT hit filter is ON" << endm;
	TString cmd(Form("StHitFilterMaker *Filtmk=(StHitFilterMaker*) %p;",mk));
	cmd += "Filtmk->setPtLowerCut(-99.);";
	cmd += "Filtmk->setPtUpperCut(-99.);";
	cmd += "Filtmk->setAbsEtaCut(-99);";
	cmd += "Filtmk->setAbsZVertCut(30);";
	ProcessLine(cmd);
      } else {
	LOG_QA << "Default hit filtering is ON" << endm;
      }
      Int_t mode = 0;
      if (GetOption("KeepTpcHit")) mode |= (1 << kTpcId);
      if (GetOption("KeepSvtHit")) mode |= (1 << kSvtId);
      mk->SetMode(mode);
    }
    if (GetOption("dst") && GetOption("NoHits") && maker == "StEventMaker") {
      ProcessLine(Form("((StEventMaker *) %p)->doLoadTpcHits  = kFALSE;", mk));
      ProcessLine(Form("((StEventMaker *) %p)->doLoadFtpcHits = kFALSE;", mk));
      ProcessLine(Form("((StEventMaker *) %p)->doLoadSvtHits  = kFALSE;", mk));
      ProcessLine(Form("((StEventMaker *) %p)->doLoadSsdHits  = kFALSE;", mk));
    }
    if (maker == "StMiniMcMaker" && fFileOut != "") {
      ProcessLine(Form("((StMiniMcMaker *) %p)->setFileName(\"%s\");", mk, fFileOut.Data()));
    }
    if (maker == "StMcAnalysisMaker") {
      Int_t mode = 0;
      if (GetOption("McAnaTpc")) mode += 0x1;
      if (GetOption("McAnaSvt")) mode += 0x2;
      if (GetOption("McAnaSsd")) mode += 0x4;
      if (mode) 
	ProcessLine(Form("((StMaker *) %p)->SetMode(%i);", mk, mode));
    }
  Add2Chain:
    if (myChain) myChain->AddMaker(mk);
    continue;
  Error:
    status = kStErr;
    if (i != iFail) {
      LOG_QA	<< " ======================================"          << endm;
	LOG_QA	<< " problem with Instantiation of " << fBFC[i].Maker << endm;
	LOG_QA	<< " ======================================"          << endm;
      iFail = i;
    }
  }
  //  PrintQAInfo();
  PrintInfo();
  // START the chain (may the force be with you)
  // Create HTML docs of all Maker's inv
  if (GetOption("MakeDoc"))  MakeDoc();
  if (GetOption("Debug"))    SetDEBUG(1);
  if (GetOption("Debug1"))   SetDEBUG(1);
  if (GetOption("Debug2"))   SetDEBUG(2);
  if (GetOption("nohistos")) SetAttr(".histos",0,"*");
  else                       SetAttr(".histos",1,"*");
  if (GetOption("NoRepeat")) gMessMgr->IgnoreRepeats();
  return status;
}
//_____________________________________________________________________
Int_t StBFChain::Init() {
  SetDbOptions();
  SetGeantOptions();
  Int_t iok = StChain::Init();
  if (GetOption("gstar") && fInFile == "") {
    StMaker *geantMk = GetMaker("geant");
    if (geantMk && !geantMk->InheritsFrom("St_geant_Maker")) geantMk = 0;
    if (geantMk) {
      ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"subevent 0;\");",geantMk));
      // gkine #particles partid ptrange yrange phirange vertexrange
      ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"gkine 80 6 1. 1. -4. 4. 0 6.28  0. 0.;\");",geantMk));
      ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"mode g2tm prin 1;\");",geantMk));
      //  ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"next;\");",geantMk));
      //  ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"dcut cave z 1 10 10 0.03 0.03;\");",geantMk));
      if (GetOption("Debug") || GetOption("Debug2")) {
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"debug on;\");",geantMk));
	if (GetOption("Debug2")) ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"swit 2 3;\");",geantMk));
      }
      if (GetOption("phys_off")) {
	LOG_INFO << "St_geant_Maker::Init switch off physics" << endm;
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"DCAY 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"ANNI 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"BREM 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"COMP 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"HADR 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"MUNU 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"PAIR 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"PFIS 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"PHOT 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"RAYL 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"LOSS 4\");",geantMk)); // no fluctuations
	//  ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"LOSS 1\");",geantMk)); // with delta electron above dcute
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"DRAY 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"MULS 0\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"STRA 0\");",geantMk));
	//                                              CUTS   CUTGAM CUTELE CUTHAD CUTNEU CUTMUO BCUTE BCUTM DCUTE DCUTM PPCUTM TOFMAX GCUTS[5]
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"CUTS     1e-3   1e-3   .001   .001   .001  .001  .001  1e-3  .001   .001 50.e-6\");",
			 geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"gclose all\");",geantMk));
	ProcessLine(Form("((St_geant_Maker *) %p)->Do(\"physi\");",geantMk));
      }
    }
  }
  return iok;
}
//_____________________________________________________________________
/// Skip events by selecting according maker
Int_t StBFChain::Skip(int nskip)
{
  StMaker *geant = 0;
  StIOMaker      *inpMk = 0;
  if (nskip<=0) return 0;
  if (GetOption("fzin") || GetOption("ntin") )  {
    geant = GetMaker("geant");
    if (geant && !geant->InheritsFrom("St_geant_Maker")) geant = 0;
    if (geant && !geant->IsActive()) 	               	 geant = 0;
    if (geant) {
      gMessMgr->QAInfo() << "StBFChain::Skip -> St_geant_Make::Skip(" << nskip << ") Events" << endm;
      ProcessLine(Form("((St_geant_Maker *) %p)->Skip(%i);",geant,nskip));
      return 0;
    }
  }
  if (GetOption("VMC"))  {
    geant = GetMaker("geant");
    if (geant && !geant->InheritsFrom("StVMCMaker")) geant = 0;
    if (geant && !geant->IsActive()) 	               	 geant = 0;
    if (geant) {
      gMessMgr->QAInfo() << "StBFChain::Skip -> StVMCMake::Skip(" << nskip << ") Events" << endm;
      ProcessLine(Form("((StVMCMaker *) %p)->Skip(%i);",geant,nskip));
      return 0;
    }
  }
  inpMk = (StIOMaker *) GetMaker("inputStream");
  if (inpMk && !inpMk->InheritsFrom("StIOMaker")) 	inpMk = 0;
  if (inpMk) {
      gMessMgr->QAInfo() << "StBFChain::Skip -> StIOMaker::Skip(" << nskip << ") Events" << endm;
    inpMk->Skip(nskip); return 0;}

  Error("Skip","No maker to Skip");
  return kStErr;
}

//_____________________________________________________________________
/// Really the destructor (close files, delete pointers etc ...)
Int_t StBFChain::Finish()
{
  if (!fBFC) return kStOK;
  int ians = StMaker::Finish();
  SafeDelete(fchainOpt);
  fBFC = 0;
  if (fTFile) {fTFile->Write(); fTFile->Flush(); fTFile->Close(); SafeDelete (fTFile);}
  return ians;
}


//_____________________________________________________________________
Int_t StBFChain::AddAB (const Char_t *mkname,const StMaker *maker,const Int_t Opt) {
  if (! maker || strlen(mkname) == 0) return kStErr;
  StMaker *parent = maker->GetParentMaker();
  if (parent) {
    TList   *list    = parent->GetMakeList();
    list->Remove((StMaker *)maker);
  }
  StMaker *mk      = GetMaker(mkname);      if (!mk)     return kStErr;
  parent  = mk->GetParentMaker();  if (!parent) return kStErr;
  TList   *list    = parent->GetMakeList(); if (!list)   return kStErr;
  if (Opt > 0) list->AddAfter (mk,(StMaker*)maker);
  else         list->AddBefore(mk,(StMaker*)maker);
  return kStOk;
}

//_____________________________________________________________________
Int_t StBFChain::ParseString (const TString &tChain, TObjArray &Opt, Bool_t Sort) {
  Opt.Clear();
  TObjArray *obj = tChain.Tokenize("[^ ;,]+");
  Int_t nParsed = obj->GetSize();
  Int_t k, N = 0;
  if (fgStChain && fgStChain->Debug() > 2) {
    cout << "StBFChain::ParseString " << tChain.Data() << endl;
    for (k = 0; k < nParsed; k++) {
      if (obj->At(k)) {
	cout << k << "\t" << ((TObjString *) obj->At(k))->GetName() << endl;
      }
    }
  }
  for (k = 0; k < nParsed; k++) {if (obj->At(k)) {if (k != N) obj->AddAt(obj->At(k),N); N++;}}
  nParsed = N;
  // sort options
  StBFChain *chain = (StBFChain *) StMaker::GetChain();
  if (chain && Sort) {// sort options
    TArrayI idT(nParsed); Int_t *idx = idT.GetArray();
    TArrayI kdT(nParsed); Int_t *kdx = kdT.GetArray();
    for (k = 0; k < nParsed; k++) {
      TString string = ((TObjString *) obj->At(k))->GetString();
      kdx[k] = TMath::Abs(chain->kOpt(string,kFALSE));
    }
    TMath::Sort(nParsed,kdx,idx,0);
    TString sChain;
    for (k = 0; k < nParsed; k++) {
      Opt.AddAtAndExpand(obj->At(idx[k]),k);
      if (k == 0) sChain = ((TObjString *)Opt[k])->GetString();
      else {sChain += ","; sChain += ((TObjString *)Opt[k])->GetString();}
    }
    if (N > 1 && chain->Debug() > 2) {
      gMessMgr->QAInfo() << "Requested chain is :\t" << tChain.Data() << endm;
      gMessMgr->QAInfo() << "Sorted    chain is :\t" << sChain.Data() << endm;
    }
  } else for (k = 0; k < nParsed; k++) Opt.AddAtAndExpand(obj->At(k),k);
  obj->SetOwner(kFALSE);
  delete obj;
  return nParsed;
}

//_____________________________________________________________________
/// Check option if defined (Char_t argument interface)
Int_t StBFChain::kOpt (const Char_t *tag, Bool_t Check) const {
  TString Tag(tag);
  Int_t kO = kOpt(&Tag, Check);
  return kO;
}
//_____________________________________________________________________
/// Check option if defined.
/*!
  This method checks if the options are valid by %comparing them
  to the list of declared options. This is called for each option
  passed as argument. The real sorting of all options is done in
  SetFlags().
*/
Int_t StBFChain::kOpt (const TString *tag, Bool_t Check) const {
  TString Tag = *tag;
  Tag.ToLower();
  TString opt, nopt;
  for (Int_t i = 1; i< fNoChainOptions; i++) {
    opt = TString(fBFC[i].Key); //check nick name
    opt.ToLower();
    nopt = TString("-");
    nopt += opt;
    if       (Tag ==  opt) {return  i;}
    else {if (Tag == nopt) {return -i;}}
    opt   = fBFC[i].Maker; //check full maker name2
    nopt  = "-";
    nopt += opt;
    if       (Tag ==  opt) {return  i;}
    else {if (Tag == nopt) {return -i;}}
  }
  if ( (strncmp( Tag.Data() ,"dbv",3) ||
	strncmp( Tag.Data() ,"sdt",3)   ) &&
       strlen(Tag.Data()) == 11 ) return 0;
  if (Check) {
    gMessMgr->Error() << "Option " << Tag.Data() << " has not been recognized" << endm;
    abort(); //assert(1);
  }
  return 0;
}

//_____________________________________________________________________
/// Enable/disable valid command line options
void StBFChain::SetOption(const Int_t k, const Char_t *chain) {
  // set all off
  if (k > 0 && !fBFC[k].Flag) {
    //    printf ("SetOption: %s %i",fBFC[k].Key,k);
    if (strlen(fBFC[k].Opts) > 0) {
      TObjArray Opts;
      Int_t N =  ParseString(fBFC[k].Opts,Opts, kTRUE);
      if (Debug() > 2) gMessMgr->QAInfo() << "parse Opts :" << N << "\t" <<  fBFC[k].Opts << endm;
      TIter next(&Opts);
      TObjString *Opt;
      for (Int_t l = 0; l < N; l++) {
	Opt = (TObjString *) Opts[l];
	if (Debug() > 2) gMessMgr->QAInfo() << "\tto :" <<  Opt->GetName() << endm;
	if (Opt) {
	  SetOption(Opt->GetName(),fBFC[k].Key);
	}
      }
      Opts.Delete();
    }
    fBFC[k].Flag = kTRUE;
    gMessMgr->QAInfo() << Form(" Switch On  %20s by %s", fBFC[k].Key, chain) << endm;
  } else {
    if (k < 0 && fBFC[-k].Flag) {
      //      printf ("SetOption: %s %i",fBFC[-k].Key,k);
      fBFC[-k].Flag = kFALSE;
      gMessMgr->QAInfo() << Form(" Switch Off %20s by %s", fBFC[-k].Key, chain) << endm;
    }
  }
}

//_____________________________________________________________________
/// Returns chain-option state (on/off)
Bool_t StBFChain::GetOption(const Int_t k) const
{
  return (k>0 && k <fNoChainOptions) ? fBFC[k].Flag : kFALSE;
}

/// Returns the comment string associated to an option
/*!
 * Any option passed a bla=XX is reshaped as follow ...
 * - The SetFlags() function strip out the =XX part and replaces
 *   the comment by the value XX
 * - This GetOptionString() returns the comment part so makers
 *   can globally access the option string.
 *
 * <i>Note</i> : If the requested option is not part of the global BFC[]
 * array, the kOpt() method is going to scream at you but it will still
 * work. You can ask for that option to be added to the chain official
 * options later whenever your code debugging is done. In other words,
 * this method allows you to pass ANY options not officially declared
 * and use it as test/work-around to pass any parameters to your maker.
 *
 * However, if the parameters are to be used in production, we DO
 * request/require that they are declared as a valid option.
 *
 *
 */
Char_t *StBFChain::GetOptionString(const Char_t *Opt)
{
  int o = kOpt(Opt);
  if(!o) return NULL;
  else if(!GetOption(o)) return NULL;
  else return(fBFC[o].Comment);
}


//_____________________________________________________________________________
/// Scan all flags, check if they are correct, manipulate the comment if necessary
/*!
  This method checks if the options passed are correct and/or sorts out
  the extraneous information passed through the comment if applies. Two
  special flags exists, that is, dbv and sdt for database interraction ...
  - The <tt>dbv</tt> tag is used to setup the end-time for entries (time after
  which any database insertions will be ignored). It used to provide a
  mechanism by which we can run production with a stable set of calibration
  constant and still allow for development value insertion to get in.
  - The <tt>sdt</tt> tag is used to setup the database look-up time stamp
  that is, on which date to look at the database. This is usefull if we
  want to decouple Geant geometry and database calibration constants.
  This may also be used to get database values when you do not run over
  a raw data file.
  - The geometry options are now dynamic. This includes BOTH Y geometries
  and RY geometry options. They are defined now in StMaker as a static
  map.
*/
void StBFChain::SetFlags(const Char_t *Chain)
{
  TString tChain(Chain);
  Int_t mode = 1;
  // chain choise
  if (tChain.Contains("ittf",TString::kIgnoreCase)) mode = 2;
  Setup(mode);
  Int_t k=0;
  if (tChain == "") {
    gMessMgr->QAInfo() << "\tPossible Chain Options are:" << endm;
    for (k=0;k<fNoChainOptions;k++)
    gMessMgr->QAInfo()
      << Form(" %3d:[-]%-13s:%-12s:%-12s:%-12s :%s :%s :%s"
	      ,k,fBFC[k].Key,fBFC[k].Name,fBFC[k].Chain,fBFC[k].Opts,fBFC[k].Maker,fBFC[k].Libs,fBFC[k].Comment)
      << endm;

    return;
  }
  TString STAR_VERSION("$STAR_VERSION");
  gSystem->ExpandPathName(STAR_VERSION);
  gMessMgr->QAInfo() << "=============================================="  << endm;
  gMessMgr->QAInfo() << "============= You are in " << STAR_VERSION.Data() << " ===============" << endm;
  gMessMgr->QAInfo() << "Requested chain " << GetName() << " is :\t" << tChain.Data() << endm;
  TObjArray Opts;
  Int_t nParsed = ParseString(tChain,Opts,kTRUE);
  for (Int_t l = 0; l < nParsed; l++) {
    TString Tag = ((TObjString *)Opts[l])->GetString();
    Int_t kgo;
    Int_t in = Tag.Index("=");
    if (in > 0) {// string with  "="
      TString subTag(Tag.Data(),in);
      subTag.ToLower(); //printf ("Chain %s\n",tChain.Data());
      kgo = kOpt(subTag.Data());
      if (kgo > 0) {
	memset(fBFC[kgo].Comment,0,200); // be careful size of Comment
	SetOption(kgo,fBFC[k].Key);
	TString Comment(Tag.Data()+in+1,Tag.Capacity()-in-1);
	strcpy (fBFC[kgo].Comment, Comment.Data());
	gMessMgr->QAInfo() << Form(" Set        %s = %s", fBFC[kgo].Key,fBFC[kgo].Comment) << endm;
      }
    } else {
      Tag.ToLower();
      // printf ("Chain %s\n",tChain.Data());
      kgo = kOpt(Tag.Data(),kFALSE);
      if (kgo != 0){
	SetOption(kgo);
      } else {
	// it is 0 i.e. was not recognized. Check if it is a dbvXXXXXXXX
	// with a 8 digit long time stamp. We can do all of that in the
	// SetDbOptions() only (removing the fBFC[i].Flag check) but the
	// goal here is to avoid user's histeria by displaying extra
	// messages NOW !!! Debug: dbv20040917
	if( ! strncmp( Tag.Data() ,"dbv",3) && strlen(Tag.Data()) == 11){
	  (void) sscanf(Tag.Data(),"dbv%d",&FDate);
	  cout << " ... but still will be considered as a dynamic timestamp (MaxEntryTime) "
	       << FDate  << endl;
	} else if( ! strncmp( Tag.Data() ,"sdt",3) && strlen(Tag.Data()) == 11){
	  (void) sscanf(Tag.Data(),"sdt%d",&FDateS);
	  cout << " ... but still will be considered as a dynamic timestamp (DateTime)     "
	       << FDateS << endl;
	} else { // Check for predefined db time stamps ?
	  const DbAlias_t *DbAlias = GetDbAliases();
	  Int_t found = 0;
	  for (Int_t i = 0; DbAlias[i].tag; i++) {
	    Bfc_st row = {"","","","db,detDb","","","",kTRUE};
	    if (! Tag.CompareTo(DbAlias[i].tag,TString::kIgnoreCase)) {
	      found = i;
	      memcpy (&row.Key, Tag.Data(), strlen(Tag.Data()));
	      fchainOpt->AddAt(&row);
	      fNoChainOptions = fchainOpt->GetNRows();
	      fBFC = fchainOpt->GetTable();
	      break;
	    }
	    TString dbTag("r");
	    dbTag += DbAlias[i].tag;
	    if (! Tag.CompareTo(dbTag,TString::kIgnoreCase)) {
	      found = i;
	      memcpy (&row.Key, Tag.Data(), strlen(Tag.Data()));
	      fchainOpt->AddAt(&row);
	      fNoChainOptions = fchainOpt->GetNRows();
	      fBFC = fchainOpt->GetTable();
	      break;
	    }
	  }
	  kgo = kOpt(Tag.Data(),kFALSE);
	  if (kgo != 0){
	    SetOption(kgo);
	  } else {
	    // Check that option can be library name or / and Maker
	    static Char_t *path = ".:.$STAR_HOST_SYS/lib::.$STAR_HOST_SYS/LIB:$STAR/.$STAR_HOST_SYS/lib:$STAR/.$STAR_HOST_SYS/LIB";
	    TString File = Tag; File += ".so";
	    Char_t *file = gSystem->Which(path,File.Data(),kReadPermission);
	    if (file) {
	      TString Maker("");
	      Bfc_st row = {"","","","","","","",kTRUE};
	      memcpy (&row.Key, Tag.Data(), strlen(Tag.Data()));
	      if (Tag.Contains("Maker")) memcpy (&row.Maker, Tag.Data(), strlen(Tag.Data()));
	      memcpy (&row.Libs, Tag.Data(), strlen(Tag.Data()));
	      fchainOpt->AddAt(&row);
	      fNoChainOptions = fchainOpt->GetNRows();
	      fBFC = fchainOpt->GetTable();
	    }
	    kgo = kOpt(Tag.Data(),kFALSE);
	    if (kgo != 0) {
	      SetOption(kgo);
	    } else {
	      cout << " Invalid Option " << Tag.Data() << ". !! ABORT !! " << endl;
	      abort(); //assert(1);
	      return;
	    }
	  }
	}
      }
    }
  }
  Opts.Delete();
  if (!GetOption("NoDefault")) {
    // Check flags consistency
    if (gClassTable->GetID("TGiant3") >= 0) { // root4star
      SetOption("-VMC","Default,TGiant3");
      SetOption("-VMCPassive","Default,TGiant3");
      SetOption("-VMCAppl","Default,TGiant3");
      SetOption("-RootVMC","Default,TGiant3");
      if (!( GetOption("fzin") || GetOption("ntin") || GetOption("gstar"))) {// Not Active geant
	SetOption("geant","Default,-fzin,-ntin,-gstar,TGiant3");
	SetOption("MagF","Default,-fzin,-ntin,-gstar,TGiant3");
      }
    } else {                                  // root
      if (GetOption("fzin")) {
	gMessMgr->Error() << "Option fzin cannot be used in root.exe. Use root4star" << endm;
	abort();
      }
      if (GetOption("ntin")) {
	gMessMgr->Error() << "Option ntin cannot be used in root.exe. Use root4star" << endm;
	abort();
      }
      if (GetOption("gstar")) {
	SetOption("VMC","Default,-TGiant3,gstar");
	SetOption("-gstar","Default,-TGiant3");
      }
      SetOption("-geant","Default,-TGiant3");
      SetOption("-geantL","Default,-TGiant3");
      SetOption("-geometry","Default,-TGiant3");
      SetOption("-geomNoField","Default,-TGiant3");
      if (! (GetOption("VMC") || GetOption("VMCPassive"))) {
	SetOption("VMCPassive","Default,-TGiant3");
      }
    }
  }
  if (!GetOption("Eval") && GetOption("AllEvent"))  SetOption("Eval","-Eval,AllEvent");
  // Print set values
  St_Bfc *Bfc = new St_Bfc("BFChain",fNoChainOptions);
  AddRunco(Bfc);
  for (k = 1; k<fNoChainOptions;k++) {
    if (GetOption(k)) {
      gMessMgr->QAInfo() << Form("================== %4d %15s\tis ON \t: %s",
				 k, (char *) fBFC[k].Key, (char *) fBFC[k].Comment) << endm;
      Bfc->AddAt(&fBFC[k]);
    }
  }
  //  gSystem->Exit(1);
}
//_____________________________________________________________________
void StBFChain::Set_IO_Files (const Char_t *infile, const Char_t *outfile){
  TString gc("");
  if (infile) {
    if (strlen(infile) > 2) {
      gc = TString(infile,3);
      gc.ToLower();
    }
    if (gc == "gc:") {SetGC(infile+3); goto SetOut;}
  }
  SetInputFile(infile);
 SetOut:
  SetOutputFile(outfile);
}
//_____________________________________________________________________
void StBFChain::SetGC (const Char_t *queue){
  TString Queue(queue);
  gMessMgr->QAInfo() << "Requested GC queue is :\t" << Queue.Data() << endm;
  TObjArray Opts;
  ParseString(Queue,Opts);
  TIter next(&Opts);
  TObjString *Opt;
  static TString ARGV[40];
  Int_t Argc = -1;
  while ((Opt = (TObjString *) next())) {
    TString string = Opt->GetString();
    const Char_t *argv = string.Data();
    if (argv[0] == '-') {
      switch (argv[1]) {
      case 'o':
      case 'i':
      case 'c':
      case 'q':
      case 's':
      case 'n':
      case 'm':
      case 't':
      case '-': // now do --options, they get added to Config
        ARGV[++Argc] = string.Data();
        Argc++;
	break;
      default :
	gMessMgr->QAInfo() << "Unrecognized option :\t" << string << endm;
	break;
      }
    }
    else if (Argc > 0) {ARGV[Argc] += " "; ARGV[Argc] += string;}
  }
  Opts.Delete();
  fSetFiles = (StFileI *)StChallenger::Challenge();
  fSetFiles->SetDebug();
  Argc++;
  Char_t **Argv = new Char_t* [Argc];
  for (int i=0;i<Argc;i++)  {Argv[i] = (Char_t *) ARGV[i].Data();}
  fSetFiles->Init(Argc,(const Char_t **) Argv);
}
//_____________________________________________________________________
void StBFChain::SetInputFile (const Char_t *infile){
  // define input file
  if (infile) fInFile = infile;
  if (fInFile != "") {
    if (!GetOption("fzin") && !GetOption("ntin")) {
      fSetFiles= new StFile();
      TObjArray Files;
      ParseString(fInFile,Files);
      TIter next(&Files);
      TObjString *File;
      while ((File = (TObjString *) next())) {
	TString string = File->GetString();
	if (!strstr(string.Data(),"*") && string[0]!='@' &&
	    gSystem->AccessPathName(string.Data())) {// file does not exist
	  gMessMgr->Error() << "StBFChain::SetInputFile  *** NO FILE: " << string.Data() << ", exit!" << endm;
	  gSystem->Exit(1);
	}
	else fSetFiles->AddFile(File->String().Data());
      }
      Files.Delete();
    }
  }
  if (fInFile != "") gMessMgr->QAInfo() << "Input file name = " << fInFile.Data() << endm;
}


//_____________________________________________________________________
/// Takes care of output file name (extension)
void StBFChain::SetOutputFile (const Char_t *outfile){
  if (outfile)               fFileOut = outfile;
  else {
    if (GetOption("gstar"))  fFileOut = "gtrack.root";
    if (GetOption("VMC"))    fFileOut = "VMC.root";
    if (fInFile != "") {
      if (GetOption("fzin") || GetOption("ntin")) {
	TObjArray words;
	ParseString(fInFile,words);
	TIter nextL(&words);
	TObjString *word = 0;
	while ((word = (TObjString *) nextL())) {
	  if (word->GetString().Contains(".fz") ||
	      word->GetString().Contains(".nt")) {
	    fFileOut = gSystem->BaseName(word->GetName());
	    break;
	  }
	}
      }
      else fFileOut = gSystem->BaseName(fInFile.Data());
      if (  fFileOut != "") {
	fFileOut.ReplaceAll("*","");
	fFileOut.ReplaceAll("@","");
	fFileOut.ReplaceAll("..",".");
	fFileOut.ReplaceAll(".daq","");
	fFileOut.ReplaceAll(".fzd","");
	fFileOut.ReplaceAll(".fz","");
	fFileOut.ReplaceAll(".nt","");
	fFileOut.ReplaceAll(".root","");
	fFileOut.ReplaceAll(".list","");
	fFileOut.ReplaceAll(".lis","");
	fFileOut.Strip();
	fFileOut.Append(".root");
      }
    }
  }
  if (fFileOut != "")  gMessMgr->QAInfo() << "Output root file name " <<  fFileOut.Data() << endm;
  if (!fTFile) {
    if (GetOption("tags")  && fFileOut != "" ||
	GetOption("lana") ||  GetOption("Laser")) {
      TString TagsName = fFileOut;
      if(GetOption("LaserCal")){
	TagsName.ReplaceAll(".root",".laser.root");
      } else {
	TagsName.ReplaceAll(".root",".tags.root");
      }
      fTFile = new TFile(TagsName.Data(),"RECREATE");
    }
  }
  //    gSystem->Exit(1);
}



//_____________________________________________________________________
/// Handles all geant options
/*!
  This method sets the Geant options that is the Geometry loading
  part. Depends on St_geant_Maker instantiated in the Instantiate()
  method.
  Please, change SetDbOptions()
*/
void StBFChain::SetGeantOptions(){
  StMaker *geantMk = GetMaker("geant");
  if (geantMk && !geantMk->InheritsFrom("St_geant_Maker")) geantMk = 0;
  if (geantMk) {
    SetInput("geant",".make/geant/.data");
    TString GeomVersion("");
    if (!GetOption("fzin") || GetOption("ForceGeometry")) {
      GeomVersion = "y2004x";
      const DbAlias_t *DbAlias = GetDbAliases();
      Int_t found = 0;
      for (Int_t i = 0; DbAlias[i].tag; i++) {
	TString r("r");
	r +=  DbAlias[i].tag;
	if ( !GetOption(DbAlias[i].tag,kFALSE) && !GetOption(r,kFALSE)) continue;
	GeomVersion = DbAlias[i].geometry;
	found = i;
	break;
      }
      if (! found) gMessMgr->QAInfo() << "StBFChain::SetGeantOptions() Chain has not found geometry tag. Use " << GeomVersion << endm;
      TString GeometryOpt("detp geometry ");
      GeometryOpt += GeomVersion;
      ProcessLine(Form("((St_geant_Maker *) %p)->LoadGeometry(\"%s\");",geantMk,GeometryOpt.Data()));
    }
    if ((GetOption("fzin") || GetOption("ntin")) && fInFile != "")
      ProcessLine(Form("((St_geant_Maker *) %p)->SetInputFile(\"%s\")",geantMk,fInFile.Data()));
  } // geantMk
  if (GetOption("Simu")) {
    StEvtHddr *fEvtHddr = (StEvtHddr*)GetDataSet("EvtHddr");
    if (!fEvtHddr) {
      fEvtHddr = new StEvtHddr(m_ConstSet);
      SetOutput(fEvtHddr);	              //Declare this "EvtHddr" for output
    }
    if (fEvtHddr->GetRunNumber() < 0 || fEvtHddr->GetRunNumber() >= 1000000) {
      fEvtHddr->SetRunNumber(1); // to have run positive and < 1000000 (to avoid mess with RunLog)
    }
  }
}


//_____________________________________________________________________
/// Treats the DbV options used for database timestamp.
/*!
  Re-scan all options and search for dbv options. This method also sorts
  out the string-based database timestamp for reconstruction. Those have
  to be in phase with the geant geometry (see SetGeantOptions()) if
  simulation is being reconstructed.

  The order matters since a later option would overwrite an earlier one.
  The mechanism introduced for a dynamic (i.e. not pre-defined) timestamp is that
  it will be used ONLY if there are no other timestamp options.
  <b>Be aware of this precedence ...</b>

*/
void StBFChain::SetDbOptions(){
  Int_t i;
  Int_t Idate=0,Itime=0;
  for (i = 1; i < fNoChainOptions; i++) {
    if (fBFC[i].Flag && !strncmp(fBFC[i].Key ,"DbV",3)){
      gMessMgr->QAInfo() << "StBFChain::SetDbOptions  Found time-stamp " << fBFC[i].Key << " [" << fBFC[i].Comment << "]" << endm;
      (void) sscanf(fBFC[i].Comment,"%d/%d",&Idate,&Itime);
    }
  }

  if( ! Idate && FDate){
      gMessMgr->QAInfo() << "StBFChain::SetDbOptions  witching to user chosen dynamic time-stamp (MaxEntry) "
			 << FDate << " " << FTime << endm;
      gMessMgr->QAInfo() << "Chain may crash if time-stamp is not validated by db interface" << endm;

    Idate = FDate;
    Itime = FTime;
  }

  StMakerIter nextMaker(this);
  StMaker *maker;
  while ((maker = nextMaker.NextMaker())) {
    if (!strcmp(maker->ClassName(),"St_db_Maker")) {
      St_db_Maker *db = (St_db_Maker *) maker;

      // Startup date over-write
      if (FDateS){
	gMessMgr->QAInfo() << "StBFChain::SetDbOptions Switching to user chosen dynamic time-stamp (Start)"
			   << FDateS << " " << FTimeS << endm;
	gMessMgr->QAInfo() << "Chain may crash if time-stamp is not validated by db interface" << endm;

	db->SetDateTime(FDateS,FTimeS);
      } else {
	const DbAlias_t *DbAlias = GetDbAliases();
	Int_t found = 0;
	for (Int_t i = 0; DbAlias[i].tag; i++) {
	  if (GetOption(DbAlias[i].tag,kFALSE)) {
	    db->SetDateTime(DbAlias[i].tag);
	    found = i;
	    break;
	  }
	}
	if (! found) gMessMgr->QAInfo() << "StBFChain::SetDbOptions() Chain has not set a time-stamp" << endm;
      }
      // Show date settings
      gMessMgr->QAInfo() << db->GetName()
			 << " Maker set time = "
			 << db->GetDateTime().GetDate() << "."
			 << db->GetDateTime().GetTime() << endm;
      if (GetOption("VMC") && m_EvtHddr) {
	gMessMgr->QAInfo() << GetName() << " Chain set time from  " << db->GetName() << endm;
	m_EvtHddr->SetDateTime(db->GetDateTime());
      }
      // MaxEntry over-write
      if (Idate) {
	db->SetMaxEntryTime(Idate,Itime);
	gMessMgr->Info() << "\tSet DataBase max entry time " << Idate << "/" << Itime
			 << " for St_db_Maker(\"" << db->GetName() <<"\")" << endm;
      }
    } // check if maker is St_db_Maker
  }   // loop over makers
  if (!GetOption("fzin")) {
    struct Field_t {
      Char_t *name;
      Float_t scale;
    };
    Field_t FieldOptions[5] = {
      {"FullMagFNegative", -1.0},
      {"FullMagFNegative",  1.0},
      {"HalfMagFNegative", -0.5},
      {"HalfMagFPositive",  0.5},
      {"ZeroMagF",          0.0}
    };
    Int_t k = -1;
    if         (GetOption("FieldON")) {
      if       (GetOption("ReverseField"))  k = 0;
      else                                  k = 1;
    } else if (GetOption("HalfField")) {
      if      (GetOption("ReverseField"))   k = 2;
      else                                  k = 3;
    } else if (GetOption("FieldOff"))       k = 4;
    if (k >= 0) {
      SetFlavor(FieldOptions[k].name,        "MagFactor");
      gMessMgr->QAInfo() << "StBFChain::SetDbOptions SetFlavor(\"" << FieldOptions[k].name
			 << "\",\"MagFactor\")" << endm;
      if ( gClassTable->GetID("StarMagField") >= 0) {
	TString cmd =
	  Form("if (!StarMagField::Instance()) new StarMagField( StarMagField::kMapped, %f, kTRUE);",
	       FieldOptions[k].scale);
	ProcessLine(cmd);
      }
    }
  }
}
//_____________________________________________________________________
/// Creates output-tree branches
void StBFChain::SetTreeOptions()
{
  StTreeMaker *treeMk = (StTreeMaker *) GetMaker("outputStream");
  if (!treeMk) return;
  treeMk->SetBranch("histBranch");
  if (GetOption("dstOut"))      {
    treeMk->IntoBranch("dstBranch","dst");
    if (GetOption("HitsBranch")) {
      treeMk->SetBranch("dstHitsBranch");
      treeMk->IntoBranch("dstHitsBranch","dst/.data/Hits");
    }
    else treeMk->IntoBranch("dstBranch","dst/.data/Hits");
    treeMk->IntoBranch("dstBranch","dst/.data/dst");
    treeMk->SetBranch("runcoBranch");
  }
  if (GetOption("Event") && GetOption("EvOut")){
    cout << "Will Write StEvent out, treeMk->GetFile() = "  << treeMk->GetFile() << endl;
    treeMk->IntoBranch("eventBranch","StEvent");
  }
  if (GetOption("McEvent") && GetOption("McEvOut")){
    cout << "Will Write StMcEvent out, treeMk->GetFile() = "  << treeMk->GetFile() << endl;
    treeMk->IntoBranch("McEventBranch","StMcEvent");
  }
  if (GetOption("GeantOut")) treeMk->IntoBranch("geantBranch","geant");
  if (GetOption("AllEvent")) {
    if (GetOption("fzin") || GetOption("ntin") || GetOption("gstar") || GetOption("VMC")  ) {
      treeMk->IntoBranch("geantBranch","geant");
      treeMk->IntoBranch("geantBranch","geant/.data/particle");
      treeMk->IntoBranch("geantBranch","geant/.data/g2t_rch_hit");
    }
    if (GetOption("fss"))    treeMk->IntoBranch("ftpc_rawBranch","ftpc_raw/.data");
    if (GetOption("tpc_daq") || GetOption("TrsMini"))
      treeMk->IntoBranch("tpc_rawBranch","tpc_raw/.data");
    if (GetOption("ems"))    treeMk->IntoBranch("emc_rawBranch","emc_raw/.data");
    if (GetOption("tcl"))    treeMk->IntoBranch("tpc_hitsBranch","tpc_hits/.data");
    if (GetOption("fcf"))    treeMk->IntoBranch("tpc_hitsBranch","tpc_hits/.data");
    if (GetOption("tpt"))    treeMk->IntoBranch("tpc_tracksBranch","tpc_tracks/.data");
    if (GetOption("srs"))    treeMk->IntoBranch("svt_hitsBranch","svt_hits/.data");
    if (GetOption("stk"))    treeMk->IntoBranch("svt_tracksBranch","svt_tracks/.data");
    if (GetOption("trg"))    treeMk->IntoBranch("trgBranch","ctf mwc trg");
    if (GetOption("global")) treeMk->IntoBranch("globalBranch","global/.data");
  }
}
//________________________________________________________________________________
Long_t  StBFChain::ProcessLine(const char *line) {
  if (! line ||  !strlen(line)) return -1;
  if (Debug()) cout << "StBFChain::ProcessLine " << line << endl;
  TInterpreter::EErrorCode error = TInterpreter::kNoError;
  Long_t  res = gInterpreter->ProcessLine(line, &error);
  if (error != TInterpreter::kNoError) {
    gMessMgr->Error() << "StBFChain::ProcessLine command:" << line << " has failed. Quit job." << endm;
    gSystem->Exit(1);
  }
  return res;
}
