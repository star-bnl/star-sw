#!/usr/bin/env perl
Import qw ( env CWD INCLUDE LIB BIN BUILD OBJ);
( my $build = $OBJ ) =~ s/\#//g;
$build =~ s/\\/\//g;                                    # print "OBJ = $OBJ build = $build\n";
# print "MAIN = $MAIN\n";
my $DirPath = DirPath '.';                              # print "DirPath = $DirPath\n";
( my $obj_dir = $DirPath ) =~ s/\\/\//g;                # print "obj_dir = $obj_dir\n";
( my $Dir = $obj_dir ) =~ s/$build\///g;                # print "Dir = $Dir\n";
my $ObjDir       = "#" . $obj_dir;                      # print "ObjDir = $ObjDir\n";
my $STAR_SYS     = $env->{ENV}->{STAR_SYS};
my $STAR_VERSION = $env->{ENV}->{STAR_VERSION};         # print "#####  $STAR_VER\n";
my $AFS_RHIC     = $env->{ENV}->{AFS_RHIC};

my $ROOT_FEATURES = `root-config --features`;

@Repo   = Repository_List unless $param::noRepository;#   print "Repositories = |@Repo|\n";



print "+-+-+- STAR=".$env->{ENV}->{STAR}."\n"  if $param::debug;
print "+-+-+- cwd=".$CWD."\n"                  if $param::debug;
my $IsDotDev = 0;
if ($env->{ENV}->{STAR} =~ /\.(dev|DEV)/) {$IsDotDev = 1;}
my $IsRepo = (stat($env->{ENV}->{STAR}."/."))[1] == (stat($CWD."/."))[1];

if ($param::debug) {
    if ( $IsRepo && ! $IsDotDev ){
	print "... REPOSITORY compilation  ...\n";
    } else {
	print "... USER area compilation   ...\n";
    }
}
my $SO_PKG  = "";
my $SO_PKG_lib = "";
my $SO_PKG_PLAIN = "";
my $SO_PKGT = "";
my $SO_MAP  = "";
my $SO_MAPT = "";
my $pkg;
my $PKG;
my $OnlinePackage=0;
my @LinkDefs = ();
my @LinkDefsT = (); # for tables if any
my @PlainObj = ();

if ( ($Dir =~ m/StRoot.*Pool\//   && $Dir !~ /StRoot.*Pool\/St/)   ||
     ($Dir =~ m/StRoot.*Client\// && $Dir !~ /StRoot.*Client\/St/) ||
     ($Dir =~ m/StarVMC\/minicern/  || $Dir =~ m/StarGenerator/ )
     ) {
    # Added 2003. In Construct, the logic is such
    # that the Pool directories have their sub-directories
    # set as targets (n sub-dir => n libraries). That's
    # fine ... apart from name clash we try to resolve
    # here.
    $pkg = $Dir;
    $pkg =~ s/StRoot\///;

    if ( $Dir =~ m/StarGenerator/ ){
	if ( $Dir =~ m/(StarGenerator)(\/)([A-Z]+$)/ ){
	    # camel case
	    $pkg =  $1.substr($3,0,1).lc(substr($3,1,length($3)));
	} else {
	    # normal case, use subdir name
	    $pkg =~ s/.*StarGenerator\///;
	}
	#print "\t[".File::Basename::basename($Dir)."] changed to $pkg\n";
    } else {
	$pkg =~ s/Pool\//Pool/      if ($pkg =~ m/Pool/  );
	$pkg =~ s/Client\//Client/  if ($pkg =~ m/Client/);
	$pkg = "StarMiniCern"       if ($pkg =~ m/minicern/);
	print "\t[".File::Basename::basename($Dir)."] (possible name clash) changed to $pkg\n";
    }
    $PKG = $pkg;

} else {
    $pkg = File::Basename::basename($Dir);               # print "Run cons in $Dir for $PKG\n";
    $PKG = $pkg;
    $OnlinePackage=true if $Dir =~ /^OnlTools/;# and $pkg ne "OnlinePlots";
}

$env1 = $env->clone('Package'  => $pkg);
my $DEBUG   = $env1->{DEBUG};
my $CXXFLAGS= $env1->{CXXFLAGS};
my $CFLAGS  = $env1->{CFLAGS};
my $FC      = $env1->{FC};
my $CC      = $env1->{CC};
my $FFLAGS  = $env1->{FFLAGS};
my $FCPATH  = $env1->{FCPATH};
my $FEXTEND = $env1->{FEXTEND};
my $FPPFLAGS= $env1->{FPPFLAGS};
my $FCCOM   = $env1->{FCCOM};
my $LIBS    = $env1->{LIBS};
my $SOFLAGS = $env1->{SOFLAGS};
my $LIBPATH = $env1->{LIBPATH};
my $STIC    = $env1->{STIC};
my $EXTRA_CPPFLAGS = $env1->{EXTRA_CPPFLAGS};
my $CPPFLAGS = $env1->{CPPFLAGS};

my $ROOTCINT_CPPFLAGS = "";
my @idlL    = script::find_idl($Dir); # print "find_idlL: ======== @idlL ======\n";
print "In Dir = $Dir idlL = @idlL\n" if $param::debug;
foreach my $Rep(@Repo) {
  my $RepDir = $Rep . "/" . $Dir;
  print "RepDir = $RepDir\n" if $param::debug;
  if ( -d $RepDir ) {
    my @idlR = script::find_idl($RepDir); # print "find_idlL: ======== @idlR ======\n";
    foreach my $i(@idlR) { push @idlL, $i; }
  }
}
@idlL = script::sortu(@idlL);
                                          print "find in $Dir ========\n" if $param::debug;
my @idlML    = script::find_idlM($Dir);   print "find_idl in $Dir ======== @idlML ======\n" if $param::debug;
my @srcL     = script::find_sources($Dir);print "find_sources in in $Dir ======== @srcL ======\n" if $param::debug;
my @h_filesL = script::find_hfiles($Dir); print "find_hfiles in $Dir ======== @h_filesL ======\n" if $param::debug;
my @uiQT     = script::find_ui($Dir);     print "find_ui in $Dir ======== @uiQT ======\n" if $param::debug;
my @xpmQT    = script::find_xpm($Dir);    print "find_xpm in $Dir ======== @xpmQT ======\n" if $param::debug;
my @qrcQT    = script::find_qrc($Dir);    print "find_qrc in $Dir ======== @qrcQT ======\n" if $param::debug;


print "idlL = @idlL\n"   if $param::debug;
# print "Geom = @xmlGeo\n";

my (@src, @h_files, @idlM);
my $CPPPATH = $env1->{CPPPATH};

if ($pkg eq "RTS") {
  if ($STAR_SYS =~ /^x86_darwin/) {}
  else {
    $CPPFLAGS .= ' -D_LARGEFILE64_SOURCE';
  }
    $CPPFLAGS .= ' -DNEW_DAQ_READER -DRTS_PROJECT_STAR -DTPXREADER '
	      .  '-DRTS_LITTLE_ENDIAN -DEVP_VERSION="\"EVP_VERSION=2.0\""';
    $CPPFLAGS =~ s/-D__ROOT__//;# print " ------------  CPPFLAGS ==== " .  $CPPFLAGS . "\n";
    $CFLAGS =~   s/-D__ROOT__//;# print " ------------  CFLAGS WHERE \"__ROOT__\" coming from ??? ==== " .  $CFLAGS . "\n";
    $CPPPATH = $main::PATH_SEPARATOR . "#StRoot/RTS/include"
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include"
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC"
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS"
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src"
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src/EVP_READER"
	    .  $main::PATH_SEPARATOR . $CPPPATH;
    my @src = ();
    #  print "srcL : @srcL\n";
    #  print "skip /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/\n";
    foreach my $s (@srcL) {
	next if $s =~ /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/;
	push @src, $s;
    }
    #  print "@src : @src\n";
    @srcL = @src;
    @src = ();
}

# Some directories will need extra includes for the RTS DAQ reader
my @DAQ_pkgs = qw(StDAQMaker StTofHitMaker StTpcHitMaker StEEmcPoolmuEztPanitkin
		  StBEMCPlots StBTofHitMaker StMtdHitMaker StPmdReadMaker
                  St_pp2pp_Maker StSstDaqMaker StFmsTriggerMaker StDaqLib
                  Stl3Util StTriggerUtilities
		);
#		  StTriggerUtilities
# But any *Raw* in StRoot/ would have this automatically done / handled
if ( $pkg =~ m/Raw/ ){
#    print "Found [$pkg] as Raw package\n";
    push(@DAQ_pkgs,$pkg);
}
my $DAQ_pkgs = join('|',@DAQ_pkgs);

my $RTS_READER_PATH =  $main::PATH_SEPARATOR . "#StRoot/RTS/src"
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/include"
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include";


#if (!$OnlinePackage) { $OnlinePackage=grep(m/$pkg/,@DAQ_pkgs); }
if ($OnlinePackage) {
  $CPPPATH = $main::PATH_SEPARATOR . "#OnlTools" . $RTS_READER_PATH . $main::PATH_SEPARATOR . $CPPPATH;
}
#print "==> $pkg => $DAQ_pkgs =======\n";
if ( $pkg =~ /$DAQ_pkgs/ )  {
  $CPPPATH = $main::PATH_SEPARATOR . "#" . $Dir . $RTS_READER_PATH . $main::PATH_SEPARATOR . $CPPPATH;
#  print "=========> $CPPPATH\n";
#. "/usr/include/libxml2" . $main::PATH_SEPARATOR
#ifdef ____MAC_____
#    if ($pkg =~ /StDaqLib/) {$CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir;}
#endif /* ____MAC_____ */
}
if ( $pkg eq "OnlinePlots") {
  $CPPPATH  .=  $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure"
            .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/HistogramGroups"
	    .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure/EEmcDb"
	    .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/QEvpClient"
	    .   $main::PATH_SEPARATOR . "#StRoot/RTS/EventTracker"
	    .   $main::PATH_SEPARATOR .  $CPPPATH;
  $CPPFLAGS .= " -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_NO_DEBUG ";
}
if ( $pkg eq "Jevp") {
    $CPPPATH  .=  $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpPlot"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpPresenter"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpServer"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpData"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpBuilders"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpViewer"
	      .   $main::PATH_SEPARATOR .  $CPPPATH;
    $CPPFLAGS .= " -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_NO_DEBUG ";
}

#$CPPFLAGS .= " -DNEW_DAQ_READER -D__NO_STRANGE_MUDST__  ";
$CPPFLAGS .= " -DNEW_DAQ_READER ";

if ($pkg eq "StDAQMaker") {
  $LIBS = "-lStDaqLib -lRTS";
}
my ($i, $obj);
my $LIBPKG = "";

my @g77pkgs = qw(geometry gen sim tls minicern geant3);
my $g77pkgs = join('|', @g77pkgs); print "FC = $FC pkg = $pkg DirPath = $DirPath\n" if $param::debug;


#+
# some compiler specific treatments below, global or conditional
#-
if( $FC eq 'pgf77'){
  if ($DirPath  =~ /$g77pkgs/ or $DirPath !~ /pams/) {
    $FC       = $env1->{G77}; print "set FC => $FC ==============================\n" if $param::debug;
    $FFLAGS   = $env1->{G77FLAGS};
    $FEXTEND  = $env1->{G77EXTEND};
  }
}
if ($FC =~ m/g77/ || $FC =~ m/gfortran/ ){
    if ( $DirPath =~ /pams/ and
	 ($DirPath !~ /$g77pkgs/ or $DirPath =~ /crs/ or $DirPath =~ /g2t/ or $DirPath =~ /hij/)){
	$FCCOM    = $env1->{FCviaAGETOFCOM};
    }
    # If fortran, grab the -lg2c or -lgfortran for linking
    if ( $DirPath =~ /StarVMC/ ){
	#print "\tAppending ".$env1->{FLIBS}." to LIBS=$LIBS\n";
	$LIBS .= " " . $env1->{FLIBS};
    }

    ## this is done not only for stand-alone library purpose but for backward
    ## compatibility of root4star linked with -lg2c rather than gfortran (hence
    ## libs would not work as symbol would fail to resolve)
    #if ( $FC eq 'gfortran' && (grep(/.F$/,@srcL) || grep(/.g$/,@srcL)) ){
    #	print "\tFound .F or .g in sources and adding [".
    #	    $env1->{FLIBS}."] to $pkg\n" ; # if $param::debug;
    #	$SOFLAGS .= " " . $env1->{FLIBS};
    #	#print "\tFinal SOFLAGS are $SOFLAGS\n";
    #}
}

#+
# Now we treat anything which is neither sim nor gen
# This will include all makers
#-
if ( $pkg !~ /^sim$/ && $pkg !~ /^gen$/ ) {
    print "\t--- Regular case treatment (not gen not sim) ---\n" if $param::debug;



    if ( $Dir =~ m/Table$/ ) { 
	if ( $ROOT_FEATURES =~ m/table/ ){ print "[ROOT has table support]\n";@srcL=();@h_filesL = (); }
	else                             { print "[ROOT has no table support, compile Table] \n"; }
    }


    # if user requested debug, print some info on what was found
    if ($param::debug) {
	$i = 0;
	foreach my $s(@idlML) { print "i=", $i++, " idlM = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@srcL) { print "i=", $i++, " src = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@h_filesL) { print "i=", $i++, " h_files = ", $s, "\n"; }
    }

    #+
    # Generate geometries first - this will be hit on any $Dir
    # xgeometry and StarGeometry may not be created however
    #-
    my($agM,$agE,$agX,$agH);
    my($trgt);

    if ( $Dir =~ m/(xg)(eometry)/ || $Dir =~ m/(StarG)(eometry)/){
	# Force dependency creation based on xml - each expected dependencies
	# have to be known a-priori by cons (the the order will be sorted out)
	# but we do not want to add the source (hence the derived .o) twice
	# and use fcheck for tetsing that
	my $RepDir = $Dir; $RepDir =~ s/$1/G/;
	my @xmlGeo   = script::find_xml($RepDir); # print "find_xml: ======== @xmlGeo ======\n";
	my @src=undef;
	my @inc=undef;
	my $fcheck;

	#print "\tBefore ".($#src)." ".($#inc)."\n";
	foreach $xml (@xmlGeo){
	    $agM  = $xml; $agM =~ s/\..*//; $agM =~ s/.*\///;
	    $trgt = "";
	    $hfl  = "";
	    if ( $Dir =~ m/xgeometry/ ){
		$trgt = "$OBJ/$Dir/$agM.age";
	    } else {
		# Compat contains redundant defs only needed for the age
		# .h also needed for Dictionary building
		if ( $xml !~ m/Compat/ ){
		    $trgt = "$OBJ/$Dir/$agM.cxx";
		    $hfl  = "$OBJ/$Dir/$agM.h";
		}
	    }
	    # push but only if not present - if present, cons will find
	    # them so there is no need for a predictive target rule
	    push(@src, $trgt ) if ($trgt ne "" );
	    push(@inc, $hfl)   if ($hfl  ne "" );
	}
	#print "\tAfter  ".($#src)." ".($#inc)."\n";

        if ($Dir =~ m#StarVMC/StarGeometry#) {
            my($cpppath) = $env->_subst($env->{CPPPATH});
            my($cscanner) = find scan::cpp($env->{_cwd}, $cpppath);
            $env->{_IFLAGS} = "%(" . $cscanner->iflags($env) . "%)";
            Command $env ["$OBJ/StarVMC/StarGeometry/StarGeo_Cint.cxx", "$OBJ/StarVMC/StarGeometry/StarGeo_Cint.h"],
                         ("$OBJ/StarVMC/StarGeometry/StarGeo.h", "#StarVMC/Geometry/StarGeoLinkDef.h"), qq(rootcint -f %> -c %_IFLAGS %1 %2);
            push(@srcL, "$OBJ/StarVMC/StarGeometry/StarGeo_Cint.cxx");
        }

	#print "-=-=-=-=- LALALA -=-=-=-\n";
	# 2018/01 issue after updating to AgML 2.0
	# TODO problem with optimization in xgeometry and StarGeometry
        #$DEBUG = "-O1 -g"; #VP
	#if ( $DEBUG =~ /-O/ ){   # there is an optimization used
	#    $DEBUG = "-O1 -g";   # switch to a lower optimization level
	#    $FDEBUG= "-O1 -g";
	#}
	$DEBUG = " -g ";

	# repack now and make sure only one exists
	push(@srcL,@src)      if ($#src != 0);
	push(@h_filesL,@inc)  if ($#inc != 0);

	#print "\t".join(",",@src)."\n";
	print "\tWill be adding ".($#src+1)." sources and ".($#inc+1)." inc to $Dir\n" if ($#src != 0 || $#inc !=0);

	# probably need a predictive rule for the Cint file here as well
	#if ( $Dir =~ m/(StarGeometry)/ ){
	#    my($Cint)= $1."_Cint.cxx";
	#    if ($#inc != 0){
	#	$fcheck = "$OBJ/$Dir/$Cint"; $fcheck =~ s/\#//;
	#	if ( ! -e $fcheck){
	#	    print "\tWill need to create a $OBJ/$Dir/$Cint\n";
	#	    Depends $env ["$OBJ/$Dir/$Cint"], @inc ;
	#	    #push(@srcL,"$OBJ/$Dir/$Cint");
	#	}
	#    }
	#}

    } elsif ( $Dir =~ m/Geometry/ ){
	my @xmlGeo   = script::find_xml($Dir); # print "find_xml: ======== @xmlGeo ======\n";

	#print "DEBUG Found ".($#xmlGeo+1)." XML files in $Dir\n";

	if ($#xmlGeo > -1){
	    # for the geometry package, generate the geom
	    # print join(";",@xmlGeo);
	    my($agM,$agE,$agX,$agH);
	    my($trgt);
	    my($agml_cmd);
	    my(@ODIR)= ("StarVMC/StarGeometry/",
			"StarVMC/xgeometry/");

	    # Below if() was added to prevent compilation in non-local but
	    # allow development in .dev - commented for integration
	    #if ( (! $IsRepo || $IsDotDev)){
		foreach (@ODIR){ if ( ! -d $ODIR[0] ){  mkdir($ODIR[0],0755);}}

		# local or global install
		if ( -e "mgr/agmlParser.py"){	$agml_root = "mgr";
		} else {			$agml_root = $env->{ENV}->{STAR}."/mgr";}
		$agml_cmd = "$agml_root/agmlParser.py";

		foreach $xml (@xmlGeo){
		    if ( $xml =~ /StarVMC\/Geometry\// ){
			print "xml = $xml\n" if $param::debug;
			$agM   = $xml; $agM =~ s/\..*//; $agM =~ s/.*\///;

			$agX   = $ODIR[0].$agM.".cxx";
			$agH   = $ODIR[0].$agM.".h";
			$agE   = $ODIR[1].$agM.".age";

		        #print "\tDEBUG $agX $xml\n";

			# generally enable all warnings for now
			$env->{ENV}->{AGML_WARNINGS} = 1==1; # $param::debug;

			# cons doesn't come with a scanner for python dependencies
			use File::Find;
			my @agml_deps;
			find(sub { return unless -f; return unless /\.py$/; push @agml_deps, "#$File::Find::name"; }, "$agml_root/Dyson");
			push @agml_deps, "#$xml";
			push @agml_deps, "#$agml_cmd";

			if ( $xml =~ m/Compat/ ){
			    Depends $env ["$OBJ/$agE"], @agml_deps;
			    Command $env ["$OBJ/$agE"], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=Mortran > %>);

			} else {
			    Depends $env ["$OBJ/$agX", "$OBJ/$agH", "$OBJ/$agE"], @agml_deps;
			    # Depends $env --> some rule to build extra dict on the fly

			    Command $env ["$OBJ/$agX", "$OBJ/$agH"], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=AgROOT --path=%>:d);
			    Command $env ["$OBJ/$agE"], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=Mortran > %>);

			    $trgt = $INCLUDE."/".$agH;
			    InstallAs  $env $trgt, "$OBJ/$agH";

			    # Add source dependency but only cxx
			    #>>push(@srcL, $trgt);
			}

			# Create source dependencies based on installed age, not the original
			#>>push(@srcL, $trgt );


		    } else {
			# just be sure we pick only from one tree
			print "Warning: found $xml but in a non-expected tree\n";
		    }
		#}
	     }
	}
    }
    # <-- end generating geometries


    foreach my $Rep(@Repo) {
	my $RepDir = $Rep . "/" . $Dir;
	print "RepDir = $RepDir\n" if $param::debug;

	if ( -d $RepDir and $pkg ne "RTS") {
	    my @srcR =
		script::find_sources($RepDir); # print "find_sources: ======== @srcR ======\n";
	    foreach my $i(@srcR) { push @srcL, $i; }
	    my @idlMR = script::find_idlM($RepDir); # print "find_idlM: ======== @idlMR ======\n";

	    foreach my $i(@idlMR) { push @idlML, $i; }
	    my @h_filesR = script::find_hfiles($RepDir); # print "find_hfiles: ======== @h_filesR ======\n";
	    foreach my $i(@h_filesR) { push @h_filesL, $i; }
	}
    }
    @src     = script::sortu(@srcL);
    @h_files = script::sortu(@h_filesL);
    @idlM    = script::sortu(@idlML);

    # ui     /opt/star/sl305_gcc323/qt/bin/uic GeomBrowser.ui -i GeomBrowser.h -o .ui/GeomBrowser.cpp
    # xpm    /opt/star/sl305_gcc323/qt/bin/uic  -embed -o .ui/qmake_image_collection.cpp
    my $uic = $env->{Packages}->{QT}->{BINDIR} . "/uic";
    my $qt4 = ($env->{Packages}->{QT}->{QT_VERSION} == 4);
    my $rcc =$uic;
    $rcc =  $env->{Packages}->{QT}->{BINDIR} . "/rcc" if ($qt4);
    my @QtDefs = ();
    my @uih = ();#   print "h_files: @h_files\n";
    foreach my $h (@h_files) {
	if ((!$qt4 && ($h =~ /\.ui\.h$/)) || ($qt4 && ($h =~ /ui_.+\.h$/))) {
	    push @uih, $h;
	}
    }
    # print "\$qt4 = $qt4 uih : @uih all: @h_files\n";
    foreach my $ui (@uiQT) {
	my $dir     = File::Basename::dirname( $ui );
	my $dirbase = $dir;
	$dirbase =~ s/$Dir//;
	my $stem    = File::Basename::basename( $ui, ".ui" );
	if ($dirbase) {
	    $dirbase =~ s|^/||;
	    $dirbase .= "/";
	}
	my $uilocal = $dirbase . File::Basename::basename( $ui );
	my @dep = ($uilocal, @uih);
	if ($qt4) {
	    my $out = "$dirbase". "ui_". $stem . ".h";
            # print "Qt4: out : $out ==> $uilocal\n"; # if $param::debug ;
	    Depends $env [$out], ($uilocal);
	    Command $env [$out], ($uilocal), qq(cd %1:d; $uic %1:f -o %>:f );
	    push @QtDefs, $out;    print "Qt4/QtDefs from $ui -> $out\n"; # if $param::debug;
	} else {
	    my @out = ($dirbase . $stem . ".cxx", $dirbase . $stem . ".h") ;
            #   print "Qt3:$out[1]:d \n out @dep : @out ==> $uilocal\n";
	    Depends $env [$out[1]], (@dep);
	    Depends $env [@out[0]], ($uilocal,$out[1]);
	    Command $env [$out[1]], @dep, qq(cd %1:d; $uic %1:f -o %>:f );
	    Command $env [@out[0]], ($uilocal,$out[1]), qq(cd %1:d; $uic %1:f  -i %2:f -o %>:f);
	    push @src, $out[0];
	    push @QtDefs, $out[1]; print "Qt3/QtDefs from $ui -> $out[1]\n"; # if $param::debug;
	}
    }
    if ($qt4) {
	foreach my $qrc (@qrcQT) {
	    my $dir     = File::Basename::dirname( $qrc );
	    my $dirbase = $dir;
	    $dirbase =~ s/$Dir//;
	    my $stem    = File::Basename::basename( $qrc);
	    if ($dirbase) {
		$dirbase =~ s|^/||;
		$dirbase .= "/";
	    }
	    my $qrclocal = $dirbase . File::Basename::basename( $qrc );
	    my @xpm = map ($dirbase . File::Basename::basename( $_), @xpmQT);
	    my @dep = ($qrclocal,@xpm );
	    my $out = "$dirbase". "qrc_". $stem . ".cxx";
            # print "Qt4:  ut : $out ==> $qrclocal\n@xpmQT\n"; # if $param::debug ;
	    Command $env [$out], @dep, qq(cd %1:d; $rcc %1:f -o %>:f );
	    push @src, $out
	}
    }

    $SO_PKG = $PKG . "." . $env1->{SUFSOLIB};
    $SO_PKG_PLAIN = $SO_PKG;
    if ( $#idlM > -1 and $PKG !~ "^St" ) {
	$PKG      = "St_" . $PKG;
	@PlainObj = @src;
	$SO_PKG   = $PKG . "." . $env1->{SUFSOLIB};
    }
    $SO_PKG_lib = "lib" . $SO_PKG;
    $SO_PKG_PLAIN_lib = "lib" . $SO_PKG_PLAIN;

    $obj = $ObjDir;
    print "obj = $obj\n" if $param::debug;
    print "SO_PKG = $SO_PKG\n" if $param::debug;

    $SO_MAP = $PKG . ".map";


    #+
    # Additional flag treatment for specific makers
    # Search path depth for Makers.
    #-
    print "-=-=-=-=- Will now test $pkg\n" if ($param::debug);
    if ( $pkg =~ m/^StEventDisplay/ || $#uiQT >= 0 || $OnlinePackage ) {
	# This make requires both ROOT Qt and QT libraries
	if ( defined($env1->{Packages}->{QT}->{DIR})) {
             # && (-r $ENV{ROOTSYS} . "/include/TQt.h" || -r $ENV{ROOTSYS} . "/include/TGQt.h")){
	    #print "-=-=-=-=-=-=-=- QT is defined -=-=-=-=-=-=-=-=-=-=\n";
	    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{INCDIR};
	    $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{LIBDIR};
	    #$LIBS ... should come loaded from ROOT
	    $CXXFLAGS.= " " . $env1->{Packages}->{QT}->{FLAGS};
	    #	    $LIBS .= " " . $env1->{Packages}->{QT}->{LIBS};
	}

    } elsif ( $pkg =~ m/^apythia$/ ) {
	my $CERN_ROOT = $env1->{ENV}->{CERN_ROOT};
	print "CERN_ROOT = $CERN_ROOT\n" if $param::debug;
	if ($LIBPATH) { $LIBPATH .= $main::PATH_SEPARATOR; }
	$LIBPATH .= $CERN_ROOT . "/lib";
	$LIBS .= " " . $env->{LDALL};
	foreach my $py ("pythia6205","pythia","pythia6152","pythia6136") {
	    my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
	    if (-f $file) {$LIBS .= " -l" . $py; last;}
	}
	foreach my $py ("pdflib804") {
	    my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
	    if (-f $file) {$LIBS .= " -l" . $py; last;}
	}
	$LIBS  .= " " . $env->{LDNONE};

    } elsif ( $pkg =~ m/^StTrsMaker$/ or $pkg =~ m/^pythia8/ ){
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include";
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;


    } elsif ( $pkg =~ m/^Pythia8/ and $Dir =~ m/StarGenerator/ ){
	# Append pythia 8 include path and define version
	#print "***** DEBUG ****\n";
	$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/include";
	$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/include/Pythia8";
	$CXXFLAGS .= " -DPythia8_version=\\\"$pkg\\\" -DXMLDIR=\\\".\\\" "; # note XMLDIR is fake here... code/interface needs to take care to set

	print "CPPPATH = $CPPPATH\n" if $param::debug;

	# Do not compile hepmc support, rootexamples
	@src = ();
	foreach my $s (@srcL) {
	    next if ($s =~ m/example/ ||
		     $s =~ m/hepmc/i      );
	    #print "Including $s\n";
	    push(@src,$s);
	}
	@srcL = @src;

	#print "DEBUG ".join(" ",@srcL)."\n";

    } elsif ( $pkg =~ m/^EvtGen/ and $Dir =~ m/StarGenerator/ ){
        # Append EvtGen include path and define version
        #print "***** DEBUG ****\n";

	# Set pythia 8 version here
	my $py8ver = "Pythia8_1_86";

        $FCPATH   .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/${py8ver}/include";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Photos3_61/include";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Tauola1_1_5/include";
        $CXXFLAGS .= "-DEVTGEN_EXTERNAL=1 -DEVTGEN_PYTHIA=1 -DEVTGEN_PHOTOS=1 -DEVTGEN_TAUOLA=1 -DEvtGen_version=\\\"$pkg\\\" ";
	$CXXFLAGS .= " -DPythia8_version=\\\"$py8ver\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, validation
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/test/ ||
                     $s =~ m/validation/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^HepMC/ and $Dir =~ m/StarGenerator/ ){
        # Append HepMC include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CXXFLAGS .= " -Dmomentum=GEV -Dlength=MM -DHepMC_version=\\\"$pkg\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/test/ ||
                     $s =~ m/examples/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^Photos/ and $Dir =~ m/StarGenerator/ ){
        # Append Photos include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/eventRecordInterfaces";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/photos-C";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/photosCInterfaces";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/utilities";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CXXFLAGS .= " -DPhotos_version=\\\"$pkg\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/examples/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^Tauola/ and $Dir =~ m/StarGenerator/ ){
        # Append Tauola include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Tauola1_1_5/include/Tauola";
        $FCPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/tauola-fortran/tauola-modified/new-currents/RChL-currents/rcht_3pi";
        #$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/tauola-fortran/tauola-modified/new-currents/RChL-currents/rcht_3pi";
        $CXXFLAGS .= " -DTauola_version=\\\"$pkg\\\" ";
        $CPPFLAGS .= " -x c++";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/SANC/ ||
                     $s =~ m/tauola-fortran\/glibk/ ||
                     $s =~ m/tauola-fortran\/jetset/ ||
                     $s =~ m/tauola-fortran\/jetset2/ ||
                     $s =~ m/tauola-fortran\/tauola-F/ ||
                     $s =~ m/tauola-fortran\/photos-F/ ||
                     $s =~ m/tauola-fortran\/demo-factory/ ||
                     $s =~ m/tauola-fortran\/tauola-factory/ ||
                     $s =~ m/tauola-fortran\/tauola-BBB/ ||
                     #$s =~ m/src/ ||
                     $s =~ m/TauSpinner/ ||
                     $s =~ m/examples/     );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";

    } elsif ( $pkg =~ m/^StHbtMaker$/ ) {
	$CPPPATH = "#" . $Dir;
	foreach my $subdir( "Base", "Infrastructure", "Reader", "Cut", "CorrFctn", "Fit", "ThCorrFctn")
	{
	    $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/" . $subdir;
	}
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}

        if ( defined($ENV{GSL_DIR}) ) {
          $CPPPATH = $ENV{GSL_DIR}."/include".$main::PATH_SEPARATOR.$CPPPATH;
        } else {
          $CPPPATH = $env1->{ENV}->{OPTSTAR}."/include".$main::PATH_SEPARATOR.$CPPPATH;
        }

	print "CPPPATH = $CPPPATH\n" if $param::debug;
	# According to description, all client requirering this
	# should be added here.

    } elsif ( $pkg =~ m/^StRTSClient/ ) {
	my ($basep) = $Dir;
	$basep =~ s/Client\/.*/Client/;
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR ."#". $basep ."/include";
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;


	# This block can be used for ANY Maker or Pool having a 2 level
	# directory structure using auto-globbing for include purposes
    } elsif ( $pkg =~ m/^StAssociationMaker$/ ||
	      $pkg =~ m/EmcUtil$/             ||
	      $pkg =~ m/St_geant_Maker$/      ||
	      $pkg =~ m/^StMuDSTMaker$/       ||
	      $pkg =~ m/^StJetMaker$/         ||
	      $pkg =~ m/^StEmcPool$/          ||
	      $pkg =~ m/^StEEmcPool$/         ||
	      $pkg =~ m/^StTofPool$/          ||
	      $pkg =~ m/^StRichPool$/         ||
	      $pkg =~ m/^StGeneri/            ||
	      $pkg =~ m/^StPxlSim/            ||
	      $pkg =~ m/^St.*Utilities/       ||
	      $pkg =~ m/^StTriggerUtilities$/ ||
	      $pkg =~ m/^Stv$/                ||
	      $pkg =~ m/^Sti/ && $pkg !~ m/StiVMC/) {

        $CPPPATH .=  $main::PATH_SEPARATOR . "#" . $Dir;

	print "WARNING Package $pkg requires a glob() to be called\n" if $param::debug;

	foreach my $subdir ( glob("$Dir/*") ){
	    if( -d $subdir &&
		$subdir ne "$Dir/\."       &&
		$subdir ne "$Dir/\.\."     &&
		$subdir ne "$Dir/CVS"      &&
		$subdir ne "$Dir/macros"   &&
		$subdir ne "$Dir/examples" &&
		$subdir ne "$Dir/doc" ){
		#print "Inserting $subdir\n";
		$CPPPATH  .= $main::PATH_SEPARATOR . "#"  . $subdir;
	    }
	}
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;
	#$SO_PKG = $PKG . "." . $env1->{SUFSOLIB};

	#print "-=-=-=-=-=-= SO_PKG = $SO_PKG\n";

    } elsif ( $pkg =~ m/^StJetFinder$/ ){

        if ( defined($ENV{FASTJET_DIR}) ) {
          $CPPPATH = $ENV{FASTJET_DIR}."/include".$main::PATH_SEPARATOR.$CPPPATH;
        } else {
          $CPPPATH = $env1->{ENV}->{OPTSTAR}."/include".$main::PATH_SEPARATOR.$CPPPATH;
        }

    } elsif ( $pkg =~ m/^StFwdTrackMaker$/ ){ 
		$CXXFLAGS .=  " -I".$env1->{ENV}->{OPTSTAR}."/include";
		$env1->{StFwdTrackMaker}->{ROOTCINT_INCLUDES} = $env1->{ENV}->{OPTSTAR}."/include"
    } elsif ( $pkg =~ m/^gcalor$/ || $pkg =~ m/^geant321$/) {
	$LIBPKG = "lib" . $pkg . "." . $env1->{SUFLIB};
	$SO_PKG = "";
	$SO_MAP = "";
	$FCPATH = "#" . $Dir . "/../geant321" .
	    $main::PATH_SEPARATOR . "#" . $Dir . "/../starsim/include" .
	    $main::PATH_SEPARATOR . "#" . $Dir . "/../gcalor/include" .
	    $main::PATH_SEPARATOR . $env1->{FCPATH};
	$FPPFLAGS = " -DATLAS_UNIX -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
        # $FPPFLAGS = $env1->{Packages}->{CERNLIB}->{FPPFLAGS} . " -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
        # $CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};

    } elsif ( $pkg =~ m/^g2t/ || $pkg =~ m/^gstar/ || $pkg =~ m/^geometry/ ) {
	$SO_MAP  = "";
	$FCPATH  = $INCLUDE;
	$FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/starsim/include";
	$FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/geant321/include";
	$FCPATH .= $main::PATH_SEPARATOR . $env1->{ENV}->{CERN_ROOT} . "/include";
        # $FCPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};

    } elsif ( $pkg =~ /^xgeometry/ ){
	$LIBS .= " -lStarMagFieldNoDict ";

    } elsif ($pkg =~ m/TGeant3|StarVMCApplication|StVMCMaker/) {
	$CPPPATH =  $env1->{ENV}->{ROOT} . "/" .$env1->{ENV}->{ROOT_LEVEL} . "/geant3/TGeant3"
	    . $main::PATH_SEPARATOR . $CPPPATH;

    } elsif ($pkg eq 'StarMiniCern') {
	$FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
	$CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};
	$FCPATH = "#StarVMC/minicern" . $main::PATH_SEPARATOR . $INCLUDE;
	$CPPPATH .= $main::PATH_SEPARATOR . "#StarVMC/minicern";
	my @srcC = ();
	foreach my $s (@src) {
	    my $dirL  = File::Basename::dirname($s);
	    my $sdir = File::Basename::basename($dirL);
	    #      print "s = $s dir = $dirL sdir = $sdir\n";
	    #      next if $sdir ne $dirL;
	    next if $sdir eq 'hpxgs'; # hpux macos
	    next if $sdir eq 'sungs'; # sun
	    next if $sdir eq 'allgs';
	    next if $sdir eq 'lnxgs';
	    next if $sdir eq 'lnxppcgs';
	    next if $sdir eq 'qutyinv';
	    next if $sdir eq 'qutyz32';
	    #      print "add $s\n";
	    push @srcC, $s;
	}
	@src = @srcC;
	push @src, "lnxgs/rdmin.F"  if $STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/;
	if ($FC eq 'g77') {
	    $LIBS .= " -lg2c";
	}

    } elsif ($pkg eq 'geant3') {
	$SO_PKG = "lib" . $SO_PKG; $SO_PKG_lib = $SO_PKG;
	$FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
	$CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};
	$FCPATH = "#StarVMC/geant3" . $main::PATH_SEPARATOR . "#StarVMC/geant3/minicern" . $main::PATH_SEPARATOR . $INCLUDE .
	    $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};
	my @dirs = qw (added gbase gcons geocad ggeom gheisha ghits ghrout ghutils
		       giface giopa gkine gparal gphys gscan gstrag gtrak matx55 miface
		       miguti neutron peanut fiface cgpack fluka block comad erdecks erpremc
		       minicern gdraw TGeant3);
	my $dirs = join '|', @dirs;
	my @srcC = ();
	foreach my $s (@src) {
	    my $dirL = File::Basename::dirname($s);
	    my $sdir = File::Basename::basename($dirL);
	    #      print "s = $s dir = $dirL sdir = $sdir\n";
	    next if $dirL !~ /$dirs/;
	    next if $sdir eq 'hpxgs'; # hpux macos
	    next if $sdir eq 'sungs'; # sun
	    next if $sdir eq 'allgs';
	    next if $sdir eq 'lnxgs';
	    next if $sdir eq 'lnxppcgs';
	    next if $sdir eq 'qutyinv';
	    next if $sdir eq 'qutyz32';

	    next if $s =~ /gtrak\/grndm.*\.F/;
	    #      if ($s =~ /gevkev/) {print "==================================";}
	    #      print "add $s\n";
	    push @srcC, $s;
	}
	@src = @srcC;
	push @src, "gcinit.F";

    } elsif ( $Dir =~ m/StarVMC/ && $pkg =~ /ecal|Tpc|star/) {
	$CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/include";

    } elsif ( $pkg =~ m/^StBFChain$/ && (! $IsRepo || $IsDotDev) ) {
	my($cmd)="BFCOpt2Html.pl";
	$cmd = "mgr/BFCOpt2Html.pl" if ( -e "mgr/BFCOpt2Html.pl");
	print "\t add documentation for $pkg\n";
	Command $env ["#StRoot/StBFChain/doc/BFC.h"], ("#StRoot/StBFChain/BigFullChain.h"), qq (%CPP            %< > %>);
	Command $env ["#StRoot/StBFChain/doc/BFC2.h"],("#StRoot/StBFChain/BigFullChain.h"), qq (%CPP -D__BFC2__ %< > %>);
	Command $env [("#StRoot/StBFChain/doc/index.html","#StRoot/StBFChain/doc/StBFChain.cxx_doc")],
	("#StRoot/StBFChain/doc/BFC.h","#StRoot/StBFChain/doc/BFC.h", "#StRoot/StBFChain/doc/BFC2.h"),
	qq($cmd);
    }

    # mysql and Db related linking separate
    #print "*** $pkg\n";
    if ( $pkg =~ m/^St.*Db/             ||
	 $pkg =~ m/^StStarLogger/       ||
	 $pkg =~ m/^StUCMApi/           ||
	 $pkg =~ m/^StTriggerUtilities/ ||
	 $pkg =~ m/Jevp/
	 ){
	#print "+++ Match +++\n";
	$CPPPATH .= $main::PATH_SEPARATOR .  $env1->{Packages}->{MYSQL}->{INCDIR};
	if ($pkg eq 'StDbLib' ||
	    $pkg =~ m/Jevp/   ) {
	    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{INCDIR};
	    $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{LIBDIR};
	    $LIBS .=  " " . $env1->{Packages}->{XML}->{LIBS};
	    if ($env1->{Packages}->{XML}->{CPP}) {
		$EXTRA_CPPFLAGS .= $env1->{Packages}->{XML}->{CPP};
	    }
	}
	if ($pkg eq 'StTpcDb') {$LIBS .=  " -lStarMagField";}
	print "EXPANDING CPPPATH = $CPPPATH\n" if $param::debug;

    } elsif ( $Dir =~ m/StarVMC/ and $pkg =~ m/StiVMC/) {
	$CPPPATH = "#StarVMC" . $main::PATH_SEPARATOR . $CPPPATH;
	#    print "StarVMC change CPPPATH to $CPPPATH =========\n";

    } elsif ($pkg eq "TPCCATracker" or $pkg eq "StiCA") {
        $CPPPATH .=
	  $main::PATH_SEPARATOR . "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/code";

        if ( defined($ENV{Vc_DIR}) ) {
          $CPPPATH = $ENV{Vc_DIR}."/include".$main::PATH_SEPARATOR.$CPPPATH;
          $LIBPATH = $ENV{Vc_DIR}."/lib";
        }

	my $extraCXXFLAGS = " -DNVALGRIND -DENABLE_VECTORIZATION -W -Wall -Wswitch -Wformat -Wchar-subscripts";
	$extraCXXFLAGS .= " -Wparentheses -Wmultichar -Wpointer-arith -Wcast-align -Wreturn-type -Wno-unused-function";
	$extraCXXFLAGS .= " -pedantic -Wno-long-long -Wno-variadic-macros -msse -msse2 -Wshadow -fno-threadsafe-statics -DTBB_DO_ASSERT=1";
	if ($STAR_SYS eq 'sl64_gcc447' or $STAR_SYS eq 'sl64_x8664_gcc447') {$extraCXXFLAGS .= " --param large-function-growth=500";}
	if ($STAR_SYS eq 'sl64_gcc447' or $STAR_SYS eq 'sl64_x8664_gcc447') {$extraCXXFLAGS .= " --param large-function-growth=500";}
	$extraCXXFLAGS .= " -DNODEBUG";
	$CXXFLAGS .= $extraCXXFLAGS;
	$CXXFLAGS .= $env->{Packages}->{Vc}->{CPP};
	if ( defined($ENV{Vc_LIB_DIR}) ) { die("Vc_LIB_DIR is not supported anymore. Please use Vc_DIR."); }
	$LIBS = "-lVc";
	if ($extraCXXFLAGS =~ /USE_TBB/) {$LIBS .= " -lTBB";}
    }
    if ( $pkg =~ m/^Sti$/) {
      if ($DEBUG =~ /-O/ and $STAR_SYS =~ /gcc432/) { # hack for Sti with gcc432
	$envNoDeb = $env->clone('DEBUG' => '-g');
	for ($i = 0; $i < $#src; $i++) {
	  if ($src[$i] =~ /StiVMCToolKit\.cxx/) {
	    my @objfiles = Objects $envNoDeb ($src[$i]);
	    $src[$i] = $objfiles[0];
	    last;
	  }
	}
      }
    }

    if ( $pkg =~ m/^StiMaker/) {
      if ($DEBUG =~ /-O/ and $STAR_SYS =~ /gcc432/) { # hack for StiMaker with gcc432
	$DEBUG = "-g";
      }
    }

    if ( $#idlM > -1 ) {
	$CPPPATH = $INCLUDE . "/" . $pkg . $main::PATH_SEPARATOR . $CPPPATH;
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    } elsif ( $#idlL > -1 ) {
	$CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables" . $main::PATH_SEPARATOR . "#";;
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    }
    if ( $LIBPKG && $Dir =~ /pams\// ) {
	$LIBS .= " -l" . $pkg;    #"lib" . $pkg . "." . $env1->{SUFLIB};
    }

    if (($pkg eq 'StHbtMaker' or $pkg eq 'StMuDSTMaker') and $CC ne 'gcc' and $CC ne 'icc') {
	# fight with __PRETTY_FUNCTION__
	$EXTRA_CPPFLAGS .= " -DDEBUGMESSAGE\\\(x\\\)=\"\"  -DDEBUGMESSAGE1\\\(x\\\)=\"\"  "
	                .  " -DDEBUGMESSAGE2\\\(x\\\)=\"\"  -DDEBUGMESSAGE3\\\(x\\\)=\"\" "
			.  " -DFORCEDDEBUGMESSAGE\\\(x\\\)=\"\"";
    }

    #print "_+_+_+_+_+ $CPPPATH $CXXFLAGS $LIBS $CPPPATH $LIBPATH _+_+_+_+_+\n";

    if ($pkg =~ /^StUCMApi$/ or $pkg =~ /^StStarLogger$/) {
	$EXTRA_CPPFLAGS .=" -D_UCMLOGGER_";
	$CPPPATH .= $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/base"
	         . $main::PATH_SEPARATOR . "StRoot/StUCMApi"
		 . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data"
		 . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/modules";
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
    }

    if ($pkg =~ /^StStarLogger$/) {
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
	$LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{LIBDIR};
	$LIBS    .= " " . $env1->{Packages}->{Logger}->{LIBS};
    }

    if ( $STAR_SYS =~ /kcc$/ ) { $LIBPATH = ""; $LIBS = ""; }
#    print "pkg = $pkg FPPFLAGS = $FPPFLAGS\n";
    my $libpath = $LIBPATH;
    if (! $LIBS) {$libpath = "";}
#  print "CPPPATH => $CPPPATH \tCPPFLAGS => $CPPFLAGS\n";
    #print "DEBUG Passing $ROOTCINT_CPPFLAGS\n";
    $env2 = $env1->clone('Package'  => $pkg,
			 'EXTRA_CPPFLAGS'    => $EXTRA_CPPFLAGS,
			 'CPPPATH'  => $CPPPATH,
			 'CFLAGS'   => $CFLAGS,
			 'CXXFLAGS' => $CXXFLAGS,
			 'FC'       => $FC,
			 'FFLAGS'   => $FFLAGS,
			 'FCPATH'   => $FCPATH,
			 'FEXTEND'  => $FEXTEND,
			 'FPPFLAGS' => $FPPFLAGS,
			 'CPPFLAGS' => $CPPFLAGS,
			 'FCCOM'    => $FCCOM,
			 'LIBS'     => $LIBS,
			 'SOFLAGS'  => $SOFLAGS,
			 'LIBPATH'  => $libpath,
			 'ObjDir'   => $obj_dir,
			 'DEBUG'    => $DEBUG,
			 'FDEBUG'   => $FDEBUG
			 );

    #print "DEBUG ".$env2->{ROOTCINT_CPPFLAGS}."\n";
    # 'ROOTCINT_CPPFLAGS' => $ROOTCINT_CPPFLAGS,

#    bless $env2, "cons"; #?
#  print "env2 : CPPPATH => $env2->{CPPPATH} \tCPPFLAGS => $env2->{CPPFLAGS}\n";
#    if ($CC eq 'icc') {$EXTRA_CPPFLAGS .= " " . "-DR__NO_CLASS_TEMPLATE_SPECIALIZATION";}
    my $Cint_CPPPATH = $CPPPATH . $main::PATH_SEPARATOR . "#";
#  print "Cint_CPPPATH => $Cint_CPPPATH\n";
    $envCint = $env2->clone('DEBUG' => $env2->{NOOPT},
			    'CPPPATH'  => $Cint_CPPPATH,
			    'CPPFLAGS' => $CPPFLAGS,
			    'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS);

    print "LIBPATH = |", $env2->{LIBPATH}, "|\n LIBS = |", $env2->{LIBS},
    "|\n CPPPATH = |", $env2->{CPPPATH}, "|\n" if $param::debug;

    print "LINKMODULECOM |", $env2->{LINKMODULECOM}, "|\n" if $param::debug;
    my $cscanner = find scan::cpp( $env2->{_cwd}, $env2->{CPPPATH} );
    my @cpps = split /$main::PATH_SEPARATOR/, $env2->{CPPPATH};
    # Additional include paths can be specified for individual packages
    my @cpps_pkg = split /$main::PATH_SEPARATOR/, $env1->{$pkg}->{ROOTCINT_INCLUDES};
    push(@cpps, @cpps_pkg);
    #  print "cpps => @cpps\n";# if $param::debug;
    #print "cpps => @cpps\n";
    my $ROOTCINT_CPP = "";
    my $STIC_CPP     = "";

    #  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
    foreach my $cpp( $Dir, @cpps ) {
	if ( $cpp =~ /cern/ || $cpp eq "/usr/include" || $cpp =~ /ospace/ ||
	     $cpp =~ /openwin/ ){
	    next;
	}
	if ($ROOTCINT_CPP) { $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $ROOTCINT_CPP = $cpp; }
	if ( $cpp =~ /ROOT/ ) {next}
	if ($STIC_CPP) { $STIC_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $STIC_CPP = $cpp; }
    }
    #  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
    $cscanner = find scan::cpp( $env2->{_cwd}, $ROOTCINT_CPP );
    print "ROOTCINT_CPP = $ROOTCINT_CPP\n" if $param::debug;
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env2);
    if ($env2->{EXTRA_CPPFLAGS}) {
	$ROOTCINT_CPPPATH .= " " . $env2->{EXTRA_CPPFLAGS}; # Requested By Frank Laue
    }
    print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n" if $param::debug;
    $cscanner = find scan::cpp( $env2->{_cwd}, $STIC_CPP );
    my $STIC_CPPPATH =
	$cscanner->iflags($env2);    # print "STIC_CPPPATH  = $STIC_CPPPATH\n";
    my $DIR = Cwd::cwd();
    print "DIR = $DIR\n" if $param::debug;
    my $line;
    my @Defs = ();


    if ( $#idlM > -1 ) {
	my $include = $INCLUDE . "/" . $pkg;
	print "include = $include\n" if $param::debug;
	foreach my $idl(@idlM) {
	    my $stem = File::Basename::basename( $idl, ".idl" );
	    print "idl = $idl  stem = $stem\n" if $param::debug;
	    my $idm  = $stem . ".idl";
	    my $idMM = $DIR . "/" . $Dir . "/" . $idl;
	    print "idMM = $idMM\n" if $param::debug;
	    my $idM = "#" . $Dir . "/" . $idl;
	    print "idM = $idM\n" if $param::debug;
	    my @idlS = ($idM);
	    my $modh = $INCLUDE . "/" . $stem . ".h";
	    my $modi = $INCLUDE . "/" . $stem . ".inc";
	    my $modH = $include . "/" . "St_" . $stem . "_Module.h";
	    print "modH = $modH\n" if $param::debug;
	    my $modC = "St_" . $stem . "_Module.cxx";
	    print "modC = $modC\n" if $param::debug;

	    $env2->{ENV}->{STICTMP} = "/tmp/$<$$";
	    my $stic_cmd =
	        "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
	        "/bin/mkdir -m 777 \$STICTMP && cd \$STICTMP && ".
	        "/bin/cp %<:a . && $STIC -s -r $STIC_CPPPATH -q %<:f && ".
	        "(/bin/mv %>:f %>:a ; cd /tmp  &&  /bin/rm -rf \$STICTMP)";
	    Command $env2 [$modh], @idlS, qq($stic_cmd);
	    Command $env2 [$modi], @idlS, qq($stic_cmd);
	    Command $env2 [$modH], @idlS, qq($stic_cmd);
	    Command $env2 [$modC], @idlS, qq($stic_cmd);

	    my @objmod = ($modC);
	    print "Install @objmod in $ObjDir\n" if $param::debug;
	    push @src, $modC;
	    print "src + $mod: @src\n" if $param::debug;
	    push @Defs, $modH;
	}

    } else {
	foreach $h(@h_files) {#print "h: $h\n";
	    if ( $h =~ /LinkDef/) { push @LinkDefs, $h;}
	    if ( $h =~ /LinkDef/ || $h =~ /Stypes/ ) { push @Defs, $h; next; }
	    my $hh = $Dir . "/" . $h;
	    if ( -r $hh ) {
		open( In, $hh ) or die "Can't open $hh";
		my $classDefFlag = 1;
		my $qtFlag       = 1;
		while ( $line = <In> ) {
		    if ( ( $line =~ /ClassDef/ || $line =~ /StCollectionDef/) ) {
			push @Defs, $h; # print "$h <==========\n";
			$classDefFlag = 0;
		    } elsif ( $line =~ /Q_OBJECT/ && defined($env1->{Packages}->{QT}->{BINDIR}) && $qtFlag ) {

			push @QtDefs, $h; print "QtDefs from Q_OBJECT  @QtDefs\n" if $param::debug;
			$qtFlag = 0;
		    }
		    next if ( $classDefFlag + $qtFlag == 0 );
		}
		close(In);

	    } else {

		foreach my $Rep(@Repo) {
		    my $RepDir = $Rep . "/" . $Dir;
		    print "RepDir = $RepDir\n" if $param::debug;
		    if ( -d $RepDir ) {
			my $hh = $RepDir . "/" . $h;
			if ( -r $hh ) {
			    open( In, $hh ) or die "Can't open $hh";

			    while ( $line = <In> ) {
				if ( $line =~ /ClassDef/
				     || $line =~ /StCollectionDef/ )
				{
				    push @Defs, $h;
				    goto ENDL;
				}
			    }
			    close(In);
			}
		    }
		}
	    }
	  ENDL:
	}
    }

    if ( $#Defs > -1 && $pkg !~ m/Geometry/ ) {
	my @CintFiles = ( $PKG . "_Cint.cxx", $PKG . "_Cint.h", "LinkDef.h" );

        if ($env->{ENV}->{ROOT_VERSION_MAJOR} >= 6) {
            push @CintFiles, $PKG."_Cint_rdict.pcm";
            Install $env $LIB, File::Basename::basename($CintFiles[3]);
        }

	@Defs = script::sortu(@Defs);
	my @defs = ();
	foreach my $def(@Defs) {    #print "def = $def OBJ = $OBJ\n";
	    if ( $def =~ /^\#/ ) { push @defs, $def; }
	    else { push @defs, "#" . $Dir . "/" . $def; }
	}
	foreach my $def (@LinkDefs) {
	    open (In, $Dir . "/" . $def) or die "Can't open $def";
	    while (my $line = <In>) {
		if (($line  =~ /^\/\/IncFile *=/))	{
		    my @words = split /(=)/, $line;
		    chomp(@words[2]);
		    my $h = $words[2];
		    # remove the quotation surrounding the file name if any
		    $h =~ s/^\"// ; $h =~ s/\"$// ;
		    if (! -r $Dir . "/" . $h) {
			$h = "#StRoot/" . $h;
		    }
		    print "Add $Dir ========= $h \n" if $param::debug;
		    if (! -r $h) {push @defs, $h;}
		}
	    }
	    close(in);
	}
	Depends $env2 [@CintFiles], @h_files;
	Depends $env2 [@CintFiles], ($env2->{Packages}->{ROOT}->{ROOTCINT});

	my $RCINTPL;

	# use local if available
	if ( -e "mgr/RootCint.pl") {
	    $RCINTPL = "mgr/RootCint.pl";
	} else {
	    $RCINTPL = "RootCint.pl";
	}
	Command $env2 [@CintFiles], @defs,
	qq($RCINTPL "%>" "%<" "$ROOTCINT_CPPPATH" );

	@LinkDefs = ("LinkDef.h");
	my @objfiles = Objects $envCint ($CintFiles[0]);
	#	push @src, $CintFiles[0];
	push @src, @objfiles[0];
	print "+==========add cint $CintFiles[0]\n" if $param::debug;
	#die ;
    }

    if ( $#QtDefs > -1 ) {
	my $mocheaders = join $main::PATH_SEPARATOR, @QtDefs;
	my @mocs = script::MakeMoc( $env2, $pkg, $done, $mocheaders);
	print "mocheaders: $mocheaders \tmocs: @mocs\n" if $param::debug;
	foreach $m(@mocs) { push @src, $m;}
    }
}


#____________________________________Tables____________________________
# Tables:
my @sourcesT = ();

if ( $#idlL > -1 ) {
  my @idlT = ();
  my $objT = $OBJ . "/pams/tables";
  ( my $objT_dir = $objT ) =~ s/^\#//g;
  print "objT_dir = $objT_dir\n" if $param::debug;
  my $includeT = $INCLUDE . "/tables";
  print "includeT = $includeT\n" if $param::debug;

  foreach my $idl(@idlL) {
    print "$idl\n" if $param::debug;
    my $IDL =
      "#" . $Dir . "/" . $idl;    # print "i=",$i++," idl = $idl IDL=$IDL\n";
    my $stem = File::Basename::basename( $IDL, ".idl" );
    print "stem = $stem\n" if $param::debug;
    my $idlt = $includeT . "/" . File::Basename::basename($idl);
    push @idlT, $IDL;
  }
  print "idlT = @idlT\n" if $param::debug;

  if ( $#idlT > -1 ) {
    $PKGT    = "lib" . $pkg . "_Tables";
    $SO_PKGT = $PKGT . "." . $env1->{SUFSOLIB};
    $SO_MAPT = $PKGT . ".map";
    print "SO_PKGT = $SO_PKGT\n" if $param::debug;
    my $LIBPKGT = $PKGT . "." . $env1->{SUFLIB};

    if ( $Dir =~ /StRoot\//  ||  $Dir =~ /OnlTools\//) {
      $SO_PKGT = $SO_PKG;
      $SO_MAPT = $SO_MAP;
      $LIBPKGT = $LIBPKG;
    } else {
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir,
	      $PKGT )
	unless ($param::quiet);
    }
    #        Install $env $INCLUDE, @idlT;  # print "Install $env $INCLUDE, @idlT\n";

    #___________________________________
    my $ROOTCINT_CPP =
      $INCLUDE . $main::PATH_SEPARATOR . $INCLUDE . "/tables";
    $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $env1->{ENV}->{ROOTSRC};

    my $tobj_dir = $obj_dir . "/Tables";
    $CPPPATH = "";
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    $CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables";
    #    if ($#QtDefs >= 0) {$CPPPATH .= $main::PATH_SEPARATOR . $env->{ENV}->{QTDIR} . "/include";}
    $env3 = $env1->clone('DEBUG'   => $env1->{NOOPT},
			 'CPPPATH' => $CPPPATH,
			 'ObjDir'  => $tobj_dir,
			 'LIBPATH' => ''
			);
    my $cscanner =
      find scan::cpp( $env1->{_cwd}, $ROOTCINT_CPP );
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env3); #print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n"; die;
    foreach my $idll(@idlT) {
      my $stem = File::Basename::basename( $idll, ".idl" );
      print "stem = $stem; idll: $idll\n" if $param::debug;
      my $dir = File::Basename::dirname($idll);
      print "dir = $dir\n" if $param::debug;
      my $idl  = File::Basename::basename($idll);
      my $idlh = $INCLUDE . "/" . $stem . ".h";
      print "idlh: $idlh\n" if $param::debug;
      my $idli = $INCLUDE . "/" . $stem . ".inc";
      print "idli: $idli\n" if $param::debug;
      my $idlH = $includeT . "/St_" . $stem . "_Table.h";
      print "idlH: $idlH\n" if $param::debug;
      my $idlC = "St_" . $stem . "_Table.cxx";
      print "idlC: $idlC\n" if $param::debug;
      my $LinkDef = $stem . "LinkDef.h";
      push @LinkDefsT, $LinkDef;
      print "LinkDef = $LinkDef\n" if $param::debug;
      my $idlCintH = "St_" . $stem . "_TableCint.h";
      print "idlCintH = $idlCintH\n" if $param::debug;
      my $idlCintC = "St_" . $stem . "_TableCint.cxx";
      print "idlCintC = $idlCintC\n" if $param::debug;
      ( my $IDL = $idll ) =~ s/^\#//g;
      print "IDL = $IDL\n" if $param::debug;

      if ( -r $IDL ) {
	my @Deps = ($idll);
	print "Deps: $Deps[0]\n" if $param::debug;

	$env3->{ENV}->{STICTMP} = "/tmp/$<$$";
	my $stic_cmd  =
	  "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
	  "/bin/mkdir -p -m 777 \$STICTMP && cd \$STICTMP && ".
	  "/bin/cp %<:a . && $STIC -q %<:f && ".
	  "(/bin/mv %>:f %>:a ; cd /tmp ; /bin/rm -rf \$STICTMP)";

	Command $env3 [$idlh], @Deps, qq ($stic_cmd);
	Command $env3 [$idli], @Deps, qq ($stic_cmd);
	push @Deps, $idlh;
	Command $env3 [$idlH], @Deps, qq (ConstructTable.pl %1 %>);
	push @Deps, $idlH;
	Command $env3 [$idlC], @Deps, qq (ConstructTable.pl %1 %>);
	Command $env3 [$LinkDef], @Deps,
	  qq (ConstructTable.pl %1 %>);

	@Deps = ();
	push @Deps, $idlH;
	push @Deps, $LinkDef;
	push @LinkDefs, $LinkDef;
	push @Deps, $idlh;
	push @Deps, $idli;

	Command $env3 [ ($idlCintC , $idlCintH) ], @Deps,
	  qq (rootcint -f %> -c $ROOTCINT_CPPPATH -D__ROOT__ %1 %2);

	push @Deps, $idlCintC;
	push @Deps, $idlCintH;
	push @Deps, $idlC;
	my @src = ( $idlC, $idlCintH, $idlCintC );
	#               Install $env3 $objT, @src;
      }
      my $s;

      if ( $SO_PKGT eq $SO_PKG ) {
	push @src,$idlC;
	push @src, $idlCintC;
      } else {
	push @sourcesT, $idlC;
	push @sourcesT, $idlCintC;
      }
    }
    print "sourcesT = @sourcesT\n" if $param::debug;
  }
}

if ( $#sourcesT > -1 ) {
  script::Keep $SO_PKGT;
  LinkedModule $env3 $SO_PKGT, @sourcesT;
  Install $env3 $LIB, $SO_PKGT;
  if ($env3->{Packages}->{ROOT}->{RLIBMAP} and $SO_MAPT and $#LinkDefsT > -1) {
    Command $env3 [ $SO_MAPT ], ($LIB . "/" . $SO_PKGT, @LinkDefsT),
      qq($env3->{Packages}->{ROOT}->{RLIBMAP} -r %> -l %1 -c %<);
    Install $env3 $LIB, $SO_MAPT;
  }
}

if ( $#src > -1 ) {
  my  $envPlain = $env2;
  printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $PKG )
    unless ($param::quiet);
  if ($LIBPKG) {
    Library $env2 $LIBPKG, @src;
    Install $env2 $LIB,    $LIBPKG;
    print "Install $env2 $LIB, $LIBPKG\n" if $param::debug;
    if ($SO_PKG) {
      my $libpkg = $LIB . "/" . File::Basename::basename($LIBPKG);
      Depends $env2 $SO_PKG, $libpkg;
    }
  }
  # print "-=-=-=-=- SO_PKG = $SO_PKG $pkg -=-=-=-=-=-\n";
  # print "SO_PKG = $SO_PKG\n";
  if ($SO_PKG) {
    script::Keep $SO_PKG;
    if ($pkg =~ m/StarMagField/) {
#      my @o = Objects $env2 (@src);
#      @src = @o;
      $envNoROOT = $env->clone('CPPFLAGS' => "", 'SUFOBJ'   => "NoDict.o",);
      @PlainObj =  Objects $envNoROOT(qw(StarMagField.cxx));
#      foreach my $s (@o) {
#	if ($s !~ /Cint/) {push @PlainObj, $s;}
#      }
      $SO_PKG_PLAIN = $pkg . "NoDict";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
    }
    if ($pkg =~ m/^geometry/ ){
      $SO_PKG_PLAIN = $pkg . "NoField";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
      my @ss = ();
      foreach my $s (@src) {
	if ($s !~ /mfldgeo/ ) {push @ss, $s}
      }
      @src = @ss;
      @PlainObj = Objects $env2 (@src);
      @src = @PlainObj;
      #      print "PlainObj = @PlainObj\n";
      my $libs = "-lStarMagFieldNoDict";
      $envg = $env2->clone('LIBPATH'  => $LIB, 'LIBS'     => $libs);
      $libs =~ s/-l/lib/;
      $libs = $LIB . "/" . $libs;
      $libs .= "." . $env2->{SUFSOLIB};
      Depends $envg, [($SO_PKG)], ($libs); #print "libs = $libs\n";
      $env2 = $envg;
    }
#________________________________________________________________________________
    if ($pkg =~ m/^StGenericVertexMaker$/) { # For Stv no Sti
      $SO_PKG_PLAIN = $pkg . "NoSti";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
      @PlainObj = ();
      @Obj = Objects $env2  (@src);
#      print "$#src => @src \n";
#      print "$#Obj => @Obj \n";
      foreach my $o (@Obj) {
#	print "o ++++++> $o\n";
	if ($o =~ m/\/StiPPVertex\//) {next;}
	push @PlainObj, $o;
      }
      @src = @Obj;
#      print "$#src => @src \n";
#      print "$#PlainObj => @PlainObj \n";
    }
    LinkedModule $env2 $SO_PKG, @src;
    Install $env2 $LIB,         $SO_PKG;
    my $lib = $LIB . "/" . $SO_PKG;
    if ($SO_PKG ne $SO_PKG_lib) {
      $lib = $LIB . "/" . $SO_PKG_lib;
      InstallAs $env2 $lib, $SO_PKG;
    }
    #    print "SO_PKG = $SO_PKG SO_PKG_PLAIN = $SO_PKG_PLAIN $#PlainObj PlainObj = @PlainObj\n";
    if ($SO_PKG ne $SO_PKG_PLAIN and $#PlainObj > -1) {#print "============================\n";
      script::Keep $SO_PKG_PLAIN;
      LinkedModule $envPlain $SO_PKG_PLAIN, @PlainObj;
      Install $envPlain $LIB,         $SO_PKG_PLAIN;
      if ($SO_PKG_PLAIN !~ /^lib/) {
	my $lib = $LIB . "/lib" . $SO_PKG_PLAIN;
	InstallAs $envPlain $lib, $SO_PKG_PLAIN;
      }
    }
    if ($pkg eq "RTS") {
      my $cppflags = "-DRTS_PROJECT_STAR -DTPXREADER -DRTS_LITTLE_ENDIAN";
      my $cpppath  = $main::PATH_SEPARATOR . "#StRoot/RTS/include"
	. $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include"
	  . $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC"
	    . $main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS"
	      . $main::PATH_SEPARATOR . "#StRoot/RTS/src"
		. $main::PATH_SEPARATOR . "StRoot/RTS/src/EVP_READER";
      $envRTS = $env2->clone('Package'  => $pkg,
			     'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS,
			     'CPPPATH'  => $cpppath,
			     'CPPFLAGS' => $cppflags,
			     'LIBPATH'  => $LIB,
			     'LIBS'     => "-lRTS"
			    );
      my @programs = glob "./StRoot/RTS/src/RTS_EXAMPLE/*.C"; #("RTS_EX/Reader","EVP_READER/special","RTS_EXAMPLE/daqFileChopper");
      foreach my $progD (@programs) {
	my $prog = File::Basename::basename($progD,".C");
	Program      $envRTS $prog, ("src/RTS_EXAMPLE/" . $prog . ".C");
	Install $envRTS $BIN, $prog;
      }
    }
  }
}
#_________________________________________________________________________________
sub script::MakeMoc {
  my $envQt  = shift;
  my $pkg  = shift;
  my $done = shift;
  my @includes = split $main::PATH_SEPARATOR,shift;
  my $Dir  = $envQt->{Dir};
  my $ROOTCINTFLAGS = "-I" . $Dir . "/inc";
  my @src      = ();
  my @Defs     = ();
  my $PLATFORM = $envQt->{PLATFORM};
  foreach my $header (@includes) {
    my $dd = $d;
    my $G__name = "moc_" . $header;
    $G__name =~ s/\.h$/\.cxx/;
    my $moc = $envQt->{Packages}->{QT}->{BINDIR} . "/moc";
    # print "moc is $moc\n";
    Command $envQt ($G__name), ($header), qq($moc -o %>  %<);
    push @src, $G__name;
    print "+==========add moc file: $G__name\n" if $param::debug;
  }
  return @src;
}
#____________________________________________________________
sub script::alpha_arcom { #
  my ($lib,$src) = @_;
  my $input = "input" . File::Basename::dirname($lib);
  open (OUTPUT, ">$input") or die "Can't open $input\n";
  print OUTPUT $src;
  close(OUTPUT);
  my $cmd = "ar $lib -input $input'; ranlib $lib"; print "$cmd\n";
  my $flag = `$cmd`; if ($?) {exit 2;}
  return 1;
}
#_________________________________________________________________________________


