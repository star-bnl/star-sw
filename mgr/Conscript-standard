#!/usr/bin/env perl
Import qw ( env CWD INCLUDE LIB BIN BUILD OBJ);
( my $build = $OBJ ) =~ s/\#//g;
$build =~ s/\\/\//g;                                    # print "OBJ = $OBJ build = $build\n";
# print "MAIN = $MAIN\n";
my $DirPath = DirPath '.';                              # print "DirPath = $DirPath\n";
( my $obj_dir = $DirPath ) =~ s/\\/\//g;                # print "obj_dir = $obj_dir\n";
( my $Dir = $obj_dir ) =~ s/$build\///g;                # print "Dir = $Dir\n";
my $ObjDir       = "#" . $obj_dir;                      # print "ObjDir = $ObjDir\n";
my $STAR_SYS     = $env->{ENV}->{STAR_SYS};
my $STAR_VERSION = $env->{ENV}->{STAR_VERSION};         # print "#####  $STAR_VER\n";
my $AFS_RHIC     = $env->{ENV}->{AFS_RHIC};

@Repo   = Repository_List unless $param::noRepository;#   print "Repositories = |@Repo|\n";


print "+-+-+- STAR=".$env->{ENV}->{STAR}."\n"  if $param::debug;
print "+-+-+- cwd=".$CWD."\n"                  if $param::debug;
my $IsDotDev = 0;
if ($env->{ENV}->{STAR} =~ /\.(dev|DEV)/) {$IsDotDev = 1;}
my $IsRepo = (stat($env->{ENV}->{STAR}."/."))[1] == (stat($CWD."/."))[1];

if ($param::debug) {
    if ( $IsRepo && ! $IsDotDev ){
	print "... REPOSITORY compilation  ...\n";
    } else {
	print "... USER area compilation   ...\n";
    }
}
my $SO_PKG  = "";
my $SO_PKG_lib = "";
my $SO_PKG_PLAIN = "";
my $SO_PKGT = "";
my $SO_MAP  = "";
my $SO_MAPT = "";
my $pkg;
my $PKG;
my $OnlinePackage=0;
my @LinkDefs = ();
my @LinkDefsT = (); # for tables if any
my @PlainObj = ();

if ( ($Dir =~ m/StRoot.*Pool\//   && $Dir !~ /StRoot.*Pool\/St/)   ||
     ($Dir =~ m/StRoot.*Client\// && $Dir !~ /StRoot.*Client\/St/) ||
     ($Dir =~ m/StarVMC\/minicern/  || $Dir =~ m/StarGenerator/ )
     ) {
    # Added 2003. In Construct, the logic is such
    # that the Pool directories have their sub-directories
    # set as targets (n sub-dir => n libraries). That's
    # fine ... apart from name clash we try to resolve
    # here.
    $pkg = $Dir;
    $pkg =~ s/StRoot\///;

    if ( $Dir =~ m/StarGenerator/ ){
	if ( $Dir =~ m/(StarGenerator)(\/)([A-Z]+$)/ ){
	    # camel case
	    $pkg =  $1.substr($3,0,1).lc(substr($3,1,length($3)));
	} else {
	    # normal case, use subdir name
	    $pkg =~ s/.*StarGenerator\///;
	}
	#print "\t[".File::Basename::basename($Dir)."] changed to $pkg\n";
    } else {
	$pkg =~ s/Pool\//Pool/      if ($pkg =~ m/Pool/  );
	$pkg =~ s/Client\//Client/  if ($pkg =~ m/Client/);
	$pkg = "StarMiniCern"       if ($pkg =~ m/minicern/);
	print "\t[".File::Basename::basename($Dir)."] (possible name clash) changed to $pkg\n";
    }
    $PKG = $pkg;

} else {
    $pkg = File::Basename::basename($Dir);               # print "Run cons in $Dir for $PKG\n";
    $PKG = $pkg;
    $OnlinePackage=true if $Dir =~ /^OnlTools/;# and $pkg ne "OnlinePlots";
}

$env1 = $env->clone('Package'  => $pkg);
my $DEBUG   = $env1->{DEBUG};
my $CXXFLAGS= $env1->{CXXFLAGS};
my $CFLAGS  = $env1->{CFLAGS};
my $FC      = $env1->{FC};
my $CC      = $env1->{CC};
my $FFLAGS  = $env1->{FFLAGS};
my $FCPATH  = $env1->{FCPATH};
my $FEXTEND = $env1->{FEXTEND};
my $FPPFLAGS= $env1->{FPPFLAGS};
my $FCCOM   = $env1->{FCCOM};
my $LIBS    = $env1->{LIBS};
my $SOFLAGS = $env1->{SOFLAGS};
my $LIBPATH = $env1->{LIBPATH};
my $STIC    = $env1->{STIC};
my $EXTRA_CPPFLAGS = $env1->{EXTRA_CPPFLAGS};
my $CPPFLAGS = $env1->{CPPFLAGS};

my $ROOTCINT_CPPFLAGS = "";
my @idlL    = script::find_idl($Dir); # print "find_idlL: ======== @idlL ======\n";
print "In Dir = $Dir idlL = @idlL\n" if $param::debug;
foreach my $Rep(@Repo) {
  my $RepDir = $Rep . "/" . $Dir;
  print "RepDir = $RepDir\n" if $param::debug;
  if ( -d $RepDir ) {
    my @idlR = script::find_idl($RepDir); # print "find_idlL: ======== @idlR ======\n";
    foreach my $i(@idlR) { push @idlL, $i; }
  }
}
@idlL = script::sortu(@idlL);
                                          print "find in $Dir ========\n" if $param::debug;
my @idlML    = script::find_idlM($Dir);   print "find_idl in $Dir ======== @idlML ======\n" if $param::debug;
my @srcL     = script::find_sources($Dir);print "find_sources in in $Dir ======== @srcL ======\n" if $param::debug;
my @h_filesL = script::find_hfiles($Dir); print "find_hfiles in $Dir ======== @h_filesL ======\n" if $param::debug;
my @uiQT     = script::find_ui($Dir);     print "find_ui in $Dir ======== @uiQT ======\n" if $param::debug;
my @xpmQT    = script::find_xpm($Dir);    print "find_xpm in $Dir ======== @xpmQT ======\n" if $param::debug;
my @qrcQT    = script::find_qrc($Dir);    print "find_qrc in $Dir ======== @qrcQT ======\n" if $param::debug;


print "idlL = @idlL\n"   if $param::debug;
# print "Geom = @xmlGeo\n";

my (@src, @h_files, @idlM);
my $CPPPATH = $env1->{CPPPATH};

if ($pkg eq "RTS") {
  if ($STAR_SYS =~ /^x86_darwin/) {}
  else {
    $CPPFLAGS .= ' -D_LARGEFILE64_SOURCE';
  }
    $CPPFLAGS .= ' -DNEW_DAQ_READER -DRTS_PROJECT_STAR -DTPXREADER '
	      .  '-DRTS_LITTLE_ENDIAN -DEVP_VERSION="\"EVP_VERSION=2.0\""';
    $CPPFLAGS =~ s/-D__ROOT__//;# print " ------------  CPPFLAGS ==== " .  $CPPFLAGS . "\n";
    $CFLAGS =~   s/-D__ROOT__//;# print " ------------  CFLAGS WHERE \"__ROOT__\" coming from ??? ==== " .  $CFLAGS . "\n";
    $CPPPATH = $main::PATH_SEPARATOR . "#StRoot/RTS/include" 
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include" 
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC" 
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS" 
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src" 
	    .  $main::PATH_SEPARATOR . "#StRoot/RTS/src/EVP_READER" 
	    .  $main::PATH_SEPARATOR . $CPPPATH;
    my @src = ();
    #  print "srcL : @srcL\n";
    #  print "skip /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/\n";
    foreach my $s (@srcL) {
	next if $s =~ /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/;
	push @src, $s;
    }
    #  print "@src : @src\n";
    @srcL = @src;
    @src = ();
}

# Some directories will need extra includes for the RTS DAQ reader
my @DAQ_pkgs = qw(StDAQMaker StTofHitMaker StTpcHitMaker StEEmcPoolmuEztPanitkin  
		  StBEMCPlots StBTofHitMaker StMtdHitMaker StPmdReadMaker St_pp2pp_Maker StSstDaqMaker
		  StFmsTriggerMaker StDaqLib Stl3Util StTriggerUtilities
		); 
#		  StTriggerUtilities 
# But any *Raw* in StRoot/ would have this automatically done / handled
if ( $pkg =~ m/Raw/ ){
#    print "Found [$pkg] as Raw package\n";
    push(@DAQ_pkgs,$pkg);
}
my $DAQ_pkgs = join('|',@DAQ_pkgs);

my $RTS_READER_PATH =  $main::PATH_SEPARATOR . "#StRoot/RTS/src" 
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/include"
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include";


#if (!$OnlinePackage) { $OnlinePackage=grep(m/$pkg/,@DAQ_pkgs); }
if ($OnlinePackage) {
  $CPPPATH = $main::PATH_SEPARATOR . "#OnlTools" . $RTS_READER_PATH . $main::PATH_SEPARATOR . $CPPPATH;
}
#print "==> $pkg => $DAQ_pkgs =======\n";
if ( $pkg =~ /$DAQ_pkgs/ )  {
  $CPPPATH = $main::PATH_SEPARATOR . "#" . $Dir . $RTS_READER_PATH . $main::PATH_SEPARATOR . $CPPPATH; 
#  print "=========> $CPPPATH\n";
#. "/usr/include/libxml2" . $main::PATH_SEPARATOR 
#ifdef ____MAC_____
#    if ($pkg =~ /StDaqLib/) {$CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir;}
#endif /* ____MAC_____ */
}
if ( $pkg eq "OnlinePlots") {
  $CPPPATH  .=  $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure"
            .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/HistogramGroups"
	    .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure/EEmcDb"
	    .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/QEvpClient"
	    .   $main::PATH_SEPARATOR . "#StRoot/RTS/EventTracker"
	    .   $main::PATH_SEPARATOR .  $CPPPATH;
  $CPPFLAGS .= " -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_NO_DEBUG ";
}
if ( $pkg eq "Jevp") {
    $CPPPATH  .=  $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpPlot"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpPresenter"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpServer"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpData"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpBuilders"
	      .   $main::PATH_SEPARATOR . "#OnlTools/Jevp/StJevpViewer"
	      .   $main::PATH_SEPARATOR .  $CPPPATH;
    $CPPFLAGS .= " -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_NO_DEBUG ";
} 
if ( $pkg eq "GeoTestMaker") {
  $LIBS = "-lQtGui"; 
}

#$CPPFLAGS .= " -DNEW_DAQ_READER -D__NO_STRANGE_MUDST__  ";
$CPPFLAGS .= " -DNEW_DAQ_READER ";

if ($pkg eq "StDAQMaker") {
  $LIBS = "-lStDaqLib -lRTS";
}
my ($i, $obj);
my $LIBPKG = "";

my @g77pkgs = qw(geometry gen sim tls minicern geant3);
my $g77pkgs = join('|', @g77pkgs); print "FC = $FC pkg = $pkg DirPath = $DirPath\n" if $param::debug;


#+
# some compiler specific treatments below, global or conditional
#-
if( $FC eq 'pgf77'){
  if ($DirPath  =~ /$g77pkgs/ or $DirPath !~ /pams/) {
    $FC       = $env1->{G77}; print "set FC => $FC ==============================\n" if $param::debug;
    $FFLAGS   = $env1->{G77FLAGS};
    $FEXTEND  = $env1->{G77EXTEND};
  }
}
if ($FC =~ m/g77/ || $FC =~ m/gfortran/ ){
    if ( $DirPath =~ /pams/ and
	 ($DirPath !~ /$g77pkgs/ or $DirPath =~ /crs/ or $DirPath =~ /g2t/ or $DirPath =~ /hij/)){
	$FCCOM    = $env1->{FCviaAGETOFCOM};
    }
    # If fortran, grab the -lg2c or -lgfortran for linking
    if ( $DirPath =~ /StarVMC/ ){
	#print "\tAppending ".$env1->{FLIBS}." to LIBS=$LIBS\n";
	$LIBS .= " " . $env1->{FLIBS};
    }
  
    ## this is done not only for stand-alone library purpose but for backward
    ## compatibility of root4star linked with -lg2c rather than gfortran (hence
    ## libs would not work as symbol would fail to resolve)
    #if ( $FC eq 'gfortran' && (grep(/.F$/,@srcL) || grep(/.g$/,@srcL)) ){
    #	print "\tFound .F or .g in sources and adding [".
    #	    $env1->{FLIBS}."] to $pkg\n" ; # if $param::debug;
    #	$SOFLAGS .= " " . $env1->{FLIBS};
    #	#print "\tFinal SOFLAGS are $SOFLAGS\n";
    #}
}

#+
# Now we treat anything which is neither sim nor gen
# This will include all makers
#-
if ( $pkg !~ /^sim$/ && $pkg !~ /^gen$/ ) {
    print "\t--- Regular case treatment (not gen not sim) ---\n" if $param::debug;
  
    # if user requested debug, print some info on what was found
    if ($param::debug) {
	$i = 0;
	foreach my $s(@idlML) { print "i=", $i++, " idlM = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@srcL) { print "i=", $i++, " src = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@h_filesL) { print "i=", $i++, " h_files = ", $s, "\n"; }
    }
 


    #+
    # Generate geometries first - this will be hit on any $Dir
    # xgeometry and StarGeometry may not be created however
    #-
    my($agM,$agE,$agX,$agH);
    my($trgt);

    if ( $Dir =~ m/(xg)(eometry)/ || $Dir =~ m/(StarG)(eometry)/){
	# Force dependency creation based on xml - each expected dependencies
	# have to be known a-priori by cons (the the order will be sorted out)
	# but we do not want to add the source (hence the derived .o) twice
	# and use fcheck for tetsing that
	my $RepDir = $Dir; $RepDir =~ s/$1/G/;
	my @xmlGeo   = script::find_xml($RepDir); # print "find_xml: ======== @xmlGeo ======\n";
	my @src=undef;
	my @inc=undef;
	my $fcheck;

	#print "\tBefore ".($#src)." ".($#inc)."\n";
	foreach $xml (@xmlGeo){
	    $agM  = $xml; $agM =~ s/\..*//; $agM =~ s/.*\///;
	    $trgt = "";
	    $hfl  = "";
	    if ( $Dir =~ m/xgeometry/ ){
		$fcheck = $trgt  = $OBJ."/".$Dir."/".$agM.".age"; 
		$fcheck =~ s/\#//; $trgt = "" if ( -e $fcheck);
	    } else {
		# Compat contains redundant defs only needed for the age
		# .h also needed for Dictionary building
		if ( $xml !~ m/Compat/ ){
		    $fcheck = $trgt  = $OBJ."/".$Dir."/".$agM.".cxx"; 
		    $fcheck =~ s/\#//; $trgt = "" if ( -e $fcheck);

		    $fcheck = $hfl   = $OBJ."/".$Dir."/".$agM.".h";
		    $fcheck =~ s/\#//; $hfl = "" if ( -e $fcheck);
		}
	    }
	    # push but only if not present - if present, cons will find
	    # them so there is no need for a predictive target rule
	    push(@src, $trgt ) if ($trgt ne "" );
	    push(@inc, $hfl)   if ($hfl  ne "" );
	}
	#print "\tAfter  ".($#src)." ".($#inc)."\n";

	#print "-=-=-=-=- LALALA -=-=-=-\n";
	# 2018/01 issue after updating to AgML 2.0
	# TODO problem with optimization in xgeometry and StarGeometry
	if ( $DEBUG =~ /-O/ ){   # there is an optimization used
	    $DEBUG = "-O1 -g";   # switch to a lower optimization level
	    $FDEBUG= "-O1 -g";
	}

	# repack now and make sure only one exists
	push(@srcL,@src)      if ($#src != 0);
	push(@h_filesL,@inc)  if ($#inc != 0);

	#print "\t".join(",",@src)."\n";
	print "\tWill be adding ".($#src+1)." sources and ".($#inc+1)." inc to $Dir\n" if ($#src != 0 || $#inc !=0);
  
	# probably need a predictive rule for the Cint file here as well
	#if ( $Dir =~ m/(StarGeometry)/ ){
	#    my($Cint)= $1."_Cint.cxx";
	#    if ($#inc != 0){
	#	$fcheck = "$OBJ/$Dir/$Cint"; $fcheck =~ s/\#//;
	#	if ( ! -e $fcheck){
	#	    print "\tWill need to create a $OBJ/$Dir/$Cint\n";
	#	    Depends $env ["$OBJ/$Dir/$Cint"], @inc ;
	#	    #push(@srcL,"$OBJ/$Dir/$Cint");
	#	}
	#    }
	#}

    } elsif ( $Dir =~ m/Geometry/ ){
	my @xmlGeo   = script::find_xml($Dir); # print "find_xml: ======== @xmlGeo ======\n";
	
	#print "DEBUG Found ".($#xmlGeo+1)." XML files in $Dir\n";

	if ($#xmlGeo > -1){
	    # for the geometry package, generate the geom
	    # print join(";",@xmlGeo);
	    my($agM,$agE,$agX,$agH);
	    my($trgt);
	    my($agml_cmd);
	    my(@ODIR)= ("StarVMC/StarGeometry/",
			"StarVMC/xgeometry/");
	    
	    # Below if() was added to prevent compilation in non-local but
	    # allow development in .dev - commented for integration
	    #if ( (! $IsRepo || $IsDotDev)){
		foreach (@ODIR){ if ( ! -d $ODIR[0] ){  mkdir($ODIR[0],0755);}}

		# local or global install
		if ( -e "mgr/agmlParser.py"){	$agml_cmd = "mgr/agmlParser.py";
		} else {			$agml_cmd = $env->{ENV}->{STAR}."/mgr/agmlParser.py";}
		
		foreach $xml (@xmlGeo){
		    if ( $xml =~ /StarVMC\/Geometry\// ){
			print "xml = $xml\n" if $param::debug;
			$agM   = $xml; $agM =~ s/\..*//; $agM =~ s/.*\///;
			
			$agX   = $ODIR[0].$agM.".cxx";
			$agH   = $ODIR[0].$agM.".h";
			$agE   = $ODIR[1].$agM.".age";
			  
		        #print "\tDEBUG $agX $xml\n";
			
			# generally enable all warnings for now
			$env->{ENV}->{AGML_WARNINGS} = 1==1; # $param::debug;
			
			if ( $xml =~ m/Compat/ ){
			    Depends $env ["#".$agE], ("#$xml", "#$agml_cmd");
			    Command $env ["#".$agE], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=Mortran > %>);

			} else {
			    Depends $env ["#".$agX, "#".$agH, "#".$agE], ("#$xml", "#$agml_cmd");
			    # Depends $env --> some rule to build extra dict on the fly

			    Command $env ["#".$agX], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=AgROOT --path=%>:d);
			    Command $env ["#".$agE], ("#$xml"), qq($agml_cmd --file=%1 --module=$agM --export=Mortran > %>);

			    # Install local file (#) as global
			    # The .h file can be installed as-is
			    $trgt = $OBJ."/".$agH;
			    InstallAs  $env $trgt, "#".$agH;
			    
			    # The recently generated .cxx will create an extra source dependency
			    $trgt = $OBJ."/".$agX;
			    InstallAs  $env $trgt, "#".$agX;

			    # Add source dependency but only cxx
			    #>>push(@srcL, $trgt); 
			}

			# Install the "#" i.e. local file as global file - ageF created in both cases
			# BEWARE that the agE (.age) file is created in xgeometry
			$trgt = $OBJ."/".$agE;
			InstallAs  $env $trgt, "#".$agE;

			# Create source dependencies based on installed age, not the original
			#>>push(@srcL, $trgt ); 


		    } else {
			# just be sure we pick only from one tree
			print "Warning: found $xml but in a non-expected tree\n";
		    }
		#}
	     }
	}
    }
    # <-- end generating geometries


    foreach my $Rep(@Repo) {
	my $RepDir = $Rep . "/" . $Dir;
	print "RepDir = $RepDir\n" if $param::debug;
    
	if ( -d $RepDir and $pkg ne "RTS") {
	    my @srcR =
		script::find_sources($RepDir); # print "find_sources: ======== @srcR ======\n";
	    foreach my $i(@srcR) { push @srcL, $i; }
	    my @idlMR = script::find_idlM($RepDir); # print "find_idlM: ======== @idlMR ======\n";
      
	    foreach my $i(@idlMR) { push @idlML, $i; }
	    my @h_filesR = script::find_hfiles($RepDir); # print "find_hfiles: ======== @h_filesR ======\n";
	    foreach my $i(@h_filesR) { push @h_filesL, $i; }
	}
    }
    @src     = script::sortu(@srcL); 
    @h_files = script::sortu(@h_filesL);
    @idlM    = script::sortu(@idlML);

    # ui     /opt/star/sl305_gcc323/qt/bin/uic GeomBrowser.ui -i GeomBrowser.h -o .ui/GeomBrowser.cpp
    # xpm    /opt/star/sl305_gcc323/qt/bin/uic  -embed -o .ui/qmake_image_collection.cpp
    my $uic = $env->{Packages}->{QT}->{BINDIR} . "/uic";
    my $qt4 = ($env->{Packages}->{QT}->{QT_VERSION} == 4);
    my $rcc =$uic;
    $rcc =  $env->{Packages}->{QT}->{BINDIR} . "/rcc" if ($qt4);
    my @QtDefs = ();
    my @uih = ();#   print "h_files: @h_files\n";
    foreach my $h (@h_files) {
	if ((!$qt4 && ($h =~ /\.ui\.h$/)) || ($qt4 && ($h =~ /ui_.+\.h$/))) {
	    push @uih, $h;
	}
    }
    # print "\$qt4 = $qt4 uih : @uih all: @h_files\n";
    foreach my $ui (@uiQT) {
	my $dir     = File::Basename::dirname( $ui );
	my $dirbase = $dir;
	$dirbase =~ s/$Dir//;
	my $stem    = File::Basename::basename( $ui, ".ui" );
	if ($dirbase) {
	    $dirbase =~ s|^/||;
	    $dirbase .= "/";
	}
	my $uilocal = $dirbase . File::Basename::basename( $ui );
	my @dep = ($uilocal, @uih);
	if ($qt4) {
	    my $out = "$dirbase". "ui_". $stem . ".h"; 
            # print "Qt4: out : $out ==> $uilocal\n"; # if $param::debug ;
	    Depends $env [$out], ($uilocal);
	    Command $env [$out], ($uilocal), qq(cd %1:d; $uic %1:f -o %>:f );
	    push @QtDefs, $out;    print "Qt4/QtDefs from $ui -> $out\n"; # if $param::debug;
	} else {
	    my @out = ($dirbase . $stem . ".cxx", $dirbase . $stem . ".h") ; 
            #   print "Qt3:$out[1]:d \n out @dep : @out ==> $uilocal\n";
	    Depends $env [$out[1]], (@dep); 
	    Depends $env [@out[0]], ($uilocal,$out[1]);
	    Command $env [$out[1]], @dep, qq(cd %1:d; $uic %1:f -o %>:f );
	    Command $env [@out[0]], ($uilocal,$out[1]), qq(cd %1:d; $uic %1:f  -i %2:f -o %>:f);
	    push @src, $out[0];
	    push @QtDefs, $out[1]; print "Qt3/QtDefs from $ui -> $out[1]\n"; # if $param::debug;
	}
    }
    if ($#xpmQT >= 0) {
	my $out = $PKG . "_image_collection.cxx";
	if (!$qt4) {
	    my $dir     = File::Basename::dirname( $xpmQT[0] );
	    my $dirbase = $dir;
	    $dirbase =~ s/$Dir//;
	    if ($dirbase) {
		$dirbase =~ s|^/||;
		$dirbase .= "/";
	    }
	    my @xpm = map ($dirbase . File::Basename::basename( $_), @xpmQT);
	    print "Command $uic -embed ".join(" ",@xpm)." -o $out \n";
	    Command $env [$out], @xpm, qq($uic -embed %< -o %> );
	    push @src, $out
	    }
    }
    if ($qt4) {
	foreach my $qrc (@qrcQT) {
	    my $dir     = File::Basename::dirname( $qrc );
	    my $dirbase = $dir;
	    $dirbase =~ s/$Dir//;
	    my $stem    = File::Basename::basename( $qrc);
	    if ($dirbase) {
		$dirbase =~ s|^/||;
		$dirbase .= "/";
	    }
	    my $qrclocal = $dirbase . File::Basename::basename( $qrc );
	    my @xpm = map ($dirbase . File::Basename::basename( $_), @xpmQT);
	    my @dep = ($qrclocal,@xpm );
	    my $out = "$dirbase". "qrc_". $stem . ".cxx"; 
            # print "Qt4:  ut : $out ==> $qrclocal\n@xpmQT\n"; # if $param::debug ;
	    Command $env [$out], @dep, qq(cd %1:d; $rcc %1:f -o %>:f );
	    push @src, $out
	}
    }
    

    
    
    
    $SO_PKG = $PKG . "." . $env1->{SUFSOLIB};
    $SO_PKG_PLAIN = $SO_PKG;
    if ( $#idlM > -1 and $PKG !~ "^St" ) { 
	$PKG      = "St_" . $PKG; 
	@PlainObj = @src; 
	$SO_PKG   = $PKG . "." . $env1->{SUFSOLIB};
    }
    $SO_PKG_lib = "lib" . $SO_PKG;
    $SO_PKG_PLAIN_lib = "lib" . $SO_PKG_PLAIN;
  
    $obj = $ObjDir;
    print "obj = $obj\n" if $param::debug;
    print "SO_PKG = $SO_PKG\n" if $param::debug;

    $SO_MAP = $PKG . ".map";
    
    
    #+
    # Additional flag treatment for specific makers
    # Search path depth for Makers.
    #-
    print "-=-=-=-=- Will now test $pkg\n" if ($param::debug);
    if ( $pkg =~ m/^StEventDisplay/ || $#uiQT >= 0 || $OnlinePackage ) {
	# This make requires both ROOT Qt and QT libraries
	if ( defined($env1->{Packages}->{QT}->{DIR})) {
             # && (-r $ENV{ROOTSYS} . "/include/TQt.h" || -r $ENV{ROOTSYS} . "/include/TGQt.h")){
	    #print "-=-=-=-=-=-=-=- QT is defined -=-=-=-=-=-=-=-=-=-=\n";
	    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{INCDIR};
	    $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{LIBDIR};
	    #$LIBS ... should come loaded from ROOT
	    $CXXFLAGS.= " " . $env1->{Packages}->{QT}->{FLAGS};
	    #	    $LIBS .= " " . $env1->{Packages}->{QT}->{LIBS};
	}
    
#  } elsif ( $pkg =~ m/^St.*Db/       or
#	    $pkg =~ m/^StStarLogger/ or
#	    $pkg =~ m/^StUCMApi/     or
#	    $pkg =~ m/^StTriggerUtilities$/) {
#    $CPPPATH .= $main::PATH_SEPARATOR .  $env1->{Packages}->{MYSQL}->{INCDIR};
#    if ($pkg eq 'StDbLib') {
#      $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{INCDIR};
#      $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{LIBDIR};
#      $LIBS .=  " " . $env1->{Packages}->{XML}->{LIBS} ." -lrt";
#      if ($env1->{Packages}->{XML}->{CPP}) {
#	$EXTRA_CPPFLAGS .= $env1->{Packages}->{XML}->{CPP};
#      }
#    }
#    if ($pkg eq 'StTpcDb') {$LIBS .=  " -lStarMagField";}
#    print "CPPPATH = $CPPPATH\n" if $param::debug;

    } elsif ( $pkg =~ m/^apythia$/ ) {
	my $CERN_ROOT = $env1->{ENV}->{CERN_ROOT};
	print "CERN_ROOT = $CERN_ROOT\n" if $param::debug;
	if ($LIBPATH) { $LIBPATH .= $main::PATH_SEPARATOR; }
	$LIBPATH .= $CERN_ROOT . "/lib";
	$LIBS .= " " . $env->{LDALL};
	foreach my $py ("pythia6205","pythia","pythia6152","pythia6136") {
	    my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
	    if (-f $file) {$LIBS .= " -l" . $py; last;}
	}
	foreach my $py ("pdflib804") {
	    my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
	    if (-f $file) {$LIBS .= " -l" . $py; last;}
	}
	$LIBS  .= " " . $env->{LDNONE};

    } elsif ( $pkg =~ m/^StTrsMaker$/ or $pkg =~ m/^pythia8/ ){
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include";
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;


    } elsif ( $pkg =~ m/^Pythia8/ and $Dir =~ m/StarGenerator/ ){
	# Append pythia 8 include path and define version
	#print "***** DEBUG ****\n";
	$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/include"; 
	$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/include/Pythia8";
	$CXXFLAGS .= " -DPythia8_version=\\\"$pkg\\\" ";
	print "CPPPATH = $CPPPATH\n" if $param::debug;

	# Do not compile hepmc support, rootexamples
	@src = ();
	foreach my $s (@srcL) {
	    next if ($s =~ m/example/ ||
		     $s =~ m/hepmc/i      );
	    #print "Including $s\n";
	    push(@src,$s);
	}
	@srcL = @src;

	#print "DEBUG ".join(" ",@srcL)."\n";

    } elsif ( $pkg =~ m/^EvtGen/ and $Dir =~ m/StarGenerator/ ){
        # Append EvtGen include path and define version
        #print "***** DEBUG ****\n";

	# Set pythia 8 version here
	my $py8ver = "Pythia8_1_86";

        $FCPATH   .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/${py8ver}/include";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Photos3_61/include";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Tauola1_1_5/include";
        $CXXFLAGS .= "-DEVTGEN_EXTERNAL=1 -DEVTGEN_PYTHIA=1 -DEVTGEN_PHOTOS=1 -DEVTGEN_TAUOLA=1 -DEvtGen_version=\\\"$pkg\\\" ";
	$CXXFLAGS .= " -DPythia8_version=\\\"$py8ver\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, validation
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/test/ ||
                     $s =~ m/validation/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^HepMC/ and $Dir =~ m/StarGenerator/ ){
        # Append HepMC include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg";
        $CXXFLAGS .= " -Dmomentum=GEV -Dlength=MM -DHepMC_version=\\\"$pkg\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/test/ ||
                     $s =~ m/examples/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^Photos/ and $Dir =~ m/StarGenerator/ ){
        # Append Photos include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/eventRecordInterfaces";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/photos-C";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/photosCInterfaces";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/src/utilities";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CXXFLAGS .= " -DPhotos_version=\\\"$pkg\\\" ";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/examples/      );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";


    } elsif ( $pkg =~ m/^Tauola/ and $Dir =~ m/StarGenerator/ ){
        # Append Tauola include path and define version
        #print "***** DEBUG ****\n";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/HepMC2_06_09";
        $CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/Tauola1_1_5/include/Tauola";
        $FCPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/tauola-fortran/tauola-modified/new-currents/RChL-currents/rcht_3pi";
        #$CPPPATH  .= $main::PATH_SEPARATOR . "#StRoot/StarGenerator/$pkg/tauola-fortran/tauola-modified/new-currents/RChL-currents/rcht_3pi";
        $CXXFLAGS .= " -DTauola_version=\\\"$pkg\\\" ";
        $CPPFLAGS .= " -x c++";
        print "CPPPATH = $CPPPATH\n" if $param::debug;

        # Do not compile test, examples
        @src = ();
        foreach my $s (@srcL) {
            next if ($s =~ m/SANC/ ||
                     $s =~ m/tauola-fortran\/glibk/ ||
                     $s =~ m/tauola-fortran\/jetset/ ||
                     $s =~ m/tauola-fortran\/jetset2/ ||
                     $s =~ m/tauola-fortran\/tauola-F/ ||
                     $s =~ m/tauola-fortran\/photos-F/ ||
                     $s =~ m/tauola-fortran\/demo-factory/ ||
                     $s =~ m/tauola-fortran\/tauola-factory/ ||
                     $s =~ m/tauola-fortran\/tauola-BBB/ ||
                     #$s =~ m/src/ ||
                     $s =~ m/TauSpinner/ ||
                     $s =~ m/examples/     );
            #print "Including $s\n";
            push(@src,$s);
        }
        @srcL = @src;

        #print "DEBUG ".join(" ",@srcL)."\n";



    } elsif ( $pkg =~ m/^StHbtMaker$/ ) {
	$CPPPATH = "#" . $Dir;
	foreach
	    my $subdir( "Base", "Infrastructure", "Reader", "Cut",
			"CorrFctn", "Fit", "ThCorrFctn")
	{
	    $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/" . $subdir;
	}
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	# $CPPPATH .= $main::PATH_SEPARATOR . "/opt/star/include";
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{ENV}->{OPTSTAR}."/include";
	print "CPPPATH = $CPPPATH\n" if $param::debug;
	# According to description, all client requirering this
	# should be added here.

    } elsif ( $pkg =~ m/^StRTSClient/ ) {
	my ($basep) = $Dir;
	$basep =~ s/Client\/.*/Client/;
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR ."#". $basep ."/include";
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;


	# This block can be used for ANY Maker or Pool having a 2 level
	# directory structure using auto-globbing for include purposes
    } elsif ( $pkg =~ m/^StAssociationMaker$/ ||
	      $pkg =~ m/EmcUtil$/             ||
	      $pkg =~ m/St_geant_Maker$/      ||
	      $pkg =~ m/^StMuDSTMaker$/       ||
	      $pkg =~ m/^StJetMaker$/         ||
	      $pkg =~ m/^StEmcPool$/          ||
	      $pkg =~ m/^StEEmcPool$/         ||
	      $pkg =~ m/^StTofPool$/          ||
	      $pkg =~ m/^StRichPool$/         ||
	      $pkg =~ m/^StGeneri/            ||
	      $pkg =~ m/^StPxlSim/            ||
	      $pkg =~ m/^St.*Utilities/       ||
	      $pkg =~ m/^StTriggerUtilities$/ ||
	      $pkg =~ m/^Stv$/                ||
	      $pkg =~ m/^Sti/ && $pkg !~ m/StiVMC/) {

      $CPPPATH .=  $main::PATH_SEPARATOR . "#" . $Dir; 

	print "WARNING Package $pkg requires a glob() to be called\n" if $param::debug;
    
	foreach my $subdir ( glob("$Dir/*") ){
	    if( -d $subdir &&
		$subdir ne "$Dir/\."       &&
		$subdir ne "$Dir/\.\."     &&
		$subdir ne "$Dir/CVS"      &&
		$subdir ne "$Dir/macros"   &&
		$subdir ne "$Dir/examples" &&
		$subdir ne "$Dir/doc" ){
		#print "Inserting $subdir\n";
		$CPPPATH  .= $main::PATH_SEPARATOR . "#"  . $subdir;
	    }
	}
	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
	print "CPPPATH = $CPPPATH\n" if $param::debug;
	#$SO_PKG = $PKG . "." . $env1->{SUFSOLIB};
    
	#print "-=-=-=-=-=-= SO_PKG = $SO_PKG\n";

    } elsif ( $pkg =~ m/^StJetFinder$/ ){
	$CXXFLAGS .=  " -I".$env1->{ENV}->{OPTSTAR}."/include";

    } elsif ( $pkg =~ m/^gcalor$/ || $pkg =~ m/^geant321$/) {
	$LIBPKG = "lib" . $pkg . "." . $env1->{SUFLIB};
	$SO_PKG = "";
	$SO_MAP = "";
	$FCPATH = "#" . $Dir . "/../geant321" .
	    $main::PATH_SEPARATOR . "#" . $Dir . "/../starsim/include" .
	    $main::PATH_SEPARATOR . "#" . $Dir . "/../gcalor/include" .
	    $main::PATH_SEPARATOR . $env1->{FCPATH};
	$FPPFLAGS = " -DATLAS_UNIX -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
        # $FPPFLAGS = $env1->{Packages}->{CERNLIB}->{FPPFLAGS} . " -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
        # $CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};

    } elsif ( $pkg =~ m/^g2t/ || $pkg =~ m/^gstar/ || $pkg =~ m/^geometry/ ) {
	$SO_MAP  = "";
	$FCPATH  = $INCLUDE;
	$FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/starsim/include";
	$FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/geant321/include";
	$FCPATH .= $main::PATH_SEPARATOR . $env1->{ENV}->{CERN_ROOT} . "/include";
        # $FCPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};

    #} elsif ( $pkg =~ /^Geometry/ ){
    #	$CPPPATH = "#" . $Dir;
    #	if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    #	#$FCPATH  = $INCLUDE;
    #	#$FCPATH .= $main::PATH_SEPARATOR . "#".$Dir;
    #    print "DEBUG $CPPPATH\n";

    } elsif ( $pkg =~ /^xgeometry/ ){
	$LIBS .= " -lStarMagFieldNoDict ";
	#my $libs = "-lStarMagFieldNoDict";	


    } elsif ($pkg =~ m/TGeant3|StarVMCApplication|StVMCMaker/) {
	$CPPPATH =  $env1->{ENV}->{ROOT} . "/" .$env1->{ENV}->{ROOT_LEVEL} . "/geant3/TGeant3"
	    . $main::PATH_SEPARATOR . $CPPPATH;
	#      } elsif ($pkg =~ m/geant3$/) {
	#	$FCPATH =
	#	  "#StarVMC/geant3" .
	#	  $main::PATH_SEPARATOR . "#StarVMC/minicern" .
	#	  $main::PATH_SEPARATOR .  $INCLUDE; #print "FCPATH: $FCPATH\n";
	
    } elsif ($pkg eq 'StarMiniCern') {
	$FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
	$CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};
	$FCPATH = "#StarVMC/minicern" . $main::PATH_SEPARATOR . $INCLUDE;
	$CPPPATH .= $main::PATH_SEPARATOR . "#StarVMC/minicern";
	my @srcC = ();
	foreach my $s (@src) {
	    my $dirL  = File::Basename::dirname($s);
	    my $sdir = File::Basename::basename($dirL);
	    #      print "s = $s dir = $dirL sdir = $sdir\n";
	    #      next if $sdir ne $dirL;
	    next if $s eq 'uset.F' and $STAR_SYS =~ /sun4x_/;
	    next if $sdir eq 'hpxgs'; # hpux macos
	    next if $sdir eq 'sungs'; # sun
	    next if $sdir eq 'allgs';
	    next if $sdir eq 'lnxgs';
	    next if $sdir eq 'lnxppcgs';
	    next if $sdir eq 'qutyinv';
	    next if $sdir eq 'qutyz32';
	    #      print "add $s\n";
	    push @srcC, $s;
	}
	@src = @srcC;
	push @src, "lnxgs/rdmin.F"  if $STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/;
	if ($FC eq 'g77') {
	    $LIBS .= " -lg2c";
	}

    } elsif ($pkg eq 'geant3') { 
	$SO_PKG = "lib" . $SO_PKG; $SO_PKG_lib = $SO_PKG;
	$FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
	$CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};
	$FCPATH = "#StarVMC/geant3" . $main::PATH_SEPARATOR . "#StarVMC/geant3/minicern" . $main::PATH_SEPARATOR . $INCLUDE .
	    $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{CERNLIB}->{INCDIR};
	my @dirs = qw (added gbase gcons geocad ggeom gheisha ghits ghrout ghutils 
		       giface giopa gkine gparal gphys gscan gstrag gtrak matx55 miface 
		       miguti neutron peanut fiface cgpack fluka block comad erdecks erpremc 
		       minicern gdraw TGeant3);
	my $dirs = join '|', @dirs;
	#	if ($STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/) {
	my @srcC = ();
	foreach my $s (@src) {
	    my $dirL = File::Basename::dirname($s);
	    my $sdir = File::Basename::basename($dirL);
	    #      print "s = $s dir = $dirL sdir = $sdir\n";
	    next if $dirL !~ /$dirs/;
	    next if $s eq 'uset.F' and $STAR_SYS =~ /sun4x_/;
	    next if $sdir eq 'hpxgs'; # hpux macos
	    next if $sdir eq 'sungs'; # sun
	    next if $sdir eq 'allgs';
	    next if $sdir eq 'lnxgs';
	    next if $sdir eq 'lnxppcgs';
	    next if $sdir eq 'qutyinv';
	    next if $sdir eq 'qutyz32';
      
	    next if $s =~ /gtrak\/grndm.*\.F/;
	    #      if ($s =~ /gevkev/) {print "==================================";}
	    #      print "add $s\n";
	    push @srcC, $s;
	}
	@src = @srcC;
	push @src, "gcinit.F";
	#  } elsif ( $Dir =~ m/StarVMC/ && $pkg =~ /ecal|Tpc|star/) {
	#    $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/include";


    } elsif ( $Dir =~ m/StarVMC/ && $pkg =~ /ecal|Tpc|star/) {
	$CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/include";
    
    } elsif ( $pkg =~ m/^StBFChain$/ && (! $IsRepo || $IsDotDev) ) {
	my($cmd)="BFCOpt2Html.pl";
	$cmd = "mgr/BFCOpt2Html.pl" if ( -e "mgr/BFCOpt2Html.pl");
	print "\t add documentation for $pkg\n";
	Command $env ["#StRoot/StBFChain/doc/BFC.h"], ("#StRoot/StBFChain/BigFullChain.h"), qq (%CPP            %< > %>);
	Command $env ["#StRoot/StBFChain/doc/BFC2.h"],("#StRoot/StBFChain/BigFullChain.h"), qq (%CPP -D__BFC2__ %< > %>);
	Command $env [("#StRoot/StBFChain/doc/index.html","#StRoot/StBFChain/doc/StBFChain.cxx_doc")],
	("#StRoot/StBFChain/doc/BFC.h","#StRoot/StBFChain/doc/BFC.h", "#StRoot/StBFChain/doc/BFC2.h"),
	qq($cmd);
    }
  
    # mysql and Db related linking separate
    #print "*** $pkg\n";
    if ( $pkg =~ m/^St.*Db/             ||
	 $pkg =~ m/^StStarLogger/       ||
	 $pkg =~ m/^StUCMApi/           ||
	 $pkg =~ m/^StTriggerUtilities/ ||
	 $pkg =~ m/Jevp/
	 ){
	#print "+++ Match +++\n";
	$CPPPATH .= $main::PATH_SEPARATOR .  $env1->{Packages}->{MYSQL}->{INCDIR};
	if ($pkg eq 'StDbLib' || 
	    $pkg =~ m/Jevp/   ) {
	    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{INCDIR};
	    $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{LIBDIR};
	    $LIBS .=  " " . $env1->{Packages}->{XML}->{LIBS};
	    if ($env1->{Packages}->{XML}->{CPP}) {
		$EXTRA_CPPFLAGS .= $env1->{Packages}->{XML}->{CPP};
	    }
	}
	if ($pkg eq 'StTpcDb') {$LIBS .=  " -lStarMagField";}
	print "EXPANDING CPPPATH = $CPPPATH\n" if $param::debug;

    } elsif ( $Dir =~ m/StarVMC/ and $pkg =~ m/StiVMC/) {
	$CPPPATH = "#StarVMC" . $main::PATH_SEPARATOR . $CPPPATH;
	#    print "StarVMC change CPPPATH to $CPPPATH =========\n";
	
    } elsif ( $pkg =~ m/^Vc$/){
	#    $CPPPATH =
	#      "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include";
	#    print "CPPPATH => $CPPPATH\n";
	$CXXFLAGS .= " -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wmultichar -Wtrigraphs -Wpointer-arith -Wcast-align -Wreturn-type -Wno-unused-function -ansi -pedantic -Wno-long-long -Wno-variadic-macros -msse -msse2 -Wshadow -fno-threadsafe-statics";
	$CXXFLAGS .= $env->{Packages}->{Vc}->{CPP};
#	if ($STAR_SYS =~ 'gcc432$') {$CXXFLAGS .= " -DVC_IMPL=Scalar";}
#	else                        {$CXXFLAGS .= " -DVC_IMPL=SSE";}
	my @srcC = ();
	foreach my $s (@src) {
	    #      print "$s\n";
	    #      next if $s eq 'benchmarks/benchmark.cpp';
	    my $dirL = File::Basename::dirname($s);
	    my $sdir = File::Basename::basename($dirL);
	    next if $sdir eq 'examples' or $sdir eq 'benchmarks';
	    push @srcC, $s;
	}
	@src = @srcC;


#    } elsif ( $pkg =~ m/^TBB$/) {
#	$CPPPATH = $INCLUDE 
#	    . $main::PATH_SEPARATOR . "#" . $Dir . "/src";
#	#      "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include" . 
#	#    print "CPPPATH => $CPPPATH\n";
#	$CXXFLAGS .= " -MMD -DTBB_DO_ASSERT -DDO_ITT_NOTIFY -DUSE_PTHREAD -D__TBB_BUILD=1 -Wall -Wno-parentheses";
#
#
    }  elsif ( $pkg =~ m/^TPCCATracker$/) {
        $CPPPATH .=
	  $main::PATH_SEPARATOR . "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/code";
#	  $main::PATH_SEPARATOR . "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/code" .
#	    $main::PATH_SEPARATOR . "#" . $Dir . "/code/KFParticle" .  $main::PATH_SEPARATOR . "#" . $Dir . "/code/Performance";
	#    $CPPPATH .= $main::PATH_SEPARATOR . "#StRoot/TBB/include";
	#    print "CPPPATH => $CPPPATH\n";
	
	my $extraCXXFLAGS = " -DNVALGRIND -DENABLE_VECTORIZATION -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts";
#	my $extraCXXFLAGS = " -DDO_TPCCATRACKER_EFF_PERFORMANCE -DDRAW -DNVALGRIND -DENABLE_VECTORIZATION -DVC_IMPL=SSE -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts";
#	my $extraCXXFLAGS = " -DDO_TPCCATRACKER_EFF_PERFORMANCE -DNVALGRIND -DENABLE_VECTORIZATION -DVC_IMPL=SSE -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts";
#	my $extraCXXFLAGS = " -DNVALGRIND -DENABLE_VECTORIZATION -DVC_IMPL=SSE -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts";
	$extraCXXFLAGS .= " -Wparentheses -Wmultichar -Wtrigraphs -Wpointer-arith -Wcast-align -Wreturn-type -Wno-unused-function";
	$extraCXXFLAGS .= " -ansi -pedantic -Wno-long-long -Wno-variadic-macros -msse -msse2 -Wshadow -fno-threadsafe-statics -DTBB_DO_ASSERT=1";
	if ($STAR_SYS eq 'sl64_gcc447' or $STAR_SYS eq 'sl64_x8664_gcc447') {$extraCXXFLAGS .= " --param large-function-growth=500";}
#	$extraCXXFLAGS .= " -ansi -pedantic -Wno-long-long -Wno-variadic-macros -msse -msse2 -msse3 -mssse3 -msse4.1 -Wshadow -fno-threadsafe-statics -DTBB_DO_ASSERT=1 -ltr";
	#    $extraCXXFLAGS .= " -DUSE_TBB "; # uncomment if you do want to use TBB
	#	$extraCXXFLAGS .= " -DDRAW3"; # uncomment for use TPCCATracker event display
	#	$extraCXXFLAGS .= " -DDO_TPCCATRACKER_EFF_PERFORMANCE"; # uncomment for CA Efficiencies output
	if ($STAR_SYS eq 'sl64_gcc447' or $STAR_SYS eq 'sl64_x8664_gcc447') {$extraCXXFLAGS .= " --param large-function-growth=500";}
	$extraCXXFLAGS .= " -DNODEBUG";
	$CXXFLAGS .= $extraCXXFLAGS;
	$CXXFLAGS .= $env->{Packages}->{Vc}->{CPP};
#	if ($STAR_SYS =~ 'gcc432$' || $STAR_SYS =~ 'gcc445$') {$CXXFLAGS .= " -DVC_IMPL=Scalar";}
#	if ($STAR_SYS =~ 'gcc432$') {$CXXFLAGS .= " -DVC_IMPL=Scalar";}
#	else                        {$CXXFLAGS .= " -DVC_IMPL=SSE"}
	# c++ `root-config --ldflags` -W -Wall -Wimplicit -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wmultichar -Wtrigraphs -Wpointer-arith -Wcast-align -Wreturn-type -Wno-unused-function -ansi -pedantic -Wno-long-long -Wno-variadic-macros -msse -msse2 -Wshadow -fno-threadsafe-statics -Os -DNDEBUG -fPIC -rdynamic -DENABLE_VECTORIZATION `root-config --glibs` -lEG  ./StRoot/TPCCATracker/CA.C -I/star/u/ikulakov/tests/test5/StRoot/TPCCATracker/code -I/afs/rhic.bnl.gov/star/ROOT/5.99.99/.sl53_gcc450/rootdeb/include  -I/star/u/ikulakov/tests/test5/.sl53_gcc450/include  -L/star/u/ikulakov/tests/test5/.sl53_gcc450/lib -lVc -lTPCCATracker -lTBB -o CA
	$LIBS = "-lVc";
	if ($extraCXXFLAGS =~ /USE_TBB/) {$LIBS .= " -lTBB";}
	# stand - alone in .DEV2 only
	if ($env->{STAR_VERSION} eq '.DEV2') {
	  my $libs = "-lTPCCATracker " . $LIBS . $env->{Packages}->{ROOT}->{LIBS} . " -lEG";
	  $envTPCCA = $env->clone('Package' => $pkg,
				  'EXTRA_CXXFLAGS' => $extraCXXFLAGS,# . " -DDRAW", # -DHLTCA_STANDALONE
				  'CPPPATH'  => $CPPPATH,
				  'LIBPATH'  => $LIB . $main::PATH_SEPARATOR .$env->{Packages}->{ROOT}->{LIBDIR},
				  'LIBS'     => $libs,
				  'DEBUG'    => $DEBUG
				 );
	  my @programs = glob($Dir . "/*.C");# print "programs: @programs\n";
	  foreach my $progD (@programs) {
	    my $prog = File::Basename::basename($progD,".C");
	    next if $prog eq 'MakeSettings';
	    Program      $envTPCCA $prog, ($prog . ".C");
	    Install $envTPCCA $BIN, $prog;
	  }
	}
    }
    if ( $pkg =~ m/^Sti$/) {  
      if ($DEBUG =~ /-O/ and $STAR_SYS =~ /gcc432/) { # hack for Sti with gcc432
	$envNoDeb = $env->clone('DEBUG' => '-g');
	for ($i = 0; $i < $#src; $i++) {
	  if ($src[$i] =~ /StiVMCToolKit\.cxx/) {
	    my @objfiles = Objects $envNoDeb ($src[$i]);
	    $src[$i] = $objfiles[0];
	    last;
	  }
	}
      }
    }

    if ( $pkg =~ m/^StiMaker/) {  
      if ($DEBUG =~ /-O/ and $STAR_SYS =~ /gcc432/) { # hack for StiMaker with gcc432
	$DEBUG = "-g";
      }
    }
    
    if ( $#idlM > -1 ) {
	$CPPPATH = $INCLUDE . "/" . $pkg . $main::PATH_SEPARATOR . $CPPPATH;
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    } elsif ( $#idlL > -1 ) {
	$CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables" . $main::PATH_SEPARATOR . "#";;
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    }
    if ( $LIBPKG && $Dir =~ /pams\// || $STAR_SYS =~ /^intel_wnt$/ ) {
	$LIBS .= " -l" . $pkg;    #"lib" . $pkg . "." . $env1->{SUFLIB};
    }
    if ($pkg =~ /^St_base$/) {
	if ( $STAR_SYS =~ /^hp_ux102$/) {
	    $CPPPATH .= $main::PATH_SEPARATOR . "/usr/local/include";
	}
    }

    if (($pkg eq 'StHbtMaker' or $pkg eq 'StMuDSTMaker') and $CC ne 'gcc' and $CC ne 'icc') {
	# fight with __PRETTY_FUNCTION__
	$EXTRA_CPPFLAGS .= " -DDEBUGMESSAGE\\\(x\\\)=\"\"  -DDEBUGMESSAGE1\\\(x\\\)=\"\"  "
	                .  " -DDEBUGMESSAGE2\\\(x\\\)=\"\"  -DDEBUGMESSAGE3\\\(x\\\)=\"\" "
			.  " -DFORCEDDEBUGMESSAGE\\\(x\\\)=\"\"";
    }

    # Many packages depend on the StMuEvent including StrangeMuDst
    #if ( $pkg eq 'StMuDSTMaker'  ){
    #	$ROOTCINT_CPPFLAGS .= " -D__NO_STRANGE_MUDST__ ";
    #	#die;
    #}

    #print "_+_+_+_+_+ $CPPPATH $CXXFLAGS $LIBS $CPPPATH $LIBPATH _+_+_+_+_+\n";

    if ($pkg =~ /^StUCMApi$/ or $pkg =~ /^StStarLogger$/) {
	$EXTRA_CPPFLAGS .=" -D_UCMLOGGER_";
	$CPPPATH .= $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/base"
	         . $main::PATH_SEPARATOR . "StRoot/StUCMApi"
		 . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data"
		 . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/modules";
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
    }

    if ($pkg =~ /^StStarLogger$/) {
	$CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
	$LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{LIBDIR};
	$LIBS    .= " " . $env1->{Packages}->{Logger}->{LIBS};
    }

    if ( $STAR_SYS =~ /^sun4x_5.$/ ) { $CXXFLAGS .= " -ptr" . $obj_dir; }
    if ( $STAR_SYS =~ /kcc$/ ) { $LIBPATH = ""; $LIBS = ""; }
#    print "pkg = $pkg FPPFLAGS = $FPPFLAGS\n";
    my $libpath = $LIBPATH;
    if (! $LIBS) {$libpath = "";}
#  print "CPPPATH => $CPPPATH \tCPPFLAGS => $CPPFLAGS\n";
    #print "DEBUG Passing $ROOTCINT_CPPFLAGS\n";
    $env2 = $env1->clone('Package'  => $pkg,
			 'EXTRA_CPPFLAGS'    => $EXTRA_CPPFLAGS,
			 'CPPPATH'  => $CPPPATH,
			 'CFLAGS'   => $CFLAGS,
			 'CXXFLAGS' => $CXXFLAGS,
			 'FC'       => $FC,
			 'FFLAGS'   => $FFLAGS,
			 'FCPATH'   => $FCPATH,
			 'FEXTEND'  => $FEXTEND,
			 'FPPFLAGS' => $FPPFLAGS,
			 'CPPFLAGS' => $CPPFLAGS,
			 'FCCOM'    => $FCCOM,
			 'LIBS'     => $LIBS,
			 'SOFLAGS'  => $SOFLAGS,
			 'LIBPATH'  => $libpath,
			 'ObjDir'   => $obj_dir,
			 'DEBUG'    => $DEBUG,
			 'FDEBUG'   => $FDEBUG
			 );

    #print "DEBUG ".$env2->{ROOTCINT_CPPFLAGS}."\n";
    # 'ROOTCINT_CPPFLAGS' => $ROOTCINT_CPPFLAGS,

#    bless $env2, "cons"; #?
#  print "env2 : CPPPATH => $env2->{CPPPATH} \tCPPFLAGS => $env2->{CPPFLAGS}\n";
#    if ($CC eq 'icc') {$EXTRA_CPPFLAGS .= " " . "-DR__NO_CLASS_TEMPLATE_SPECIALIZATION";}
    my $Cint_CPPPATH = $CPPPATH . $main::PATH_SEPARATOR . "#";
#  print "Cint_CPPPATH => $Cint_CPPPATH\n";
    $envCint = $env2->clone('DEBUG' => $env2->{NOOPT},
			    'CPPPATH'  => $Cint_CPPPATH,
			    'CPPFLAGS' => $CPPFLAGS,
			    'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS);

    print "LIBPATH = |", $env2->{LIBPATH}, "|\n LIBS = |", $env2->{LIBS},
    "|\n CPPPATH = |", $env2->{CPPPATH}, "|\n" if $param::debug;

    print "LINKMODULECOM |", $env2->{LINKMODULECOM}, "|\n" if $param::debug;
    my $cscanner = find scan::cpp( $env2->{_cwd}, $env2->{CPPPATH} );
    my @cpps = split /$main::PATH_SEPARATOR/, $env2->{CPPPATH};
    #  print "cpps => @cpps\n";# if $param::debug;
    #print "cpps => @cpps\n"; 
    my $ROOTCINT_CPP = "";
    my $STIC_CPP     = "";

    #  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
    foreach my $cpp( $Dir, @cpps ) {
	if ( $cpp =~ /cern/ || $cpp eq "/usr/include" || $cpp =~ /ospace/ ||
	     $cpp =~ /openwin/ ){
	    next;
	}
	if ($ROOTCINT_CPP) { $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $ROOTCINT_CPP = $cpp; }
	if ( $cpp =~ /ROOT/ ) {next}
	if ($STIC_CPP) { $STIC_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $STIC_CPP = $cpp; }
    }
    #  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
    $cscanner = find scan::cpp( $env2->{_cwd}, $ROOTCINT_CPP );
    print "ROOTCINT_CPP = $ROOTCINT_CPP\n" if $param::debug;
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env2);
    if ($env2->{EXTRA_CPPFLAGS}) {
	$ROOTCINT_CPPPATH .= " " . $env2->{EXTRA_CPPFLAGS}; # Requested By Frank Laue
    }
    print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n" if $param::debug;
    $cscanner = find scan::cpp( $env2->{_cwd}, $STIC_CPP );
    my $STIC_CPPPATH =
	$cscanner->iflags($env2);    # print "STIC_CPPPATH  = $STIC_CPPPATH\n";
    my $DIR = Cwd::cwd();
    print "DIR = $DIR\n" if $param::debug;
    my $line;
    my @Defs = (); 

	
    if ( $#idlM > -1 ) {
	my $include = $INCLUDE . "/" . $pkg;
	print "include = $include\n" if $param::debug;
	foreach my $idl(@idlM) {
	    my $stem = File::Basename::basename( $idl, ".idl" );
	    print "idl = $idl  stem = $stem\n" if $param::debug;
	    my $idm  = $stem . ".idl";
	    my $idMM = $DIR . "/" . $Dir . "/" . $idl;
	    print "idMM = $idMM\n" if $param::debug;
	    my $idM = "#" . $Dir . "/" . $idl;
	    print "idM = $idM\n" if $param::debug;
	    my @idlS = ($idM);
	    my $modh = $INCLUDE . "/" . $stem . ".h";
	    my $modi = $INCLUDE . "/" . $stem . ".inc";
	    my $modH = $include . "/" . "St_" . $stem . "_Module.h";
	    print "modH = $modH\n" if $param::debug;
	    my $modC = "St_" . $stem . "_Module.cxx";
	    print "modC = $modC\n" if $param::debug;
    
	    if ( $STAR_SYS !~ /^intel_wnt$/ ) {
		$env2->{ENV}->{STICTMP} = "/tmp/$<$$";
		my $stic_cmd =
		    "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
		    "/bin/mkdir -m 777 \$STICTMP && cd \$STICTMP && ".
		    "/bin/cp %<:a . && $STIC -s -r $STIC_CPPPATH -q %<:f && ".
		    "(/bin/mv %>:f %>:a ; cd /tmp  &&  /bin/rm -rf \$STICTMP)";
		Command $env2 [$modh], @idlS, qq($stic_cmd);
		Command $env2 [$modi], @idlS, qq($stic_cmd);
		Command $env2 [$modH], @idlS, qq($stic_cmd);
		Command $env2 [$modC], @idlS, qq($stic_cmd);
	    }
	    my @objmod = ($modC);
	    print "Install @objmod in $ObjDir\n" if $param::debug;
	    push @src, $modC;
	    print "src + $mod: @src\n" if $param::debug;
	    push @Defs, $modH;
	}
  
    } else {
	foreach $h(@h_files) {#print "h: $h\n";
	    if ( $h =~ /LinkDef/) { push @LinkDefs, $h;}
	    if ( $h =~ /LinkDef/ || $h =~ /Stypes/ ) { push @Defs, $h; next; }
	    my $hh = $Dir . "/" . $h;
	    if ( -r $hh ) {
		open( In, $hh ) or die "Can't open $hh";
		my $classDefFlag = 1;
		my $qtFlag       = 1;
		while ( $line = <In> ) {
		    if ( ( $line =~ /ClassDef/ || $line =~ /StCollectionDef/) ) {
			push @Defs, $h; # print "$h <==========\n";
			$classDefFlag = 0;
		    } elsif ( $line =~ /Q_OBJECT/ && defined($env1->{Packages}->{QT}->{BINDIR}) && $qtFlag ) {
	  
			push @QtDefs, $h; print "QtDefs from Q_OBJECT  @QtDefs\n" if $param::debug;
			$qtFlag = 0;
		    }
		    next if ( $classDefFlag + $qtFlag == 0 );
		}
		close(In);
      
	    } else {
      
		foreach my $Rep(@Repo) {
		    my $RepDir = $Rep . "/" . $Dir;
		    print "RepDir = $RepDir\n" if $param::debug;
		    if ( -d $RepDir ) {
			my $hh = $RepDir . "/" . $h;
			if ( -r $hh ) {
			    open( In, $hh ) or die "Can't open $hh";
	    
			    while ( $line = <In> ) {
				if ( $line =~ /ClassDef/
				     || $line =~ /StCollectionDef/ )
				{
				    push @Defs, $h;
				    goto ENDL;
				}
			    }
			    close(In);
			}
		    }
		}
	    }
	  ENDL:
	}
    }

    if ( $#Defs > -1 ){  # && ! $OnlinePackage ) {
	my @CintFiles = ( $PKG . "_Cint.cxx", $PKG . "_Cint.h", "LinkDef.h" );
	@Defs = script::sortu(@Defs);
	my @defs = ();
	foreach my $def(@Defs) {    #print "def = $def OBJ = $OBJ\n";
	    if ( $def =~ /^\#/ ) { push @defs, $def; }
	    else { push @defs, "#" . $Dir . "/" . $def; }
	}
	foreach my $def (@LinkDefs) {
	    open (In, $Dir . "/" . $def) or die "Can't open $def";
	    while (my $line = <In>) {
		if (($line  =~ /^\/\/IncFile *=/))	{
		    my @words = split /(=)/, $line;
		    chomp(@words[2]);
		    my $h = $words[2];
		    # remove the quotation surrounding the file name if any
		    $h =~ s/^\"// ; $h =~ s/\"$// ;
		    if (! -r $Dir . "/" . $h) {
			$h = "#StRoot/" . $h;
		    }
		    print "Add $Dir ========= $h \n" if $param::debug;
		    if (! -r $h) {push @defs, $h;}
		}
	    }
	    close(in);
	}
	Depends $env2 [@CintFiles], @h_files;
	Depends $env2 [@CintFiles], ($env2->{Packages}->{ROOT}->{ROOTCINT});
  
	my $RCINTPL;
  
	# use local if available
	if ( -e "mgr/RootCint.pl") {
	    $RCINTPL = "mgr/RootCint.pl";
	} else {
	    $RCINTPL = "RootCint.pl";
	}
	Command $env2 [@CintFiles], @defs,
	qq($RCINTPL "%>" "%<" "$ROOTCINT_CPPPATH" );
  
	@LinkDefs = ("LinkDef.h");
	my @objfiles = Objects $envCint ($CintFiles[0]);
	#	push @src, $CintFiles[0];
	push @src, @objfiles[0];
	print "+==========add cint $CintFiles[0]\n" if $param::debug;
	#die ;
    }

    if ( $#QtDefs > -1 ) {
	my $mocheaders = join $main::PATH_SEPARATOR, @QtDefs;
	my @mocs = script::MakeMoc( $env2, $pkg, $done, $mocheaders);
	print "mocheaders: $mocheaders \tmocs: @mocs\n" if $param::debug;
	foreach $m(@mocs) { push @src, $m;}
    }
}


#____________________________________Tables____________________________
# Tables:
my @sourcesT = ();

if ( $#idlL > -1 ) {
  my @idlT = ();
  my $objT = $OBJ . "/pams/tables";
  ( my $objT_dir = $objT ) =~ s/^\#//g;
  print "objT_dir = $objT_dir\n" if $param::debug;
  my $includeT = $INCLUDE . "/tables";
  print "includeT = $includeT\n" if $param::debug;
  
  foreach my $idl(@idlL) {
    print "$idl\n" if $param::debug;
    my $IDL =
      "#" . $Dir . "/" . $idl;    # print "i=",$i++," idl = $idl IDL=$IDL\n";
    my $stem = File::Basename::basename( $IDL, ".idl" );
    print "stem = $stem\n" if $param::debug;
    my $idlt = $includeT . "/" . File::Basename::basename($idl);
    push @idlT, $IDL;
  }
  print "idlT = @idlT\n" if $param::debug;
  
  if ( $#idlT > -1 ) {
    $PKGT    = "lib" . $pkg . "_Tables";
    $SO_PKGT = $PKGT . "." . $env1->{SUFSOLIB};
    $SO_MAPT = $PKGT . ".map";
    print "SO_PKGT = $SO_PKGT\n" if $param::debug;
    my $LIBPKGT = $PKGT . "." . $env1->{SUFLIB};
    
    if ( $Dir =~ /StRoot\//  ||  $Dir =~ /OnlTools\//) {
      $SO_PKGT = $SO_PKG;
      $SO_MAPT = $SO_MAP;
      $LIBPKGT = $LIBPKG;
    } else {
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir,
	      $PKGT )
	unless ($param::quiet);
    }
    #        Install $env $INCLUDE, @idlT;  # print "Install $env $INCLUDE, @idlT\n";
    
    #___________________________________
    my $ROOTCINT_CPP =
      $INCLUDE . $main::PATH_SEPARATOR . $INCLUDE . "/tables";
    $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $env1->{ENV}->{ROOTSRC};
    
    my $tobj_dir = $obj_dir . "/Tables";
    $CPPPATH = "";
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    $CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables";
    #    if ($#QtDefs >= 0) {$CPPPATH .= $main::PATH_SEPARATOR . $env->{ENV}->{QTDIR} . "/include";}
    $env3 = $env1->clone('DEBUG'   => $env1->{NOOPT},
			 'CPPPATH' => $CPPPATH,
			 'ObjDir'  => $tobj_dir,
			 'LIBPATH' => ''
			);
    my $cscanner =
      find scan::cpp( $env1->{_cwd}, $ROOTCINT_CPP );
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env3); #print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n"; die;
    foreach my $idll(@idlT) {
      my $stem = File::Basename::basename( $idll, ".idl" );
      print "stem = $stem; idll: $idll\n" if $param::debug;
      my $dir = File::Basename::dirname($idll);
      print "dir = $dir\n" if $param::debug;
      my $idl  = File::Basename::basename($idll);
      my $idlh = $INCLUDE . "/" . $stem . ".h";
      print "idlh: $idlh\n" if $param::debug;
      my $idli = $INCLUDE . "/" . $stem . ".inc";
      print "idli: $idli\n" if $param::debug;
      my $idlH = $includeT . "/St_" . $stem . "_Table.h";
      print "idlH: $idlH\n" if $param::debug;
      my $idlC = "St_" . $stem . "_Table.cxx";
      print "idlC: $idlC\n" if $param::debug;
      my $LinkDef = $stem . "LinkDef.h";
      push @LinkDefsT, $LinkDef;
      print "LinkDef = $LinkDef\n" if $param::debug;
      my $idlCintH = "St_" . $stem . "_TableCint.h";
      print "idlCintH = $idlCintH\n" if $param::debug;
      my $idlCintC = "St_" . $stem . "_TableCint.cxx";
      print "idlCintC = $idlCintC\n" if $param::debug;
      ( my $IDL = $idll ) =~ s/^\#//g;
      print "IDL = $IDL\n" if $param::debug;
      
      if ( -r $IDL ) {
	my @Deps = ($idll);
	print "Deps: $Deps[0]\n" if $param::debug;
	if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	  $env3->{ENV}->{STICTMP} = "/tmp/$<$$";
	  my $stic_cmd  =
	    "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
	    "/bin/mkdir -p -m 777 \$STICTMP && cd \$STICTMP && ".
	    "/bin/cp %<:a . && $STIC -q %<:f && ".
	    "(/bin/mv %>:f %>:a ; cd /tmp ; /bin/rm -rf \$STICTMP)";

	  Command $env3 [$idlh], @Deps, qq ($stic_cmd);
	  Command $env3 [$idli], @Deps, qq ($stic_cmd);
	  push @Deps, $idlh;
	  Command $env3 [$idlH], @Deps, qq (ConstructTable.pl %1 %>);
	  push @Deps, $idlH;
	  Command $env3 [$idlC], @Deps, qq (ConstructTable.pl %1 %>);
	  Command $env3 [$LinkDef], @Deps,
	    qq (ConstructTable.pl %1 %>);
	}
	@Deps = ();
	push @Deps, $idlH;
	push @Deps, $LinkDef;
	push @LinkDefs, $LinkDef;
	push @Deps, $idlh;
	push @Deps, $idli;
	
	if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	  Command $env3 [ ($idlCintC , $idlCintH) ], @Deps,
	    qq (rootcint -f %> -c $ROOTCINT_CPPPATH -D__ROOT__ %1 %2);
	}
	push @Deps, $idlCintC;
	push @Deps, $idlCintH;
	push @Deps, $idlC;
	my @src = ( $idlC, $idlCintH, $idlCintC );
	#               Install $env3 $objT, @src;
      }
      my $s;
      
      if ( $SO_PKGT eq $SO_PKG ) {
	push @src,$idlC;
	push @src, $idlCintC;
      } else {
	push @sourcesT, $idlC;
	push @sourcesT, $idlCintC;
      }
    }
    print "sourcesT = @sourcesT\n" if $param::debug;
  }
}

if ( $#sourcesT > -1 ) {
  script::Keep $SO_PKGT;
  LinkedModule $env3 $SO_PKGT, @sourcesT;
  Install $env3 $LIB, $SO_PKGT;
  if ($env3->{Packages}->{ROOT}->{RLIBMAP} and $SO_MAPT and $#LinkDefsT > -1) {
    Command $env3 [ $SO_MAPT ], ($LIB . "/" . $SO_PKGT, @LinkDefsT),
      qq($env3->{Packages}->{ROOT}->{RLIBMAP} -r %> -l %1 -c %<);
    Install $env3 $LIB, $SO_MAPT;
  }
}

if ( $#src > -1 ) {
  my  $envPlain = $env2;
  printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $PKG )
    unless ($param::quiet);
  if ($LIBPKG) {
    Library $env2 $LIBPKG, @src;
    Install $env2 $LIB,    $LIBPKG;
    print "Install $env2 $LIB, $LIBPKG\n" if $param::debug;
    if ($SO_PKG) {
      my $libpkg = $LIB . "/" . File::Basename::basename($LIBPKG);
      Depends $env2 $SO_PKG, $libpkg;
    }
  }
  # print "-=-=-=-=- SO_PKG = $SO_PKG $pkg -=-=-=-=-=-\n";
  # print "SO_PKG = $SO_PKG\n";
  if ($SO_PKG) {
    script::Keep $SO_PKG;
    if ($pkg =~ m/StarMagField/) {
#      my @o = Objects $env2 (@src);
#      @src = @o;
      $envNoROOT = $env->clone('CPPFLAGS' => "", 'SUFOBJ'   => "NoDict.o",);
      @PlainObj =  Objects $envNoROOT(qw(StarMagField.cxx));
#      foreach my $s (@o) {
#	if ($s !~ /Cint/) {push @PlainObj, $s;}
#      }
      $SO_PKG_PLAIN = $pkg . "NoDict";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
    }
    if ($pkg =~ m/^geometry/ ){
      $SO_PKG_PLAIN = $pkg . "NoField";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
      my @ss = ();
      foreach my $s (@src) {
	if ($s !~ /mfldgeo/ ) {push @ss, $s}
      }
      @src = @ss;
      @PlainObj = Objects $env2 (@src);
      @src = @PlainObj;
      #      print "PlainObj = @PlainObj\n";
      my $libs = "-lStarMagFieldNoDict";
      $envg = $env2->clone('LIBPATH'  => $LIB, 'LIBS'     => $libs);
      $libs =~ s/-l/lib/;
      $libs = $LIB . "/" . $libs;
      $libs .= "." . $env2->{SUFSOLIB};
      Depends $envg, [($SO_PKG)], ($libs); #print "libs = $libs\n";
      $env2 = $envg;
    }
#________________________________________________________________________________
    if ($pkg =~ m/^StGenericVertexMaker$/) { # For Stv no Sti 
      $SO_PKG_PLAIN = $pkg . "NoSti";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
      @PlainObj = ();
      @Obj = Objects $env2  (@src);
#      print "$#src => @src \n";
#      print "$#Obj => @Obj \n";
      foreach my $o (@Obj) {
#	print "o ++++++> $o\n";
	if ($o =~ m/\/StiPPVertex\//) {next;}
	push @PlainObj, $o;
      }
      @src = @Obj;
#      print "$#src => @src \n";
#      print "$#PlainObj => @PlainObj \n";
    }
#    if ($pkg =~ m/^StMuDSTMaker$/) { # MuDst without Strange MuDst
#	$SO_PKG_PLAIN = $pkg . "NoStrange";
#	printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
#	$SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
#	$envPlain = $env2->clone('SUFOBJ'   => "NoStrange.o",
#				 'CXXFLAGS' => $CXXFLAGS . " -D__NO_STRANGE_MUDST__");
#	@PlainObj = @src;
##	push @PlainObj, "StMuDSTMaker_Cint.cxx";
#    }
#________________________________________________________________________________
#    if ($pkg =~ m/^StMuDSTMaker$/) { # MuDst without makers
#      $SO_PKG_PLAIN = "StMuDst";
#      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
#      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
#      @PlainObj = ();
#      @Obj = Objects $env2  (@src);
##      print "$#src => @src \n";
##      print "$#Obj => @Obj \n";
#      foreach my $o (@Obj) {
##	print "o ++++++> $o\n";
#	if ($o =~ m/EZTREE/) {next;}
#	my $oo = File::Basename::basename($o); 
#	if ($oo =~ m/Maker/) {next;} 
#	if ($oo =~ m/SchedulerExample/) {next;}
#	if ($oo =~ m/Cint/) {next;}
#	push @PlainObj, $o;
#      }
#      @src = @Obj;
##      print "$#src => @src \n";
##      print "$#PlainObj => @PlainObj \n";
#    }
    LinkedModule $env2 $SO_PKG, @src;
    Install $env2 $LIB,         $SO_PKG;
    my $lib = $LIB . "/" . $SO_PKG;
    if ($SO_PKG ne $SO_PKG_lib) {
      $lib = $LIB . "/" . $SO_PKG_lib;
      InstallAs $env2 $lib, $SO_PKG;
    }
    #    print "SO_PKG = $SO_PKG SO_PKG_PLAIN = $SO_PKG_PLAIN $#PlainObj PlainObj = @PlainObj\n";
    if ($SO_PKG ne $SO_PKG_PLAIN and $#PlainObj > -1) {#print "============================\n";
      script::Keep $SO_PKG_PLAIN;
      LinkedModule $envPlain $SO_PKG_PLAIN, @PlainObj;
      Install $envPlain $LIB,         $SO_PKG_PLAIN;
      if ($SO_PKG_PLAIN !~ /^lib/) {
	my $lib = $LIB . "/lib" . $SO_PKG_PLAIN;
	InstallAs $envPlain $lib, $SO_PKG_PLAIN;
      }
    }
    if ($pkg eq "RTS") {
      my $cppflags = "-DRTS_PROJECT_STAR -DTPXREADER -DRTS_LITTLE_ENDIAN";
      my $cpppath  = $main::PATH_SEPARATOR . "#StRoot/RTS/include"
	. $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include"
	  . $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC"
	    . $main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS"
	      . $main::PATH_SEPARATOR . "#StRoot/RTS/src"
		. $main::PATH_SEPARATOR . "StRoot/RTS/src/EVP_READER";
##else /* ____MAC_____ */
#		. $main::PATH_SEPARATOR . "StRoot/RTS/src/EVP_READER"
#		  . $main::PATH_SEPARATOR . $env->{ENV}->{ROOTSYS} . "/include";
##endif /* ____MAC_____ */
      $envRTS = $env2->clone('Package'  => $pkg,
			     'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS,
			     'CPPPATH'  => $cpppath,
			     'CPPFLAGS' => $cppflags,
			     'LIBPATH'  => $LIB,
			     'LIBS'     => "-lRTS"
			    );
      my @programs = glob "./StRoot/RTS/src/RTS_EXAMPLE/*.C"; #("RTS_EX/Reader","EVP_READER/special","RTS_EXAMPLE/daqFileChopper");
      foreach my $progD (@programs) {
	my $prog = File::Basename::basename($progD,".C");
	Program      $envRTS $prog, ("src/RTS_EXAMPLE/" . $prog . ".C");
	Install $envRTS $BIN, $prog;
      }
    }
  }
}
#_________________________________________________________________________________
sub script::MakeMoc {
  my $envQt  = shift;
  my $pkg  = shift;
  my $done = shift;
  my @includes = split $main::PATH_SEPARATOR,shift;
  my $Dir  = $envQt->{Dir};
  my $ROOTCINTFLAGS = "-I" . $Dir . "/inc";
  my @src      = ();
  my @Defs     = ();
  my $PLATFORM = $envQt->{PLATFORM};
  foreach my $header (@includes) {
    my $dd = $d;
    my $G__name = "moc_" . $header;
    $G__name =~ s/\.h$/\.cxx/;
    my $moc = $envQt->{Packages}->{QT}->{BINDIR} . "/moc";
    # print "moc is $moc\n";  
    Command $envQt ($G__name), ($header), qq($moc -o %>  %<);
    push @src, $G__name;
    print "+==========add moc file: $G__name\n" if $param::debug;
  }
  return @src;
}
#____________________________________________________________
sub script::alpha_arcom { #
  my ($lib,$src) = @_;
  my $input = "input" . File::Basename::dirname($lib);
  open (OUTPUT, ">$input") or die "Can't open $input\n";
  print OUTPUT $src;
  close(OUTPUT);
  my $cmd = "ar $lib -input $input'; ranlib $lib"; print "$cmd\n";
  my $flag = `$cmd`; if ($?) {exit 2;}
  return 1;
}
#_________________________________________________________________________________


