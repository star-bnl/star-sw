// COMMON /TRCOM3/ 
static TRMatrix A(5,5);
static TRMatrix B(5,5);
static TRSymMatrix S(5);
static TVector3 TN;
static TRVector T(5);
static Double_t cosl, sinl, cosp, sinp, cosl1;
static Int_t    new = 0;
static const Double_t DELHP6 = 300.;
static const Double_t CFACT8 = 2.997925e-4;
static const Double_t DELFI6 = 0.1;
//________________________________________________________________________________
Int_t StGeanePropagator::Trprfn(Double_t *x1,Double_t *p1,Double_t *h1,
				Double_t *x2,Double_t *p2,Double_t *h2,
				Double_t  Ch,Double_t  xL,Double_t *r,
				Int_t Mvar,Int_t Iflag,Int_t Itran) {
  TVector3 X1(x1);  TVector3 P1(p1);
  TVector3 X2(x2);  TVector3 P2(p2);
  TVector3 H1(h1);  TVector3 H2(h2);
  TRSymMatrix R(5,r);
  return Trprfn(X1,P1,H1,X2,P2,H2,Ch,xL,R,Mvar,Iflag,Itran);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trsxsp(const TVector3 &P1,const TVector3 &H1, Double_t Ch, TRSymMatrix &R) {
  //  transform error matrix from external to internal variables;
  if (P1(0) == 0.) return 4;
  pa1=P1.Mag();
  if (pa1 == 0.) return 2;
  TVector3 PS(1./pa1,P1(1)/P1(0),P1(2)/P1(0));
  Double_t spx=1.;
  if (P1(0)  < 0.) spx=-1.;
  TVector3 PC;
  return Trspsc(PS,R,PC,R,H1,Ch,spx);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trprfn(const TVector3 &X1,const TVector3 &P1,const const TVector3 &H1,
				const TVector3 &X2,const TVector3 &P2,const TVector3 &H2,
				Double_t Ch, Double_t  xL,TRSymMatrix &R,
				Int_t Mvar,Int_t Iflag,Int_t Itran) {
  /*________________________________________________________________________________
   *     SUBR. TRPRFN(X1,P1,H1,X2,P2,H2,ch,XL,*R*,MVAR,IFLAG,ITRAN,IERR*)
   *     Origin W.Wittek    EMCSW/81/18
   *     Finite step length case coded by V.Innocente ( Feb. 88 )
   *     code improved:                   V.Innocente ( April. 90 )
   *                   inline code replaces external function
   *     code improved:                   V.Innocente ( January 91 )
   *                   effect of energy loss added
   * *** Error propagation along a particle trajectory in a magnetic field
   *     routine assumes that in the interval (x1,x2) the quantities 1/p
   *     And (Hx,Hy,Hz) Are Constant.
   *
   * *** Iflag  =  -1   Initialization, transformation of error matrix from
   *                    external to sc variables
   *            =   0   Error propagation from X1 to X2
   *            =   1   Transformation Of Error Matrix From Sc To
   *                    External Variables
   *     Itran          Used For Iflag = 0 Or 1 Only
   *            =   0   Transformation Matrix Is Updated ,But Error Matrix Is Not
   *                    Transformed
   *           =    1   Transf. Matrix Is Updated  And Error Matrix Is Transformed
   *     Mvar           Specifies Type Of External Variables
   *            =   0   ( 1/P,Lambda,Phi,Yt, Zt ;   Sc   )
   *            =   1   ( 1/P,  Y',  Z',  Y,  Z ; Spline )
   * *** X1, P1, H1     X,Y,Z Components Of Position, Momentum And Magnetic   Input
   *                    Field Vector/Gradient At Starting Point Of Interval
   *     X2, P2, H2     ......  At End Point Of Interval                      Input
   *     Ch             Charge Of Particle                                    Input
   *     xL             Pathlength From X1 To X2   ( Negative If Opposite
   *                    To Actual Movement Of Particle )                      Input
   *     R              Error Matrix  (Triangle)                       Input/Output
   *     B              5 * 5 Transformation Matrix For Errors In
   *                    Sc Variables                                         Output
   * *** Ierr   =  1    Illegal Value Of Mvar                                Output
   *               2    Momentum Is Zero
   *               3    H*Alfa/P At X1 And X2 Differ Too Much
   *               4    Particle Moves In Z - Direction
   *
   ________________________________________________________________________________*/
  static Int_t INIT = 0;
  if (Iflag < 0 ) {// 10, 20, 80
    //  transform error matrix from external to internal variables;
    new=1;
    if (Mvar == 1) return Trsxsp(P1,H1,Ch, R);
    else           return 1;
  }  
  if (Iflag == 0) {
    //  error propagation on a helix assuming sc variables
    pa1=P1.Mag();
    pa2=P2.Mag();
    if (pa1*pa2 == 0.) return 2;
    Double_t pm1 = 1./pa1;
    Double_t pm2 =1./pa2;
    Double_t dpm = pm2 - pm1;
    TVector3 T1 = pm1*P1;
    TVector3 T2 = pm2*P2;
    sinl = T2(2);
    Double_t sinl0=T1[2];
    cosl = TMath::Sqrt(1 - sinl*sinl);
    if (cosl == 0.) return 4;
    cosl1=1./cosl;
    cosl0=TMath::Sqrt(TMath::Abs(1.-sinl0*sinl0));
    //  define transformation matrix between X1 and X2 for
    //  neutral particle or fieldfree region
    A = TRMatrix(TRArray::kUnit,5);
    A(3,2)=xL*cosl;
    A(4,1)=xL;
    if (Ch != 0.) {
      Double_t ha1 = H1.Mag();
      Double_t ha2 = H2.Mag();
      Double_t ham1=ha1*pm1;
      Double_t ham2 = ha2*pm2;
      Double_t hamx = TMath::Max(ham1,ham2);
      if (hamx == 0.) {
	//  check whether h*alfa/p is too different at x1 and x2
	Double_t gam = 0;
	if (ha2 != 0.) gam=(H2*T2)/ha2;
	else           gam=(H1*T1)/ha1;
	Double_t alfa2 = 1. - gam*gam;
	TVector3 DH2 = pm1*H1 - pm2*H2;
	Double_t dh2 = DH2.Mag();
	if (dh2*alfa2 > DELHP6*DELHP6) return 3;
	//  define average magnetic field and gradient
	Double_t pm12=(pm1+pm2)*0.5;
	Double_t p12=1./(2.*pm12);
	TVector3 HN = (pm1*H1 + pm2*H2)*Ch*CFACT8;
	Double_t hm = HN.Mag();
	HN = HN.Unit();
	Double_t pav = 0.5*(pa1+pa2);
	Double_t q = - hm/pav;
	Double_t theta = q*xL;
	Double_t sint = TMath::Sin(theta);
	Double_t cost = TMath::Cos(theta);
	Double_t gamma = HN*T2;
	TVector3 AN2 = HN.Cross(T2);
	Double_t au = 1./T1.Perp();
	TVector3 UU1(-T1(1),T1(0),0);
	TVector3 U1 = UU1.Unit();
	TVector3 V1 = U1.Cross(T1);
	TVector3 UU2(-T2(1),T2(0),0);
	TVector3 U2 = UU2.Unit();
	TVector3 V2 = U2.Cross(T2);
	TVector3 DX = X1 - X2;
	//  complete transformation matrix between errors at X1 and X2
	//  field gradient perpendicular to track is presently not
	//  taken into account
	Double_t qp  = q*pav;
	Double_t anv = - HN*U2;
	Double_t anu = HN*V2;
	Double_t omcost = 1.-cost;
	Double_t tmsint = theta-sint;
	
	TVector3 HU1 = U1.Cross(HN);
	TVector3 HV1 = HN.Cross(V1);
	Double_t dDdD[25] = {
	  1     -dpm*pav*(1.+T2*DX/xL)+2.*dpm*pav                              // 1/p                                   A(1,1)
	  ,      -dpm/theta*( tmsint*gamma*HN*V1 + sint*V1*T2 + omcost*HV1*T2) //	        			A(1,2)
	  ,-cosl0*dpm/theta*( tmsint*gamma*HN*U1 + sint*U1*T2 + omcost*HU1*T2) //					A(1,3)
	  ,      -dpm/xL*U1*T2 						       //  			                A(1,4)
	  ,      -dpm/xL*V1*T2 						       // 				        A(1,5)
	  , -qp*anv*T2*DX *(1.+dpm*pav) 	  			       // Lambda				A(2,1)
	  ,cost*V1*V2 + sint*HV1*V2 + omcost*HN*V1*(HN*V2) + anv*( -sint*V1*T2 +omcost*(V1*AN2 - tmsint*gamma*HN*V1)) //A(2,2)
	  ,cost*U1*V2 + sint*HU1*V2 + omcost*HN*U1*(HN*V2) + anv*( -sint*U1*T2 +omcost*(U1*AN2 - tmsint*gamma*HN*U1)) //A(2,3)
	  ,cosl0*A(2,3) 						       //					A(2,3)
	  ,-q*anv*U1*T2 						       // 					A(2,4)
	  ,-q*anv*V1*T2 						       // 					A(2,5)
	  ,-qp*anu*T2*DX*cosl1*(1.+dpm*pav) 				       // Phi					A(3,1)
	  ,cost*V1*U2 + sint*HV1*U2 + omcost*HN*V1*(HN*U2) + anu*( -sint*V1*T2 + omcost*(V1*AN2 - tmsint*gamma*HN*V1))//A(3,2)
	  ,cosl1*A(3,2) 						       //       				A(3,2)
	  ,cost*U1*U2 + sint*HU1*U2 + omcost*HN*U1*(HN*U2) + anu*( -sint*U1*T2 + omcost*(U1*AN2 - tmsint*gamma*HN*U1))//A(3,3)
	  ,cosl1*cosl0*A(3,3) 						       //  				        A(3,3)
	  ,-q*anu*U1*T2*cosl1 						       // 				        A(3,4)
	  ,-q*anu*V1*T2*cosl1 						       // 				        A(3,5)
	  ,pav*U2*DX*(1.+dpm*pav) 					       // Yt					A(4,1)
	  ,(   sint*V1*U2 + omcost*HV1*U2 + tmsint*(HN*U2)*HN*V1)/q 	       //					A(4,2)
	  ,(   sint*U1*U2 + omcost*HU1*U2 + tmsint*(HN*U2)*HN*U1)*cosl0/q      //					A(3,2)
	  ,U1*U2 							       //					A(4,4)
	  ,V1*U2 							       // 					A(4,5)
	   ,pav*V2*DX*(1.+dpm*pav) 					       // Zt					A(5,1)
	  ,(   sint*V1*V2 + omcost*HV1*V2 + tmsint*(HN*V2)*HN*V1)/q            //			     		A(4,1)
	  ,(   sint*U1*V2 + omcost*HU1*V2 + tmsint*(HN*V2)*HN*U1)*cosl0/q      //					A(5,3)
	  ,U1*V2   							       //					A(5,4)
	  ,V1*V2}; 							       // 					A(5,5)
	A = TRMatrix(5,5,dDdD);
      }
    }
    //  new = 0  transformation matrix is updated
    //        1  transformation matrix is initialized
    if (new == 0) {
      new=0;
      B = A;
    } else {
      B = TRMatrix(A,TRArray::kAxB,B);
    }
  }
  //  transform error matrix
  if (Itran != 0) S = TRSymMatrix(B,TRArray::kATxSxA,S);
  if (Iflag<= 0) return 0;
  //  Transform error matrix from internal to external variables;
  new=1;
  if (Mvar == 1) {
    TVector3 PC(pm2,P2.Phi(),TMath::Pi()/2 - P2.Theta());
    return Trscsp(PC,R,PS,R,H2,Ch,spx);
  }
  if (Mvar != 0) return 1;
  return 0;
}
 
//________________________________________________________________________________
Int_t StGeanePropagator::Trprop(Double_t *x1,Double_t *p1,Double_t *h1,
				Double_t *x2,Double_t *p2,Double_t *h2,
				Double_t  Ch,Double_t  xL,Double_t *r,
				Int_t Mvar,Int_t Iflag,Int_t Itran) {
  TVector3 X1(x1);  TVector3 P1(p1);
  TVector3 X2(x2);  TVector3 P2(p2);
  TVector3 H1(h1);  TVector3 H2(h2);
  TRSymMatrix R(5,r);
  return Trprop(X1,P1,H1,X2,P2,H2,Ch,xL,R,Mvar,Iflag,Itran);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trprop(const TVector3 &X1,const TVector3 &P1,const TVector3 &H1,
				const TVector3 &X2,const TVector3 &P2,const TVector3 &H2,
				Double_t Ch,Double_t xL,RSymMatrix &R,
				Int_t Mvar,Int_t Iflag,Int_t Itran) {
  /***  error propagation along a particle trajectory in a magnetic field
   *    routine assumes that in the interval (X1,X2) the quantities 1/p
   *    and (Hx,Hy,Hz) are rather constant. Delta(Phi) must not be too large
   *    Authors: A. Haas And W. Wittek
   **** Iflag  =  -1   initialization, transformation of error matrix from
   *                   external to sc variables
   *           =   0   error propagation From X1 to X2
   *           =   1   transformation of error matrix from sc to
   *                   external variables
   *    Itran          used for Iflag = 0 or 1 only
   *           =   0   transformation matrix is updated ,but error matrix is not
   *                   transformed
   *          =    1   transf. matrix is updated  and error matrix is transformed
   *    Mvar           specifies type of external variables
   *           =   0   ( 1/p,lambda,phi,yt, zt ;   SC   )
   *           =   1   ( 1/p,  y',  z',  y,  z ; Spline )
   **** X1, P1, H1     x,y,z components of position, momentum and magnetic   Input
   *                   field vector/gradient at starting point of interval
   *    X2, P2, H2     ......  at end point of interval                      Input
   *    Ch             Charge Of Particle                                    Input
   *    Xl             Pathlength From X1 To X2   ( Negative If Opposite
   *                   To Actual Movement Of Particle )                      Input
   *    R              Error Matrix  (Triangle)                       Input/Output
   *    B              5 * 5 Transformation Matrix For Errors In
   *                   Sc Variables                                         Output
   **** Ierr   =  1    Illegal Value Of Mvar                                Output
   *              2    Momentum Is Zero
   *              3    H*Alfa/P At X1 And X2 Differ Too Much
   *                   Or Delta Phi Is Too Large
   *              4    Particle Moves In Z - Direction                             */
  static Int_t INIT = 0;
  if (Iflag < 0 ) {// 10, 20, 80
    //  transform error matrix from external to internal variables;
    new=1;
    if (Mvar == 1) return Trsxsp(P1,H1,Ch, R);
    else           return 1;
  }  
// error propagation on a helix assuming sc variables
  Double_t pa1 = P1.Mag();
  Double_t pa2 = P2.Mag();
  if (pa1*pa2 == 0.) return 2;
  Double_t pm1 =1./pa1;
  Double_t pm2 =1./pa2;
  TN = P1 + P2;
  TN = TN.Unit();
  sinl=TN(2);
  cosl = TMath::Sqrt(1 - sinl*sinl);
  if (cosl == 0.) return 4;
  cosl1=1./cosl;
  sinp=TN(1)*cosl1;
  cosp=TN(0)*cosl1;
// define transformation matrix between X1 and X2 for neutral particle or fieldfree region
  A = TRMatrix(TRArray::kUnit,5);
  A(3,2)=xL*cosl;
  A(4,1)=xL;
  if (Ch != 0.) {
    Double_t ha1 = H1.Mag();
    Double_t ha2 = H2.Mag();
    Double_t ham1=ha1*pm1;
    Double_t ham2 = ha2*pm2;
    Double_t hamx = TMath::Max(ham1,ham2);
    if (hamx != 0.) {
      // define average magnetic field and gradient
      Double_t pm12=(pm1+pm2)*0.5;
      Double_t p12=1./(2.*pm12);
      TVector3 HN = (pm1*H1 + pm2*H2)*Ch*CFACT8;
      Double_t B0=HN(0)*cosp+HN(1)*sinp;
      Double_t B2=-HN(0)*sinp+HN(1)*cosp;
      Double_t B3=-B0*sinl+HN(2)*cosl;
      Double_t TGL=sinl*cosl1;
      // check whether h*alfa/p is too different at X1 and X2 and whether change of track direction due to mag.field is too large
      Double_t gam = 0;
      if (ha2 == 0.) gam=(H1*TN)/ha1;
      else           gam=(H2*TN)/ha2;
      Double_t alfa=TMath::Sqrt(TMath::Abs(1.-gam**2));
      TVector3 H12 = pm1*H1 - pm2*H2;
      Double_t dh2 = H12.Mag();
      if (dh2*alfa*alfa > DELHP6*DELHP6) return 3;
      Double_t alfaQ=-alfa*CFACT8*(ham1+ham2)*0.5;
      Double_t dfi=TMath::Abs(xL*alfaQ);
      if (dfi > DELFI6) return 3;
      // complete transformation matrix between errors at X1 and X2
      // taking into account  field gradient perpendicular to track
      Double_t cosp2=cosp*cosp;
      Double_t sinp2=sinp*sinp;
      Double_t cosip=cosp*sinp;
#if 0
      Double_t G22=sinp2*HN(8)+cosp2*HN(7)-2.0*cosip*HN(6);
      Double_t G33=sinl*sinl*(cosp2*HN(8)+sinp2*HN(7)+2.0*cosip*HN(6))+cosl*(cosl*HN(5)-2.0*sinl*(cosp*HN(3)+sinp*HN(4)));
      Double_t G23=sinl*(cosip*(HN(8)-HN(7))+(sinp2-cosp2)*HN(6))     +cosl                     *(cosp*HN(4)-sinp*HN(3));
#else
      Double_t G22 = 0, G33 = 0; G23 = 0;
#endif
      Double_t dDdD[25] = {
	1.0,                          0.0,               0.0,                             0.0,                            0.0, 
	xL*B2,	                      1.0,       -B0*xL*pm12,        (B2*B3*pm12+G22)*xL*pm12,	    (-B2*B2*pm12+G23)*xL*pm12,
	-xL*B3*cosl1, B0*xL*pm12*cosl1**2, 1.+TGL*B2*xL*pm12, (-B3*B3*pm12-G23)*xL*pm12*cosl1,( B3*B2*pm12-G33)*xL*pm12*cosl1,
	xl,                           0.0,               1.0,                             0.0,                -B3*TGL*xL*pm12,
	0.0,                          0.0,               0.0,                  B3*TGL*xL*pm12,                            1.0};
      A = TRMatrix(5,5,dDdD);
    }
  }
  // new = 0  transformation matrix is updated
  //       1  transformation matrix is initialized
  if (new != 0) {
    new=0;
    B = A;
  } else {
      B = TRMatrix(A,TRArray::kAxB,B);
  }
  if (Itran != 0) S = TRSymMatrix(B,TRArray::kATxSxA,S);
  new=1;
  R = S;
  if (Iflag<= 0) return 0;
  // transform error matrix from internal to external variables;
  new=1;
  if (Mvar == 1) {
    Double_t pc[3];
    pc[0] =pm2;
    PC[1]=TMath::ASin(P2[2]*pc[0]);
    if (TMath::Abs (P2[0])   <  1.E-30) P2[0] = 1.E-30;
    pc[2] = TMath::ATan2 (P2[1],P2[0]);
    return  Trscsp(PC,R,PS,R,H2,Ch,spx);
  }
  if (Mvar != 0) return 1;
  return 0;
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trptsc(Double_t pc[3], Double_t rc[15], Double_t pd[3], Double_t rd[15]) {
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 PD(pd);  TRSymMatrix RD(5,rd);
  return Trptsc(PC,RC,PD,RD);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trptsc(const TVector3 &PC,const TRSymMatrix &RC,
				      TVector3 &PD,      TRSymMatrix &RD) {
C
// Transforms Error Matrix
C     From   Sc   Variables (1/Pt,Lambda,Phi,Yt,Zt)
C     From   Sc   Variables (1/P,Lambda,Phi,Yt,Zt)
 
 
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  PC,PD,RC,RD
#}
#include "geant321/trcom3.inc"
      DIMENSION PC(3),PD(3),RC(15),RD(15)
*
*______________________________________________________________________
*
      IERR = 0
      cosl  = TMath::Cos(PC(2))
      if  (TMath::Abs(cosl) == 0) return 1
      sinl  =    TMath::Sin(PC(2))
*
      PD(1) = PC(1)*cosl
      PD(2) = PC(2)
      PD(3) = PC(3)
*
      J=0
*
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
*
      A(1,1) = cosl
      A(2,2) = 1.D0
      A(3,3) = 1.D0
      A(4,4) = 1.D0
      A(5,5) = 1.D0
*
      A(1,2) = -PC(1)*sinl
C
      CALL SSMT5T(A,S,S)
C
      DO 25 J=1,15
        RD(J)=S(J)
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
}
//________________________________________________________________________________
Int_t StGeanePropagator::TRPTSD(Double_t pd[3],Double_t rd[15],Double_t pc[3],Double_t rc[15],
				Double_t h[3], Double_t Ch,
				Double_t spu, Double_t dj[3],Double_t dk[3]) {
  TVector3 PD(pd); TRSymMatrix RD(5,rd); 
  TVector3 PC(pc); TRSymMatrix RC(5,rc); 
  TVector3 H(h);
  TVector3 DJ(dj); TVector3 DK(dk);
  return Trptsd(PD,RD,PC,RC,H,Ch,spu,DJ,DK);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trptsd(const TVector3 PD,const TRSymMatrix RD,
				TVector3 &PC,TRSymMatrix &RC,
				const TVector3 H,Double_t Ch,Double_t  &spu,
				const TVector3 DJ,const TVector3 DK) {
*
//________________________________________________________________________________***
C
// TRANSFORMS ERROR MATRIX
C     FROM        VARIABLES (1/Pt,V',W',V,W)
C     FROM        VARIABLES (1/P, V',W',V,W)
C
C
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD,PC,H,RC,RD,Ch,DJ,DK,SPU
#}
#include "geant321/trcom3.inc"
      DIMENSION PD(3),PC(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
*
**_____________________________________________________________________
*
      Int_t Ierr = 0;
      TVW(1)=1./TMath::Sqrt(1.+PD(2)**2+PD(3)**2)
      if (SPU  < 0.) TVW(1)=-TVW(1)
      TVW(2)=PD(2)*TVW(1)
      TVW(3)=PD(3)*TVW(1)
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      DO 5 I=1,3
         TN(I)=TVW(1)*DI(I)+TVW(2)*DJ(I)+TVW(3)*DK(I)
    5 CONTINUE
C
      cosl=TMath::Sqrt(TMath::Abs(1.-TN(3)**2))
      if  (cosl   <  1.E-30) cosl = 1.E-30
      cosl1=1./cosl
      sinl  = TN(3)
*
      PC(1)=PD(1)*cosl
      PC(2)=PD(2)
      PC(3)=PD(3)
      pm=PC(1)
*
      if  (TMath::Abs (TN(1))   <  1.E-30) TN(1) = 1.E-30
C
      UN(1)=-TN(2)*cosl1
      UN(2)=TN(1)*cosl1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
 
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD(J)
    4    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
C
      q=-ham*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(1,4)=q*TVW(2)*SINZ*(sinl*PD(1))
      A(1,5)=q*TVW(3)*SINZ*(sinl*PD(1))
C
6     continue
      A(1,1) = cosl
      A(2,2) = 1.
      A(3,3) = 1.
      A(4,4) = 1.
      A(5,5) = 1.
*
      A(1,2)=-TVW(1)*VJ*(sinl*PD(1))
      A(1,3)=-TVW(1)*VK*(sinl*PD(1))
C
      CALL SSMT5T(A,S,S)
C
      DO J=1,15
        RC(J)=S(J)
  
}
*
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trs1s2 (Double_t pd1[3], Double_t rd1[3], 
				 Double_t pd2[3], Double_t rd2[3], 
				 Double_t h[3], Double_t Ch, Double_t sp1, Double_t &sp2, 
				 Double_t dj1[3], Double_t dk1[3], 
				 Double_t dj2[3], Double_t dk2[3]) {
  TVector3 PD1(rd1); TRSymMatrix RD1(5,rd1);
  TVector3 PD2(rd2); TRSymMatrix RD1(5,rd2);
  TVector3 H(h);
  TVector3 DJ1(dj1); TVector3 DK1(dk1);
  TVector3 DJ2(dj2); TVector3 DK2(dk2);
  return Trs1s2 (PD1,RD1,PD2,RD2,H,Ch,sp1,sp2,DJ1,DK1,DJ2,DK2);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trs1s2 (const TVector3 &PD1,const TRSymMatrix &RD1,
				       TVector3 &PD2,      TRSymMatrix &RD2,
				 const TVector3 &H,const Double_t &Ch,
				 const Double_t &sp1,Double_t &sp2
				 const TVector3 &DJ1,const TVector3 &DK1,
				 const TVector3 &DJ2,const TVector3 &DK2) {
C
// Transforms Error Matrix
C     From        Variables (1/P,V1',W1',V1,W1)
C      To         Variables (1/P,V2',W2',V2,W2)
C
C     Authors: A. Haas And W. Wittek
C
C
// Pd1(3)    1/P,V1',W1'                             Input
C     Pd2(3)    1/P,V2',W2'                            Output
C     H(3)      Magnetic Field                          Input
C     Rd1(15)   Error Matrix In 1/P,V1',W1',V1,W1       Input      (Triangle)
C     Rd2(15)   Error Matrix In 1/P,V2',W2',V2,W2      Output      (Triangle)
C     Ch        Charge Of Particle                      Input
C               Charge And Magnetic Field Are Needed
C               For Correlation Terms (V2',V1),(V2',W1),(W2',V1),(W2',W1)
C               These Correlation Terms Appear Because Rd1 Is Assumed
C               To Be The Error Matrix For Fixed U1
C               And Rd2 For Fixed U2
C     Sp1       Sign Of U1-Component Of Particle Momentum     Input
C     Sp2       Sign Of U2-Component Of Particle Momentum    Output
C     Dj1(3)    Unit Vector In V1-Direction
C     Dk1(3)    Unit Vector In W1-Direction    Of System 1
C     Dj2(3)    Unit Vector In V2-Direction
C     Dk2(3)    Unit Vector In W2-Direction    Of System 2
C
C     Ierr      = 0    Transformation Ok
C               = 1    Momentum Perpendicular To U2-Direction (V2',W2' Not Defin
C               = 2    Momentum Perpendicular To X-Axis
C
C
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD1,PD2,RD1,RD2,H,Ch,SP1,SP2,DJ1,DK1,DJ2,DK2
#}
#include "geant321/trcom3.inc"
      DIMENSION PD1(3),PD2(3),RD1(15),RD2(15),H(3),DJ1(3),DK1(3)
     +,DJ2(3),DK2(3),UN(3),VN(3),DI1(3),DI2(3),TVW1(3),TVW2(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
C
      Int_t Ierr = 0;
      pm=PD1(1)
      TVW1(1)=1./TMath::Sqrt(1.+PD1(2)**2+PD1(3)**2)
      if (SP1  < 0.) TVW1(1)=-TVW1(1)
      TVW1(2)=PD1(2)*TVW1(1)
      TVW1(3)=PD1(3)*TVW1(1)
C
      DI1(1)=DJ1(2)*DK1(3)-DJ1(3)*DK1(2)
      DI1(2)=DJ1(3)*DK1(1)-DJ1(1)*DK1(3)
      DI1(3)=DJ1(1)*DK1(2)-DJ1(2)*DK1(1)
C
      DO 5 I=1,3
         TN(I)=TVW1(1)*DI1(I)+TVW1(2)*DJ1(I)+TVW1(3)*DK1(I)
    5 CONTINUE
C
      DI2(1)=DJ2(2)*DK2(3)-DJ2(3)*DK2(2)
      DI2(2)=DJ2(3)*DK2(1)-DJ2(1)*DK2(3)
      DI2(3)=DJ2(1)*DK2(2)-DJ2(2)*DK2(1)
C
      TVW2(1)=TN(1)*DI2(1)+TN(2)*DI2(2)+TN(3)*DI2(3)
      TVW2(2)=TN(1)*DJ2(1)+TN(2)*DJ2(2)+TN(3)*DJ2(3)
      TVW2(3)=TN(1)*DK2(1)+TN(2)*DK2(2)+TN(3)*DK2(3)
C
      if (TVW2(1) == 0.) return 1
      TR=1./TVW2(1)
      SP2=1.
      if (TVW2(1)  < 0.) SP2=-1.
      PD2(1)=PD1(1)
      PD2(2)=TVW2(2)*TR
      PD2(3)=TVW2(3)*TR
C
      cosl=TMath::Sqrt(TMath::Abs(1.-TN(3)**2))
      if (cosl == 0.) return 2
      cosl1=1./cosl
      UN(1)=-TN(2)*cosl1
      UN(2)=TN(1)*cosl1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
C
      UJ1=UN(1)*DJ1(1)+UN(2)*DJ1(2)+UN(3)*DJ1(3)
      UK1=UN(1)*DK1(1)+UN(2)*DK1(2)+UN(3)*DK1(3)
      VJ1=VN(1)*DJ1(1)+VN(2)*DJ1(2)+VN(3)*DJ1(3)
      VK1=VN(1)*DK1(1)+VN(2)*DK1(2)+VN(3)*DK1(3)
C
      UJ2=UN(1)*DJ2(1)+UN(2)*DJ2(2)+UN(3)*DJ2(3)
      UK2=UN(1)*DK2(1)+UN(2)*DK2(2)+UN(3)*DK2(3)
      VJ2=VN(1)*DJ2(1)+VN(2)*DJ2(2)+VN(3)*DJ2(3)
      VK2=VN(1)*DK2(1)+VN(2)*DK2(2)+VN(3)*DK2(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD1(J)
    4    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
C
      q=-ham*CFACT8
      TT=-q*TR**3
      SJ1I2=DJ1(1)*DI2(1)+DJ1(2)*DI2(2)+DJ1(3)*DI2(3)
      SK1I2=DK1(1)*DI2(1)+DK1(2)*DI2(2)+DK1(3)*DI2(3)
      SK2U=DK2(1)*UN(1)+DK2(2)*UN(2)+DK2(3)*UN(3)
      SK2V=DK2(1)*VN(1)+DK2(2)*VN(2)+DK2(3)*VN(3)
      SJ2U=DJ2(1)*UN(1)+DJ2(2)*UN(2)+DJ2(3)*UN(3)
      SJ2V=DJ2(1)*VN(1)+DJ2(2)*VN(2)+DJ2(3)*VN(3)
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-TT*SJ1I2*(SK2U*SINZ-SK2V*COSZ)
      A(2,5)=-TT*SK1I2*(SK2U*SINZ-SK2V*COSZ)
      A(3,4)= TT*SJ1I2*(SJ2U*SINZ-SJ2V*COSZ)
      A(3,5)= TT*SK1I2*(SJ2U*SINZ-SJ2V*COSZ)
C
    6 A(1,1)=1.
      A(4,4)=TR*(UJ1*VK2-VJ1*UK2)
      A(4,5)=TR*(UK1*VK2-VK1*UK2)
      A(5,4)=TR*(VJ1*UJ2-UJ1*VJ2)
      A(5,5)=TR*(VK1*UJ2-UK1*VJ2)
C
      TS=TR*TVW1(1)
      A(2,2)=A(4,4)*TS
      A(2,3)=A(4,5)*TS
      A(3,2)=A(5,4)*TS
      A(3,3)=A(5,5)*TS
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RD2(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
  901 IERR=1
      GO TO 910
  902 IERR=2
  910 RETURN
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscpt(const Double_t pc[3],const Double_t rc[15],
				      Double_t pd[3],      Double_t rd[15]) {
  
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 PD(pd);  TRSymMatrix RD(5,rd);
  return Trscpt(PC,RC,PD,RD);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscpt(const TVector3 &PC,const TRSymMatrix &RC,
				      TVector3 &PD,      TRSymMatrix &RD) {
C
// TRANSFORMS ERROR MATRIX
C     FROM   SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C     FROM   SC   VARIABLES (1/Pt,LAMBDA,PHI,YT,ZT)
 
 
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  PC,PD,RC,RD
#}
#include "geant321/trcom3.inc"
      DIMENSION PC(3),PD(3),RC(15),RD(15)
*
*______________________________________________________________________
*
      IERR = 0
      cosl  = TMath::Cos(PC(2))
      if  (TMath::Abs(cosl) == 0) return 1
      cosl1 = 1./cosl
      TANL  =    TAN(PC(2))
*
      PD(1) = PC(1)*cosl1
      PD(2) = PC(2)
      PD(3) = PC(3)
*
      J=0
*
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
*
      A(1,1) = cosl1
      A(2,2) = 1.D0
      A(3,3) = 1.D0
      A(4,4) = 1.D0
      A(5,5) = 1.D0
*
      A(1,2) = PD(1)*TANL
C
      CALL SSMT5T(A,S,S)
C
      DO 25 J=1,15
        RD(J)=S(J)
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscsd(const Double_t pc[3],const Double_t rc[15]
				,     Double_t pd[3],      Double_t rd[15],
				const Double_t h[3],Double_t Ch, Double_t &spu,
				const Double_t dj[3],const Double_t dk[3]) {
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 PD(pd);  TRSymMatrix RD(5,rd);
  TVector3 H(h);
  TVector3 DJ(dj); TVector3 DK(dk);
  return Trscsd(PC,RC,PD,RD,H,Ch,spu,DJ,DK);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscsd(const TVector3 &PC,const TRSymMatrix &RC
				,     TVector3 &PD,      TRSymMatrix &RD,
				const TVector3 &H,Double_t Ch,Double_t &spu,
				const TVector3 &DJ,const TVector3 &DK) {
C
// Transforms Error Matrix
C     From   Sc   Variables (1/P,Lambda,Phi,Yt,Zt)
C      To         Variables (1/P,V',W',V,W)
C
C     Authors: A. Haas And W. Wittek
C
C
// Pc(3)     1/P,Lambda,Phi                          Input
C     Pd(3)     1/P,V',W'                              Output
C     H(3)      Magnetic Field                          Input
C     Rc(15)    Error Matrix In   Sc   Variables        Input     (Triangle)
C     Rd(15)    Error Matrix In 1/P,V',W',V,W          Output     (Triangle)
C     Ch        Charge Of Particle                      Input
C               Charge And Magnetic Field Are Needed
C               For Correlation Terms (V',Yt),(V',Zt),(W',Yt),(W',Zt)
C               These Correlation Terms Appear Because Rc Is Assumed
C               To Be The Error Matrix For Fixed S (Path Length)
C               And Rd For Fixed U
C     Dj(3)     Unit Vector In V-Direction
C     Dk(3)     Unit Vector In W-Direction    Of Detector System
C
C     Ierr  =   1       Particle Moves Perpendicular To U-Axis
C                      ( V',W' Are Not Defined )
C     Spu       Sign Of U-Component Of Particle Momentum   Output
C
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  PC,PD,H,RC,RD,Ch,DJ,DK,SPU
#}
#include "geant321/trcom3.inc"
      DIMENSION PC(3),PD(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
C
      Int_t Ierr = 0;
      pm=PC(1)
      cosl=TMath::Cos(PC(2))
      sinp=TMath::Sin(PC(3))
      cosp=TMath::Cos(PC(3))
C
      TN(1)=cosl*cosp
      TN(2)=cosl*sinp
      TN(3)=TMath::Sin(PC(2))
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      TVW(1)=TN(1)*DI(1)+TN(2)*DI(2)+TN(3)*DI(3)
      SPU=1.
      if (TVW(1)  < 0.) SPU=-1.
      TVW(2)=TN(1)*DJ(1)+TN(2)*DJ(2)+TN(3)*DJ(3)
      TVW(3)=TN(1)*DK(1)+TN(2)*DK(2)+TN(3)*DK(3)
      if (TVW(1) == 0.) return 1
C
      T1R=1./TVW(1)
      PD(1)=PC(1)
      PD(2)=TVW(2)*T1R
      PD(3)=TVW(3)*T1R
C
      UN(1)=-sinp
      UN(2)=cosp
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
C
      J=0
 
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
      q=-ham*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      T3R=q*T1R**3
      UI=UN(1)*DI(1)+UN(2)*DI(2)+UN(3)*DI(3)
      VI=VN(1)*DI(1)+VN(2)*DI(2)+VN(3)*DI(3)
      A(2,4)=-UI*(VK*COSZ-UK*SINZ)*T3R
      A(2,5)=-VI*(VK*COSZ-UK*SINZ)*T3R
      A(3,4)= UI*(VJ*COSZ-UJ*SINZ)*T3R
      A(3,5)= VI*(VJ*COSZ-UJ*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,2)=-UK*T2R
      A(2,3)=VK*cosl*T2R
      A(3,2)=UJ*T2R
      A(3,3)=-VJ*cosl*T2R
      A(4,4)=VK*T1R
      A(4,5)=-UK*T1R
      A(5,4)=-VJ*T1R
      A(5,5)=UJ*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RD(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscsp(const Double_t pc[3],const Double_t rc[15],
				Double_t ps[3],Double_t rs[15],const Double_t h[3],
				Double_t Ch,Double_t &spx) {
  TVector3 PC(pc); TRSymMatrix RC(5,rc);
  TVector3 PS(ps); TRSymMatrix RS(5,rs);
  TVector3 H(h);
  return Trscsp(PC,RC,PS,RS,H,Ch,spx);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trscsp(const TVector3 &PC,const TRSymMatrix &RC,
				TVector3 &PS,TRSymMatrix &RS,
				const TVector3 H,Double_t Ch,Double_t &spx) {
C
// Transforms Error Matrix
C     From   Sc   Variables (1/P,Lambda,Phi,Yt,Zt)
C      To  Spline Variables (1/P,Y',Z',Y,Z)
C
C     Authors: A. Haas And W. Wittek
C
C
// Pc(3)     1/P,Lambda,Phi                          Input
C     Ps(3)     1/P,Y',Z'                              Output
C     H(3)      Magnetic Field                          Input
C     Rc(15)    Error Matrix In   Sc   Variables        Input     (Triangle)
C     Rs(15)    Error Matrix In Spline Variables       Output     (Triangle)
C     Ch        Charge Of Particle                      Input
C               Charge And Magnetic Field Are Needed
C               For Correlation Terms (Y',Yt),(Y',Zt),(Z',Yt),(Z',Zt)
C               These Correlation Terms Appear Because Rc Is Assumed
C               To Be The Error Matrix For Fixed S (Path Length)
C               And Rs For Fixed X
C
C     Ierr  =   1       Particle Moves Perpendicular To X-Axis
C                      ( Y',Z' Are Not Defined )
C     Spx       Sign Of X-Component Of Particle Momentum   Output
C
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PC,PS,H,RC,RS,Ch,spx
#}
#include "geant321/trcom3.inc"
      DIMENSION PC(3),PS(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
C
      Int_t Ierr = 0;
      pm=PC(1)
      cosl=TMath::Cos(PC(2))
      sinp=TMath::Sin(PC(3))
      cosp=TMath::Cos(PC(3))
C
      TN(1)=cosl*cosp
      spx=1.
      if (TN(1)  < 0.) spx=-1.
      if (TN(1) == 0.) return 1
      TN(2)=cosl*sinp
      TN(3)=TMath::Sin(PC(2))
C
      T1R=1./TN(1)
      PS(1)=PC(1)
      PS(2)=sinp/cosp
      PS(3)=TN(3)*T1R
C
      UN(1)=-sinp
      UN(2)=cosp
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
C
      J=0
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
      q=-ham*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
 
      T3R=q*T1R**3
      A(2,4)=-UN(1)*(VN(3)*COSZ           )*T3R
      A(2,5)=-VN(1)*(VN(3)*COSZ           )*T3R
      A(3,4)=UN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
      A(3,5)=VN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,3)=VN(3)*cosl*T2R
      A(3,2)=UN(2)*T2R
      A(3,3)=-VN(2)*cosl*T2R
      A(4,4)=VN(3)*T1R
      A(5,4)=-VN(2)*T1R
      A(5,5)=UN(2)*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RS(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trsdpt(const Double_t pd[3],const Double_t rd[15]
				,     Double_t pc[3],      Double_t rc[15], 
				Double_t h[3], Double_t Ch,Double_t &spu,
				const Double_t dj[3],const Double_t dk[3]) {
  TVector3 PD(pd);  TRSymMatrix RD(5,rd);
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 H(h);
  TVector3 DJ(dj); TVector3 DK(dk);
  return Trsdpt(PD,RD,PC,RC,H,Ch,spu,DJ,DK);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trsdpt(const TVector3 &PD,const TRSymMatrix &RD
				,     TVector3  PC,      TRSymMatrix &RC,
				const TVector3 &H,Double_t Ch,Double_t &spu,
				const TVector3 &DJ,const TVector3 &DK) {
*
//________________________________________________________________________________
C
// TRANSFORMS ERROR MATRIX
C     FROM        VARIABLES (1/P,V',W',V,W)
C     FROM        VARIABLES (1/Pt,V',W',V,W)
C
C
#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD,PC,H,RC,RD,Ch,DJ,DK,SPU
#}
#include "geant321/trcom3.inc"
      DIMENSION PD(3),PC(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
*
**_____________________________________________________________________
*
      Int_t Ierr = 0;
      pm=PD(1)
      TVW(1)=1./TMath::Sqrt(1.+PD(2)**2+PD(3)**2)
      if (SPU  < 0.) TVW(1)=-TVW(1)
      TVW(2)=PD(2)*TVW(1)
      TVW(3)=PD(3)*TVW(1)
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      DO 5 I=1,3
         TN(I)=TVW(1)*DI(I)+TVW(2)*DJ(I)+TVW(3)*DK(I)
    5 CONTINUE
C
      cosl=TMath::Sqrt(TMath::Abs(1.-TN(3)**2))
      if  (cosl   <  1.E-30) cosl = 1.E-30
      cosl1=1./cosl
      TANL  = TN(3)*cosl1
*
      PC(1)=PD(1)*cosl1
      PC(2)=PD(2)
      PC(3)=PD(3)
*
      if  (TMath::Abs (TN(1))   <  1.E-30) TN(1) = 1.E-30
C
      UN(1)=-TN(2)*cosl1
      UN(2)=TN(1)*cosl1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
 
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD(J)
    4    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
C
      q=-ham*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(1,4)=-q*TVW(2)*SINZ*(TANL*PC(1))
      A(1,5)=-q*TVW(3)*SINZ*(TANL*PC(1))
C
6     continue
      A(1,1) = cosl1
      A(2,2) = 1.
      A(3,3) = 1.
      A(4,4) = 1.
      A(5,5) = 1.
*
      A(1,2)=TVW(1)*VJ*(TANL*PC(1))
      A(1,3)=TVW(1)*VK*(TANL*PC(1))
C
      CALL SSMT5T(A,S,S)
C
      DO J=1,15
        RC(J)=S(J)
}DO
*
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trsdsc(const Double_t pd[3],const Double_t rd[15]
				,     Double_t pc[3],      Double_t rc[15], 
				Double_t h[3], Double_t ch,Double_t &spu,
				const Double_t dj[3],const Double_t dk[3]) {
  TVector3 PD(pd);  TRSymMatrix RD(5,rd);
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 H(h);
  TVector3 DJ(dj); TVector3 DK(dk);
  return Trsdsc(PD,RD,PC,RC,H,ch,spu,DJ,DK);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trsdsc(const TVector3 &PD,const TRSymMatrix &RD
				,     TVector3  PC,      TRSymMatrix &RC,
				const TVector3 &H,Double_t ch,Double_t &spu,
				const TVector3 &DJ,const TVector3 &DK) {
C
// Transforms Error Matrix
C     From        Variables (1/P,V',W',V,W)
C      To    Sc   Variables (1/P,Lambda,Phi,Yt,Zt)
C
C     Authors: A. Haas And W. Wittek
C
C
// Pd(3)     1/P,V',W'                               Input
C     Pc(3)     1/P,Lambda,Phi                         Output
C     H(3)      Magnetic Field                          Input
C     Rd(15)    Error Matrix In 1/P,V',W',V,W           Input      (Triangle)
C     Rc(15)    Error Matrix In   Sc   Variables       Output      (Triangle)
C     Ch        Charge Of Particle                      Input
C               Charge And Magnetic Field Are Needed
C               For Correlation Terms (Lambda,V),(Lambda,W),(Phi,V),(Phi,W)
C               These Correlation Terms Appear Because Rc Is Assumed
C               To Be The Error Matrix For Fixed S (Path Length)
C               And Rd For Fixed U
C     Dj(3)     Unit Vector In V-Direction
C     Dk(3)     Unit Vector In W-Direction    Of Detector System
C
C     Ierr              Not Used
C     Spu       Sign Of U-Component Of Particle Momentum    Input
C

#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD,PC,H,RC,RD,Ch,DJ,DK,SPU
#}
#include "geant321/trcom3.inc"
      DIMENSION PD(3),PC(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
C
      Int_t Ierr = 0;
      pm=PD(1)
      TVW(1)=1./TMath::Sqrt(1.+PD(2)**2+PD(3)**2)
      if (SPU  < 0.) TVW(1)=-TVW(1)
      TVW(2)=PD(2)*TVW(1)
      TVW(3)=PD(3)*TVW(1)
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      DO 5 I=1,3
         TN(I)=TVW(1)*DI(I)+TVW(2)*DJ(I)+TVW(3)*DK(I)
    5 CONTINUE
C
      PC(1)=PD(1)
      PC(2)=ATMath::Sin(TN(3))
      if  (TMath::Abs (TN(1))   <  1.E-30) TN(1) = 1.E-30
      PC(3) = TMath::ATan2 (TN(2),TN(1))
C
      cosl=TMath::Sqrt(TMath::Abs(1.-TN(3)**2))
      if  (cosl   <  1.E-30) cosl = 1.E-30
      cosl1=1./cosl
      UN(1)=-TN(2)*cosl1
      UN(2)=TN(1)*cosl1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
 
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD(J)
    4    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if (ham == 0.) GO TO 6
      HM=Ch/ha
C
      q=-ham*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-q*TVW(2)*SINZ
      A(2,5)=-q*TVW(3)*SINZ
      A(3,4)=-q*TVW(2)*COSZ*cosl1
      A(3,5)=-q*TVW(3)*COSZ*cosl1
C
    6 A(1,1)=1.
      A(2,2)=TVW(1)*VJ
      A(2,3)=TVW(1)*VK
      A(3,2)=TVW(1)*UJ*cosl1
      A(3,3)=TVW(1)*UK*cosl1
      A(4,4)=UJ
      A(4,5)=UK
      A(5,4)=VJ
      A(5,5)=VK
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
// ERROR EXITS
C
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trspsc(const Double_t ps[3],const Double_t rs[15]
				,     Double_t pc[3],      Double_t rc[15],
				const Double_t h[3],Double_t ch,Double_t &spx) {
  
  TVector3 PS(ps);  TRSymMatrix RS(5,rs);
  TVector3 PC(pc);  TRSymMatrix RC(5,rc);
  TVector3 H(h);
  return Trspsc(PS,RS,PC,RC,H,ch,spx);
}
//________________________________________________________________________________
Int_t StGeanePropagator::Trspsc(const TVector3 &PS,const TRSymMatrix &RS
				,     TVector3 &PC,      TRSymMatrix &RC,
				const TVector3 &H,Double_t ch,Double_t &spx) {
C
// Transforms Error Matrix
C     From Spline Variables (1/P,Y',Z',Y,Z)
C      To    Sc   Variables (1/P,Lambda,Phi,Yt,Zt)
C
C     Authors: A. Haas And W. Wittek
C
C
// Ps(3)     1/P,Y',Z'                               Input
C     Pc(3)     1/P,Lambda,Phi                         Output
C     H(3)      Magnetic Field                          Input
C     Rs(15)    Error Matrix In Spline Variables        Input      (Triangle)
C     Rc(15)    Error Matrix In   Sc   Variables       Output      (Triangle)
C     Ch        Charge Of Particle                      Input
C               Charge And Magnetic Field Are Needed
C               For Correlation Terms (Lambda,Y),(Lambda,Z),(Phi,Y),(Phi,Z)
C               These Correlation Terms Appear Because Rc Is Assumed
C               To Be The Error Matrix For Fixed S (Path Length)
C               And Rs For Fixed X
C
C     Ierr              Not Used
C     Spx       Sign Of X-Component Of Particle Momentum    Input
C

#if !defined(CERNLIB_SINGLE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PS,PC,H,RC,RS,Ch,spx
#}
#include "geant321/trcom3.inc"
      DIMENSION PS(3),PC(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
#if defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 E-4 /
#}
#if !defined(CERNLIB_SINGLE)
      DATA CFACT8 / 2.997925 D-4 /
#}
C
      Int_t Ierr = 0;
      pm=PS(1)
      TN(1)=1./TMath::Sqrt(1.+PS(2)**2+PS(3)**2)
      if (spx  < 0.) TN(1)=-TN(1)
      TN(2)=PS(2)*TN(1)
      TN(3)=PS(3)*TN(1)
C
      PC(1)=PS(1)
      PC(2)=ATMath::Sin(TN(3))
      if  (TMath::Abs (TN(1))   <  1.E-30) TN(1) = 1.E-30
      PC(3) = TMath::ATan2 (TN(2),TN(1))
C
      cosl=TMath::Sqrt(TMath::Abs(1.-TN(3)**2))
      if  (cosl   <  1.E-30) cosl = 1.E-30
      cosl1=1./cosl
      UN(1)=-TN(2)*cosl1
      UN(2)=TN(1)*cosl1
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=cosl
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RS(J)
    4    CONTINUE
   10 CONTINUE
C
      if (Ch == 0.) GO TO 6
 
      ha=TMath::Sqrt(H(1)**2+H(2)**2+H(3)**2)
      ham=ha*pm
      if !(ham == 0.) GO TO 6
      HM=Ch/ha
C
      q=-ham*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-q*TN(2)*SINZ
      A(2,5)=-q*TN(3)*SINZ
      A(3,4)=-q*TN(2)*COSZ*cosl1
      A(3,5)=-q*TN(3)*COSZ*cosl1
C
    6 A(1,1)=1.
      A(2,2)=TN(1)*VN(2)
      A(2,3)=TN(1)*VN(3)
      A(3,2)=TN(1)*UN(2)*cosl1
      A(4,4)=UN(2)
      A(5,4)=VN(2)
      A(5,5)=VN(3)
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
*
//  ERROR EXITS
*
}
